import{v as j}from"https://app.framerstatic.com/chunk-CQ6F5PRQ.mjs";import{j as n}from"https://app.framerstatic.com/chunk-AHQIRSXG.mjs";var f;(e=>e.log=j("\u{1F4A9} fallback-logger-please-reassign:services"))(f||={});(s=>{s._isTesting=!1;let e;async function t(i,a){if(!s._isTesting)throw new Error("ServiceManager.isTesting must be true to use testWithShared()");if(e)throw new Error("ServiceManager.testWithShared() may not be nested");try{return e=i,await a()}finally{e=void 0}}s._testWithShared=t;function r(){if(s._isTesting){if(e)return e;throw new Error("ServiceManager.shared() may not be used while testing. Use testWithShared() for explicitness.")}}s._sharedServiceManagerIfTesting=r})(f||={});var m;(s=>{s.onewayRequestId="oneway",s.onewayStreamResponseIdPrefix="#oneway:";let t;(l=>(l.Request="request",l.Response="response",l.Error="error"))(t=s.MessageType||={});function r(i){return typeof i!="object"?!1:i.type==="request"||i.type==="response"||i.type==="error"}s.isMessage=r})(m||={});function P(o,e){throw e||new Error("Unexpected object: "+o)}var c=class extends Error{constructor(){super(...arguments);n(this,"name","ServiceError.UnknownError");n(this,"code",0);n(this,"status",0);n(this,"skipSentry",!1)}};(p=>{let o;(S=>(S[S.serviceNotFound=404]="serviceNotFound",S[S.serviceNotCompatible=426]="serviceNotCompatible",S[S.serviceGone=410]="serviceGone",S[S.implementation=500]="implementation",S[S.timedOut=504]="timedOut",S[S.badRequest=400]="badRequest",S[S.badResponse=422]="badResponse"))(o=p.Code||={});class e extends p{constructor(){super(...arguments);n(this,"code",404);n(this,"name","ServiceError.ServiceNotFound")}}p.ServiceNotFound=e;class t extends p{constructor(){super(...arguments);n(this,"code",426);n(this,"name","ServiceError.ServiceNotCompatible")}}p.ServiceNotCompatible=t;class r extends p{constructor(){super(...arguments);n(this,"code",410);n(this,"name","ServiceError.ServiceGone");n(this,"skipSentry",!0)}}p.ServiceGone=r;class s extends p{constructor(){super(...arguments);n(this,"code",500);n(this,"name","ServiceError.Implementation")}}p.Implementation=s;class i extends p{constructor(){super(...arguments);n(this,"code",504);n(this,"name","ServiceError.TimedOut")}}p.TimedOut=i;class a extends p{constructor(){super(...arguments);n(this,"code",400);n(this,"name","ServiceError.BadRequest")}}p.BadRequest=a;class v extends p{constructor(y,C){super(y);n(this,"code",422);n(this,"name","ServiceError.BadResponse");n(this,"response");this.response=C}}p.BadResponse=v;function l(d){if(!d)return new v;let u;A(d)&&(u=d.message);let y=h(d.code,u);return V(d)&&(y.code=d.code),W(d)&&(y.stack=d.stack),_(d)&&(y.skipSentry=d.skipSentry),z(d)&&(y.status=d.status),y}p.reconstructErrorResponse=l;function h(d,u){try{let y=d;switch(y){case 404:return new e(u);case 426:return new t(u);case 410:return new r(u);case 500:return new s(u);case 504:return new i(u);case 400:return new a(u);case 422:return new v(u);default:P(y)}}catch{return new p(u)}}function b(d){if(d instanceof p)return{code:d.code,message:d.message,stack:d.stack,skipSentry:d.skipSentry};let u,y,C,N,L;return typeof d=="string"?u=d:A(d)&&(u=d.message),W(d)&&(y=d.stack),_(d)&&(C=d.skipSentry),V(d)&&(N=d.code),z(d)&&(L=d.status),{code:N,message:u,stack:y,skipSentry:C,status:L}}p.toMessageBody=b})(c||={});function A(o){return typeof o=="object"&&o&&"message"in o&&typeof o.message=="string"}function W(o){return typeof o=="object"&&o&&"stack"in o&&typeof o.stack=="string"}function _(o){return typeof o=="object"&&o&&"skipSentry"in o&&typeof o.skipSentry=="boolean"}function V(o){return typeof o=="object"&&o&&"code"in o&&typeof o.code=="number"}function z(o){return typeof o=="object"&&o&&"status"in o&&typeof o.status=="number"}function ne(o){f.log.error(o)}var w;(r=>{let o=Math.random;function e(){return`${o()}`}r.generateUniqueId=e;function t(){let s,i,a=new Promise((v,l)=>{s=v,i=l});return a.resolve=s,a.reject=i,a}r.newResolvablePromise=t})(w||={});var T;(t=>{function o(r){if(!r)return!1;switch(r.replay){case"latest":case void 0:break;default:return!1}return!0}t.isServiceStreamOptions=o;class e{constructor(s,i,a){this.method=s;this.options=i;this.helper=a;n(this,"oneway");n(this,"onewayCallback");n(this,"iterator");n(this,"cancelled",!1);n(this,"resolveCancelPromise");n(this,"rejectCancelPromise");this.oneway=i?.oneway??!1}[Symbol.asyncIterator](){if(this.oneway)throw new c.BadRequest("Cannot read a oneway stream through an AsyncIterator. Use read() with a void callback instead.");return this.iterator=this.newIterator(),this.iterator}async read(s){for(this.iterator=this.newIterator(),this.oneway&&(this.onewayCallback=i=>{if(!U(i))throw new c.BadResponse("StreamReader.onewayCallback received an invalid iterator result");if(i.done)return;if(s(i.value))throw new c.BadRequest("ServiceStream callbacks cannot be async if oneway = true.")});;){let i=await this.iterator.next();if(i.done)return;await s(i.value)}}async cancel(){this.cancelled=!0,await this.iterator?.return?.()}newIterator(){if(this.iterator)throw new c.BadRequest("ServiceStream instances can only be read once. If multiple AsyncIterators or read() calls are required, create a new stream for each by calling the associated service method. To broadcast events with an observer pattern, consider using a client-specific EventEmitter or similar.");let s=w.generateUniqueId(),i={done:!0,value:void 0},a=async h=>{if(!U(h))throw new c.BadResponse("StreamReader.next received an invalid iterator result for next()");return h},v=async()=>{try{let h=await this.helper({method:this.method,argument:this.options,stream:{id:s,method:"next"}},this.onewayCallback);return await a(h)}catch(h){throw this.cancelled=!0,h}},l=async()=>(this.cancelled||await new Promise((h,b)=>{this.resolveCancelPromise=h,this.rejectCancelPromise=b}),i);return{next:async()=>this.cancelled?i:Promise.race([v(),l()]),return:async()=>(this.cancelled=!0,this.resolveCancelPromise?.(),this.helper({method:this.method,stream:{id:s,method:"return"}}),i),throw:async h=>(this.cancelled=!0,this.rejectCancelPromise?.(h),this.helper({method:this.method,stream:{id:s,method:"return"}}),i)}}}t.StreamReader=e})(T||={});function U(o){return o?o.done===!0||o.done===!1&&o.value!==void 0:!1}var E=class{constructor(e){this.log=e;n(this,"expectWithoutDiscovery",(e,t)=>this.addRouter(t).expectWithoutDiscovery(e));n(this,"discover",async(e,t,r={})=>this.addRouter(t).discover(e,r));n(this,"unregister",async e=>{let t=[];for(let r of this.routers)r.channel===e&&t.push(r);if(t.length>0)for(let r of t)await r.unregisterAllImplementations(),this.routers.delete(r),r.destroy();else for(let r of this.routers)await r.unregisterImplementation(e)});n(this,"routers",new Set);n(this,"addRouter",e=>{for(let r of this.routers)if(r.channel===e)return r;let t=new O(e,this.log);return this.routers.add(t),t});n(this,"testable",{onlyRouter:()=>{if(this.routers.size!==1)throw new Error(`onlyRouter called on a ServiceManager with ${this.routers.size} routers, expected 1`);return this.routers.values().next().value}})}register(e){function t(r){return"service"in r&&"implementation"in r&&r.service!==void 0&&r.implementation!==void 0}return t(e)?(this.addRouter(e.channel).registerImplementation(e.implementation,e.service),()=>void this.unregister(e.implementation)):(this.addRouter(e.channel),()=>void this.unregister(e.channel))}};(t=>{let o;function e(){return o=o??new t,f._sharedServiceManagerIfTesting()??o}t.shared=e})(E||={});var O=class{constructor(e,t){this.channel=e;this.customLogger=t;n(this,"onMessage",e=>{try{e.type===m.MessageType.Request?e.id===m.onewayRequestId?this.onOnewayRequest(e):this.onRequest(e):e.type===m.MessageType.Response?e.method===M.method?this.onDiscoveryResponse(e):this.onResponse(e):e.type===m.MessageType.Error?this.onErrorResponse(e):P(e.type,new Error(`Unknown message: ${JSON.stringify(e)}`))}catch(t){this.log.reportError(t,{message:e})}});n(this,"latestDiscoveryInfo");n(this,"waitingDiscoveryMap",{});n(this,"reflectDiscoveredServices",()=>{let e=this.latestDiscoveryInfo?Object.keys(this.latestDiscoveryInfo.services):[],t;this.channel.disabled&&(e=Object.keys(this.waitingDiscoveryMap),t=new c.ServiceNotFound);for(let r of e){let s=this.waitingDiscoveryMap[r];s&&(this.waitingDiscoveryMap[r]=[],s.forEach(i=>t?i.reject(t):i.resolve()))}});n(this,"onDiscoveryResponse",e=>{if(M.isValidInfo(e.body))this.latestDiscoveryInfo=e.body,this.reflectDiscoveredServices(),this.log.trace("\u2198\uFE0F Discovered services",e.body);else throw new c.BadResponse("Invalid discovery response",e);e.id!==M.broadcastMessageId&&this.onResponse(e)});n(this,"broadcastDiscoveryInfo",e=>{let t={};for(let[s,i]of Object.entries(this.implementedServices)){let a=i.service;t[s]={fingerprint:a.fingerprint}}let r={services:t};try{this.channel.postMessage({type:m.MessageType.Response,id:e||M.broadcastMessageId,serviceId:M.serviceId,method:M.method,body:r})}catch{}});n(this,"onewayPromise",Promise.resolve(void 0));n(this,"expectWithoutDiscovery",e=>(this.log.trace("\u260E\uFE0F expectWithoutDiscovery",e.id),e.newOutgoingWrapper(async(t,r)=>t.oneway?(this.postOnewayRequest(e.id,t),this.onewayPromise):(await this.waitForDiscoveryInfo(1e3),this.throwErrorIfBadService(e),this.postRequest(e.id,t,void 0,r)))));n(this,"discover",async(e,{timeout:t=3e4}={})=>{this.log.trace("\u260E\uFE0F discover",e.id);let r=[this.waitForDiscoveredService(e,t)];return t!==1/0&&r.push(H(t).then(()=>{throw this.latestDiscoveryInfo?new c.ServiceNotFound(e.id):new c.TimedOut(e.id)})),await Promise.race(r),this.throwErrorIfBadService(e),this.expectWithoutDiscovery(e)});n(this,"throwErrorIfBadService",e=>{let t=this.latestDiscoveryInfo,r=t&&t?t.services[e.id]:void 0;if(!r)throw this.log.warn("\u260E\uFE0F Couldn't find service",e.id,t),new c.ServiceNotFound(e.id);if(r.fingerprint!==e.fingerprint)throw this.log.warn("\u260E\uFE0F Couldn't find service with required version fingerprint. Make sure both endpoints are using the same version of the Services package.",t),new c.ServiceNotCompatible(e.id)});n(this,"postOnewayRequest",(e,t)=>{this.channel.postMessage({type:m.MessageType.Request,id:m.onewayRequestId,serviceId:e,method:t.method,body:t.argument})});n(this,"postRequest",(e,t,r,s)=>{if(this.log.trace("\u2197\uFE0F",e,t),!!(this.channel.disabled??!1))return Promise.reject(new c.ServiceNotFound(e));let a={type:m.MessageType.Request,id:w.generateUniqueId(),serviceId:e,method:t.method,stream:D.toMessage(t.stream),body:t.argument},v=w.newResolvablePromise();this.waitingRequestsMap[a.id]={result:v,onStreamValue:s},this.channel.postMessage(a);let l=[v];return typeof r=="number"&&l.push(H(r).then(()=>{throw new c.TimedOut})),Promise.race(l).then(h=>h?.body).catch(h=>{throw delete this.waitingRequestsMap[a.id],h})});n(this,"waitingRequestsMap",{});n(this,"onResponse",e=>{let t=e.id,r=t.startsWith(m.onewayStreamResponseIdPrefix);r&&(t=t.substr(m.onewayStreamResponseIdPrefix.length));let s=this.waitingRequestsMap[t];if(r)s&&e.body&&s.onStreamValue?.(e.body);else{if(!s)return this.log.warn("\u260E\uFE0F onResponse: couldn't find request",e);delete this.waitingRequestsMap[t],s.result.resolve(e)}});n(this,"onErrorResponse",(e,t)=>{let r=this.waitingRequestsMap[e.id];if(!r)return this.log.warn("\u260E\uFE0F onErrorResponse: couldn't find request",e);delete this.waitingRequestsMap[e.id];let s=t||c.reconstructErrorResponse(e.body);r.result.reject(s)});n(this,"implementedServices",{});n(this,"unregisteredServices",new Set);n(this,"registerImplementation",(e,t)=>{this.log.trace("\u260E\uFE0F registerImplementation",t.id,e);let r={};for(let s in t.methods){let i=s,a=e[i];if(typeof a!="function")throw new c.Implementation(`Implementation for ${t.id} doesn't correctly implement ${i}()`);r[i]=a.bind(e)}this.unregisteredServices.delete(t.id),this.implementedServices[t.id]={service:t,rawImplementation:e,implementation:Object.freeze(r)},this.broadcastDiscoveryInfo()});n(this,"unregisterImplementation",async e=>{let t=e===this.unregisterAllToken;t||this.log.trace("\u260E\uFE0F unregisterImplementation",e);let r=!1,s=[];for(let[i,a]of Object.entries(this.implementedServices))if(!(!t&&a.rawImplementation!==e)){this.unregisteredServices.add(i),delete this.implementedServices[i],r=!0;for(let[v,l]of Object.entries(this.requestedStreamsMap))l?.serviceId===i&&s.push({id:v,error:new c.ServiceGone(i)})}await this.cancelStreams(s),r&&this.broadcastDiscoveryInfo()});n(this,"unregisterAllToken",{});n(this,"unregisterAllImplementations",async()=>{this.log.debug("\u260E\uFE0F unregisterAllImplementations"),await this.unregisterImplementation(this.unregisterAllToken)});n(this,"requestedStreamsMap",{});n(this,"cancelStreams",async e=>{let t=[];for(let{id:r,error:s}of e){let i=this.requestedStreamsMap[r];delete this.requestedStreamsMap[r],i?.iterator.throw&&t.push(i.iterator.throw(s))}await Promise.all(t)});n(this,"onRequest",async e=>{if(e.method===M.method){this.broadcastDiscoveryInfo(e.id);return}let t=m.MessageType.Response,r,s=!1;try{let i=this.implementedServices[e.serviceId],a=i?.implementation;if(!a)throw this.unregisteredServices.has(e.serviceId)?new c.ServiceGone(e.serviceId):new c.BadRequest;this.log.trace("\u2198\uFE0F",e.serviceId,e);let v=a[e.method];if(!e.stream)r=await v(e.body);else{let{id:l,method:h}=D.fromMessage(e.stream),b=this.requestedStreamsMap[l];if(h==="next"){if(!b){let p=T.isServiceStreamOptions(e.body)?e.body:void 0;b={iterator:(await v(p))[Symbol.asyncIterator](p?.oneway?y=>(this.channel.postMessage({type:m.MessageType.Response,id:m.onewayStreamResponseIdPrefix+e.id,serviceId:e.serviceId,method:e.method,body:{done:!1,value:y}}),{ignore:!0}):void 0),serviceId:i.service.id},this.requestedStreamsMap[l]=b}try{let p=await b.iterator.next();r={done:p.done,value:p.value}}catch(p){throw s=p instanceof c.ServiceGone,p}}else if(h==="return"){delete this.requestedStreamsMap[l];let p=b?.iterator.return;p&&await p(),r={done:!0,value:void 0}}else throw new c.BadRequest("Stream operations other than next() and return() are not yet supported")}}catch(i){t=m.MessageType.Error,r=c.toMessageBody(i),s||this.log.warn("\u260E\uFE0F onRequest: error",e,i)}finally{this.channel.postMessage({type:t,id:e.id,serviceId:e.serviceId,method:e.method,body:r})}});n(this,"onOnewayRequest",e=>{try{let r=this.implementedServices[e.serviceId]?.implementation;if(!r)throw this.unregisteredServices.has(e.serviceId)?new c.ServiceGone(e.serviceId):new c.BadRequest;this.log.trace("\u2198\uFE0F",e.serviceId,e);let s=r[e.method];s(e.body)}catch(t){this.log.warn("\u260E\uFE0F onOnewayRequest: error",e,t)}});n(this,"testable",{waitingRequestsMap:()=>this.waitingRequestsMap});e.addMessageListener(this.onMessage)}get log(){return this.customLogger??f.log}destroy(){this.channel.removeMessageListener(this.onMessage)}async waitForDiscoveryInfo(e,t=0){if(this.latestDiscoveryInfo)return this.latestDiscoveryInfo;let r=e/(t+1),s=0;for(;s<=t;)try{await this.postRequest(M.serviceId,{method:M.method},r);break}catch(i){if(!(i instanceof c.TimedOut))throw i;if(!this.isWaitingForDiscovery())break;s++}if(!this.latestDiscoveryInfo)throw new c.ServiceNotFound;return this.latestDiscoveryInfo}isWaitingForDiscovery(){return Object.values(this.waitingDiscoveryMap).some(e=>e&&e.length>0)}async waitForDiscoveredService(e,t){let r=w.newResolvablePromise(),s=this.waitingDiscoveryMap[e.id]||[],i=this.isWaitingForDiscovery();return this.waitingDiscoveryMap[e.id]=s,s.push(r),i||this.waitForDiscoveryInfo(t,2).catch(()=>{}),this.reflectDiscoveredServices(),r}},M;(s=>{s.serviceId="",s.method="#discover",s.broadcastMessageId="";function r(i){return!!(i&&typeof i=="object"&&"services"in i&&typeof i.services=="object")}s.isValidInfo=r})(M||={});var D;(s=>{let o="#return:",e="#throw:";function t(i){return i.startsWith(o)?{id:i.substr(o.length),method:"return"}:i.startsWith(e)?{id:i.substr(e.length),method:"throw"}:{id:i,method:"next"}}s.fromMessage=t;function r(i){if(i)switch(i.method){case"next":return i.id;case"return":return o+i.id;case"throw":return e+i.id;default:return}}s.toMessage=r})(D||={});function H(o){return new Promise(e=>{setTimeout(e,o)})}var F=class{constructor(){n(this,"listeners",new Set)}get log(){return f.log.extend("LocalChannel")}postMessage(e){this.log.trace("\u2197\uFE0E",e),this.listeners.forEach(t=>t(e))}addMessageListener(e){this.listeners.add(e)}removeMessageListener(e){this.listeners.delete(e)}},we=new F;var $=class{constructor(e){this.port=e;n(this,"listeners",new Set);n(this,"onMessageEvent",e=>{this.log.trace(e);let t=e.data;if(m.isMessage(t))for(let r of this.listeners)r(t)})}get log(){return f.log.extend("MessagePortChannel")}postMessage(e){this.log.trace("\u2197\uFE0E",e),this.port.postMessage(e)}addMessageListener(e){this.listeners.size===0&&(this.port.start(),this.port.addEventListener("message",this.onMessageEvent,!1)),this.listeners.add(e)}removeMessageListener(e){this.listeners.delete(e),this.listeners.size===0&&this.port.removeEventListener("message",this.onMessageEvent,!1)}};var g=typeof window>"u"?void 0:window,x="data:origin-not-initialized",R=class R{constructor(e,t){this.target=e;n(this,"trustedOrigin",x);n(this,"disabled");n(this,"listeners",new Set);n(this,"onMessageEvent",e=>{this.log.trace(e.data,e.origin);let t=!1;if(e.source!==this.target)if(this===I&&e.source===g&&e.data?.__sourceRepresentsParentFrame)t=!0;else return;if(!t&&e.origin!==this.trustedOrigin&&this.trustedOrigin!=="*")throw this.trustedOrigin?new Error(`PostMessageChannel received a message with origin ${e.origin}, expected ${this.trustedOrigin}`):new Error(`PostMessageChannel received a message with origin ${e.origin}, but has not been configured with initializeTrustedOrigin`);if(this.interceptor?.handleRawEvent(e))return;let r=e.data;if(m.isMessage(r))for(let s of this.listeners)s(r)});n(this,"interceptor");let r=R.targetRepresentingParentFrame;if(e===(g?g.parent:void 0)||e===r){if(!B||I!==void 0)throw new Error("PostMessageChannel.toParentFrame must be used instead of initializing with window.parent.");if(g)g.parent!==g?this.target=g.parent:(this.target=r,this.disabled=r.disabled);else{this.target={postMessage:(...s)=>{this.log.debug("postMessage to parent channel not running in a DOM environment: ",s)}};return}}t!==x&&this.initializeTrustedOrigin(t)}get log(){return f.log.extend("PostMessageChannel")}static get toParentFrame(){return B=!0,I=I??new R(R.targetRepresentingParentFrame,x),B=!1,I}initializeTrustedOrigin(e){if(this.trustedOrigin!==x&&!(this===I&&e===this.trustedOrigin))throw new Error("PostMessageChannel can only be initialized with a trusted origin once");if(e!=="*"){if(!e.includes("://"))throw new Error(`PostMessageChannel can only be initialized with a concrete origin (https://...); received ${e}`)}this.trustedOrigin=e}postMessage(e){this.log.trace("\u2197\uFE0E",e),this.target.postMessage(e,this.trustedOrigin)}postMessageRaw(e){this.target.postMessage(e,this.trustedOrigin)}addMessageListener(e){this.listeners.size===0&&g?.addEventListener("message",this.onMessageEvent,!1),this.listeners.add(e)}removeMessageListener(e){this.listeners.delete(e),this.listeners.size===0&&g?.removeEventListener("message",this.onMessageEvent,!1)}static interceptMessageEventsFromOpenerFrame(e){Q.setInterceptor(e)}setInterceptor(e){this.interceptor&&this.removeMessageListener(this.interceptor.unusedMessageListenerOnlyForCounting),this.interceptor=e?{handleRawEvent:e,unusedMessageListenerOnlyForCounting:()=>{}}:void 0,this.interceptor&&this.addMessageListener(this.interceptor.unusedMessageListenerOnlyForCounting)}};n(R,"targetRepresentingParentFrame",(()=>{let e="__targetRepresentingParentFrame",t=g?.[e]??g?.webkit?.messageHandlers?.[e];return{disabled:!t,postMessage:(...r)=>{if(g){if(!t)throw new Error(`Can't find window.parent or ${e} message handler`)}else throw new Error("PostMessageChannel requires a DOM environment");t.postMessage(...r)}}})());var k=R,B=!1,I,K=k.toParentFrame,Q=g&&g.opener&&g!==g.opener&&g.parent===g?new k(g.opener,x):K;var G=class{constructor(){n(this,"hook");n(this,"onNewStream");n(this,"newStream",e=>{let t=w.generateUniqueId();return new q((r,s)=>{this.iterators.push({id:t,update:r,done:s});let i=this.onNewStream?.(e);if(e?.replay==="latest"){let a=i?.latest??this.latestValue;if(a)r(a);else throw new c.Implementation('ServiceEventEmitter needs a "latest" value, but nothing has been emitted or returned by the onNewStream callback')}else if(i)throw new c.Implementation(`ServiceEventEmitter received a "latest" value from the onNewStream callback for a stream that didn't need it`)},()=>{let r=this.iterators.findIndex(s=>s.id===t);if(r>=0)this.iterators.splice(r,1);else throw new c.BadRequest(`ServiceEventEmitter couldn't find cancelled iterator with id: ${t}`)})});n(this,"iterators",[]);n(this,"latestValue");n(this,"emit",e=>{this.hook?.(e),this.latestValue=e;for(let t of this.iterators)t.update(e)});n(this,"latest",()=>this.latestValue);n(this,"hasStreams",()=>this.iterators.length>0)}setHook(e){this.hook=e}},q=class{constructor(e,t){this.onIteratorEnd=t;n(this,"log",f.log.extend("ServiceStreamIterator"));n(this,"hasAsyncIterator",!1);n(this,"updatesBeforeAsyncIterator",[]);n(this,"onUpdate");n(this,"doneResult",{done:!0,value:void 0});n(this,"promises",[]);n(this,"returnedNextPromise");n(this,"update",e=>{let{hasAsyncIterator:t,updatesBeforeAsyncIterator:r,promises:s,returnedNextPromise:i}=this;if(!t){if(!e||e instanceof c)throw new c.BadRequest("ServiceStream received return or throw before being read");r.push(e);return}let a=s[this.promises.length-1];if(e&&a===void 0){if(!i){this.log.warn("lastPromise and returnedNextPromise should never both be undefined");return}a=i}if(e===void 0)a?.resolve(this.doneResult),i?.resolve(this.doneResult);else if(e instanceof c)i?.reject(e);else{if(this.onUpdate?.(e).ignore)return;s.push(w.newResolvablePromise()),a?.resolve({done:!1,value:e})}});n(this,"next",async()=>{let e=this.promises.shift();return this.returnedNextPromise=e,e||this.doneResult});n(this,"return",async()=>(this.update(void 0),this.onIteratorEnd?.(),this.doneResult));n(this,"throw",async e=>(this.update(e),this.onIteratorEnd?.(),this.doneResult));n(this,"read",async e=>{let t=this[Symbol.asyncIterator](),r=await t.next();for(;!r.done;)e(r.value),r=await t.next()});n(this,"cancel",async()=>{await this.return()});this.promises=[w.newResolvablePromise()],e(this.update,this.update)}[Symbol.asyncIterator](e){if(this.hasAsyncIterator)throw new Error("ServiceStreamIterator.asyncIterator() may only be called once");return this.onUpdate=e,this.hasAsyncIterator=!0,this.updatesBeforeAsyncIterator.forEach(this.update),this.updatesBeforeAsyncIterator=[],this}};var J;(s=>{function o(i,a,v,l){v({method:i,argument:a?l:void 0,oneway:!0})}s.onewayMethodTemplate=o;async function e(i,a,v,l){await v({method:i,argument:a?l:void 0})}s.voidMethodTemplate=e;async function t(i,a,v,l){return await v({method:i,argument:a?l:void 0})}s.valueMethodTemplate=t;function r(i,a,v){return new T.StreamReader(i,v,a)}s.streamMethodTemplate=r})(J||={});export{f as a,P as b,c,ne as d,E as e,we as f,$ as g,k as h,K as i,Q as j,J as k,G as l};
//# sourceMappingURL=https://app.framerstatic.com/chunk-53WSEHWE.mjs.map
