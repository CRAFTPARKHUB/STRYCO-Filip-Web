import{p as b}from"https://app.framerstatic.com/chunk-ZQUNXESX.mjs";import{v as c}from"https://app.framerstatic.com/chunk-CQ6F5PRQ.mjs";import{a as d,b as T}from"https://app.framerstatic.com/chunk-WNSBRACC.mjs";import{j as r}from"https://app.framerstatic.com/chunk-AHQIRSXG.mjs";function p({source:a,target:e,origin:n,url:t}){return e?a===e:n===t}function w(a,e){if(a.length!==e.length)return!1;for(let n of a){let t=e.find(s=>s.id===n.id);if(!t||t.state===n.state)return!1}return!0}var u=c("message-channel-connection");var f=class{constructor(e){this.options=e;r(this,"cleanup");r(this,"_isConnected",!1);r(this,"connectionPromise");r(this,"connectionResolve");r(this,"localWeight");r(this,"cleanupFn")}debugConnect(){this._isConnected=!0;let e=this.waitUntilConnected();return this.connectionResolve?.(),e}isConnected(){return this._isConnected}setConnected(){this._isConnected=!0}onRendezvousMessage(e,n){if(!this.shouldHandleRendezvous(e,n))return;let t=new MessageChannel;if(d(e.ports[0],"Missing port"),this.setup(t.port2,e.ports[0]),n.allowDynamicTarget&&!n.target){let s=e.source;this.options.setPostMessageTarget(s)}e.ports[0].postMessage({type:"reply"},[t.port1])}shouldHandleRendezvous(e,n){if(e.data.type!=="rendezvous"||e.data.controller===this.options.id||e.data.namespace!==n.namespace||this.isConnected()||this.localWeight!==void 0&&this.localWeight>e.data.weight)return!1;let t=this.options.getChannelConfig();return w(t,e.data.channelConfig)||d(!1,"Channel configuration mismatch"),!0}setupMessageChannel(){let e=new MessageChannel;return e.port1.onmessage=n=>{n.data.type==="reply"&&(this.isConnected()||(d(n.ports[0],"Missing port"),this.setup(e.port1,n.ports[0])))},e}sendConnectionMessage(e,n,t,s){let o={type:"rendezvous",port:t.port2,namespace:n.namespace,weight:s,controller:this.options.id,channelConfig:this.options.getChannelConfig()};e.postMessage(o,n.url,[t.port2])}trySendMessage(e,n,t,s){try{this.sendConnectionMessage(e,n,this.setupMessageChannel(),t)}catch(o){o instanceof DOMException&&o.name==="DataCloneError"&&(s?u.errorOncePerMinute("MessagePort was neutered on retry attempt. Check your browser extensions. Error:",o):(u.debug("MessagePort was neutered, creating new channel and retrying:",o),this.trySendMessage(e,n,t,!0))),u.error("Failed to send connection message:",o)}}setupActiveConnection(e){u.debug("setupActiveConnection",{options:e}),d(e.target,"Target window is required for active connection");let n=e.target,t=()=>{if(this.isConnected())return;let o=Math.floor(Math.random()*Number.MAX_SAFE_INTEGER);this.localWeight=o,this.trySendMessage(n,e,o,!1)},s=setInterval(t,500);return t(),{cleanup:()=>clearInterval(s)}}setupPassiveConnection(e){let n=t=>{p({source:t.source,target:e.target,origin:t.origin,url:e.url})&&this.onRendezvousMessage(t,e)};return window.addEventListener("message",n),{cleanup:()=>window.removeEventListener("message",n)}}connect(e){this.cleanup?.();let n=this.setupPassiveConnection(e),t;return e.target&&(t=this.setupActiveConnection(e),this.options.setPostMessageTarget(e.target)),this.options.setPostMessageUrl(e.url),this.cleanup=()=>{t?.cleanup(),n.cleanup()},this.waitUntilConnected()}async waitUntilConnected(){return this.connectionPromise||(this.connectionPromise=new Promise(e=>{this.connectionResolve=e})),this.connectionPromise}setup(e,n){u.debug("setup",{sendingPort:e,receiverPort:n}),this.cleanupFn?.(),this.options.setPorts(e,n),this.setConnected(),this.connectionResolve?.(),this.connectionResolve=void 0}};var m=class{constructor(e){this.handleAllMessages=e;r(this,"sendingPort");r(this,"receivingPort")}setPorts(e,n){this.sendingPort=e,this.receivingPort=n,this.receivingPort.onmessage=this.handleAllMessages}send(e){if(!this.sendingPort)throw new Error("Cannot send message - channel not connected");this.sendingPort.postMessage(e)}handleMessageEvent(e){this.handleAllMessages(e)}};var I=c("post-message-transport"),C=class{constructor(e,n){this.controllerId=e;this.handleAllMessages=n;r(this,"target");r(this,"origin");r(this,"messageHandler");this.messageHandler=t=>{if(!this.origin)throw new Error("PostMessageTransport: origin (url) must be set before handling messages.");p({source:t.source,target:this.target,origin:t.origin,url:this.origin})&&t.data.type!=="rendezvous"&&this.handleAllMessages(t)}}setUrl(e){this.origin=e}setTarget(e){I.info("setTarget",e),this.target&&window.removeEventListener("message",this.messageHandler),this.target=e,window.addEventListener("message",this.messageHandler)}send(e){if(!this.target)throw new Error("PostMessageTransport: target must be set before sending messages.");if(!this.origin)throw new Error("PostMessageTransport: origin (url) must be set before sending messages.");this.target.postMessage(e,this.origin)}};function P(a,e){let n=new Map;return new Proxy({},{get:(t,s)=>{let o=n.get(s);if(o)return o;if(typeof s!="string"||s==="then")return;if(s==="oneway"){let l=E(a,e);return n.set(s,l),l}if(s==="toJSON"||s==="toString"){let l=`[Proxy: ${e}]`,h=()=>l;return n.set(s,h),h}let i=(...l)=>a.sendMessage(e,s,l);return n.set(s,i),i}})}function E(a,e){let n=new Map;return new Proxy({},{get:(t,s)=>{let o=n.get(s);if(o)return o;if(typeof s!="string"||s==="then")return;if(s==="toJSON"||s==="toString"){let l=`[OneWayProxy: ${e}]`,h=()=>l;return n.set(s,h),h}let i=(...l)=>a.sendOnewayMessage(e,s,l);return n.set(s,i),i}})}var M=(s=>(s.Invoke="invoke",s.InvokeOneWay="invokeOneWay",s.Result="result",s.Error="error",s))(M||{}),k=Object.values(M);function x(a){return k.includes(a)}var g=c("message-channel-controller");var y=class{constructor(e,n){this.channel=e;this.object=n}},v=class{constructor(e,n){this.channel=e;this.proxy=n}},R=class{constructor(e){this.channelInterface=e;r(this,"id");r(this,"messageCounter",0);r(this,"localChannels",new Map);r(this,"remoteChannels",new Map);r(this,"connectionManager");r(this,"pendingCalls",new Map);r(this,"messagePortTransport");r(this,"postMessageTransport");r(this,"handleAllMessages",e=>{if(!x(e.data.type))return;let n=e.data;switch(n.type){case"result":{let t=this.pendingCalls.get(n.seq);if(!t){g.warn("No pending call found for seq:",n.seq,n);return}this.pendingCalls.delete(n.seq),t.resolve(n.result);return}case"error":{let t=this.pendingCalls.get(n.seq);if(!t){g.warn("No pending call found for seq:",n.seq,n);return}this.pendingCalls.delete(n.seq),t.reject(n.error);return}case"invoke":case"invokeOneWay":this.handleInvokeMessage(n);return;default:T(n)}});r(this,"debugSendMessage");this.id=Math.floor(Math.random()*Number.MAX_SAFE_INTEGER),this.messagePortTransport=new m(this.handleAllMessages),this.postMessageTransport=new C(this.id,this.handleAllMessages),this.connectionManager=new f(this)}debugConnect(e){return this.debugSendMessage=e,this.connectionManager.debugConnect()}setPorts(e,n){this.messagePortTransport.setPorts(e,n)}setPostMessageTarget(e){this.postMessageTransport.setTarget(e)}setPostMessageUrl(e){this.postMessageTransport.setUrl(e)}get isConnected(){return this.connectionManager.isConnected()}getChannelConfig(){let e=[];for(let n of this.localChannels.keys())e.push({id:n,state:"local"});for(let n of this.remoteChannels.keys())e.push({id:n,state:"remote"});return e}async connect(e={}){if(!this.areAllChannelsSetup())throw new Error("All channels must be setup as local or remote before connecting");if(Object.values(this.channelInterface.channels).some(t=>t.communicationMethod==="post-message")&&!e.allowDynamicTarget&&!e.target)throw new Error("When not allowing a dynamic target, specifying a target window is required when using PostMessage communication.");return this.connectionManager.connect({url:e.url??"*",target:e.target,allowDynamicTarget:e.allowDynamicTarget??!1,namespace:this.channelInterface.name})}waitUntilConnected(){return this.connectionManager.waitUntilConnected()}getTransport(e){return e==="post-message"?this.postMessageTransport:this.messagePortTransport}handleInvokeMessage(e){g.trace("handleChannelMessage",e);let n=this.postMessageTransport;try{let t=this.localChannels.get(e.channel);if(!t)throw Error(`TypeError: endpoint '${e.channel}' not found`);n=this.getTransport(t.channel.communicationMethod);let s=t.object[e.method];if(!s)throw Error(`TypeError: method '${e.method}' on endpoint '${e.channel}' is not found`);let o=s.apply(t.object,e.args);if(e.type==="invokeOneWay")return;if(b(o)){o.then(i=>{n.send({type:"result",seq:e.seq,result:i})}).catch(i=>{g.error("method",e.method,"promise threw an error:",i),n.send({type:"error",seq:e.seq,error:i})});return}n.send({type:"result",seq:e.seq,result:o})}catch(t){if(g.error("Method",e.method,"threw an error:",t),e.type==="invokeOneWay")return;n.send({type:"error",seq:e.seq,error:t})}}sendOnewayMessage(e,n,t){g.trace("oneway message:",e,n,t),this.messageCounter++;let s={type:"invokeOneWay",channel:e,method:n,args:t,seq:this.messageCounter};this.sendMessageCommon(e,s),this.debugSendMessage&&this.debugSendMessage(s)}async sendMessage(e,n,t){g.trace("message:",e,n,t),this.messageCounter++;let s={type:"invoke",channel:e,method:n,args:t,seq:this.messageCounter};return this.sendMessageCommon(e,s),this.debugSendMessage?this.debugSendMessage(s):new Promise((o,i)=>{this.pendingCalls.set(this.messageCounter,{resolve:o,reject:i})})}sendMessageCommon(e,n){let t=e?this.remoteChannels.get(e):void 0;if(!t)throw Error(`TypeError: endpoint '${e}' not found`);let s=this.getTransport(t.channel.communicationMethod);this.debugSendMessage||s.send(n)}areAllChannelsSetup(){return this.remoteChannels.size+this.localChannels.size===this.channelInterface.size}assertOurChannel(e){if(this.channelInterface.channels[e.id]!==e)throw this.channelInterface.channels[e.id]?Error("Channel found but from different interface: "+e.id):Error("Channel not found in interface: "+e.id)}setupChannelAsLocal(e,n){if(this.assertOurChannel(e),this.remoteChannels.has(e.id))throw new Error(`Channel ${e.id} has already been setup as remote`);if(this.localChannels.has(e.id))throw new Error(`Channel ${e.id} has already been setup as local before`);this.localChannels.set(e.id,new y(e,n))}setupChannelAsRemote(e){if(this.assertOurChannel(e),this.localChannels.has(e.id))throw new Error(`Channel ${e.id} has already been setup as local`);let n=this.remoteChannels.get(e.id);return n||(n=new v(e,P(this,e.id)),this.remoteChannels.set(e.id,n)),n.proxy}setLocal(e,n){this.setupChannelAsLocal(e,n)}getRemote(e){return this.setupChannelAsRemote(e)}async getConnectedRemote(e){return await this.waitUntilConnected(),this.getRemote(e)}};var S=class{constructor(e="message-channel"){this.communicationMethod=e;r(this,"_id")}get id(){return d(this._id,"Channel defined outside of ChannelInterface"),this._id}setId(e){d(!this._id,"Cannot set id twice."),this._id=e}};var z=class{constructor(e,n){this.name=e;this.channels=n;r(this,"size");let t=0;for(let s in n)n[s]?.setId(s),t++;this.size=t}};export{R as a,S as b,z as c};
//# sourceMappingURL=https://app.framerstatic.com/chunk-AG7S5MTU.mjs.map
