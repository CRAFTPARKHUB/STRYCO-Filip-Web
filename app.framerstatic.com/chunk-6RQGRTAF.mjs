import{Cc as un,Dc as _s,Ec as fn,Fa as Rs,Gc as $s,Hb as Es,Hc as js,Ic as qs,Nc as Ws,Qc as Js,Rc as ut,_c as Hs,_e as yn,ac as Ms,bb as xs,bc as Vs,cd as Gs,ce as Zs,dc as Fs,dd as Ks,ef as ya,fd as pn,ff as Sa,gc as Us,hc as ln,he as ie,ie as gn,if as Sn,je as la,jf as Nt,ke as ua,le as fa,lf as va,me as pa,mf as bn,ne as ma,oc as ho,pe as ha,sb as Ds,sc as go,tc as As,wc as zs,xb as ks}from"https://app.framerstatic.com/chunk-Z52HPYUI.mjs";import{b as da,g as Ia}from"https://app.framerstatic.com/chunk-CKN4QK3D.mjs";import{a as ta,b as mn,c as ra,d as hn,e as na,f as oa}from"https://app.framerstatic.com/chunk-HKTXCOMI.mjs";import{b as ea,e as fe}from"https://app.framerstatic.com/chunk-SZHO3GJC.mjs";import{a as ia,b as sa,c as aa,d as ca}from"https://app.framerstatic.com/chunk-SE354WOV.mjs";import{a as hr}from"https://app.framerstatic.com/chunk-IRUXHEMQ.mjs";import{b as mr}from"https://app.framerstatic.com/chunk-J5GSEMYU.mjs";import{a as Ps,g as jt,j as Ls}from"https://app.framerstatic.com/chunk-6223XENM.mjs";import{M as Ns}from"https://app.framerstatic.com/chunk-S254BFAJ.mjs";import{e as ga}from"https://app.framerstatic.com/chunk-ZCJRITYT.mjs";import{b as ba,c as Ca,d as Ta,e as wa}from"https://app.framerstatic.com/chunk-E5YBF7LR.mjs";import{o as Qs,p as Xs,q as Ys,x as vn}from"https://app.framerstatic.com/chunk-XRODVMEA.mjs";import{$f as pr,Hg as sn,Ka as Qe,Lg as Is,Ob as co,Pg as an,Q as Ot,Tc as ps,U as ve,V as ji,X as qi,Xa as ss,Za as as,ag as ys,bc as ls,bg as lt,cc as us,dg as Ss,ie as hs,ig as vs,jg as bs,ke as gs,kg as Cs,lg as Ts,mg as lo,ng as uo,od as ms,og as fo,pb as cs,pg as po,qg as Ne,ra as Hi,rc as fs,rg as mo,sg as ws,tg as on,xb as ao}from"https://app.framerstatic.com/chunk-FPS4GZUH.mjs";import{e as Pe,k as It,m as is,v as ds}from"https://app.framerstatic.com/chunk-5VCCZK32.mjs";import{f as Xe}from"https://app.framerstatic.com/chunk-IHU2PUEH.mjs";import{Je as cn}from"https://app.framerstatic.com/chunk-Q54L4BMQ.mjs";import{e as Bs,i as Os}from"https://app.framerstatic.com/chunk-VCLUQ2DP.mjs";import{Ag as v,Bg as ts,Cg as rs,Fg as Zr,Hd as Yi,Ig as en,Jb as Gi,Jg as tn,Li as os,Qc as Ki,Sg as ns,Vc as wt,Vg as dt,Wg as rn,Xc as zt,Xg as _t,Yc as Qi,Yg as $t,Zg as nn,bb as Wi,gd as Xi,kb as so,ld as Yr,mc as Xr,se as Zi,ub as Ji,ve as es}from"https://app.framerstatic.com/chunk-4BR6WBUV.mjs";import{$e as fi,$k as oo,$q as Fi,$u as $i,Ee as Ie,Fe as Bt,Gg as mi,Hg as hi,I as Jr,Ib as ii,Ip as Vi,Kt as Ai,Le as li,Me as Se,Ne as oe,Oe as Q,Pe as L,Qt as Bi,Re as X,Se as H,Td as At,Te as ui,Ui as yi,Uk as ur,Un as ki,We as at,Wk as fr,Wt as Oi,Xd as st,Xn as Ei,Xt as io,Yt as zi,Zd as Kr,Ze as G,Zk as no,Zt as Qr,_d as ci,_e as ro,_o as Li,_u as _i,ap as Mi,bl as F,cl as w,cw as ue,dl as Ci,do as Pi,el as le,fe as di,ga as it,gj as Si,gl as M,hl as f,hm as Ii,il as Ue,kh as gi,kl as Ae,l as de,mn as Di,nl as Ti,ok as vi,ol as wi,ot as Be,pb as Gr,pm as Ni,sm as Ri,sr as Ui,tc as si,uf as Fe,vf as pi,vk as bi,vm as xi,yc as ai,yq as ct,zd as to}from"https://app.framerstatic.com/chunk-JMNEQD26.mjs";import{K as ni,O as oi,m as ri}from"https://app.framerstatic.com/chunk-5GP6FPZ7.mjs";import{a as dn}from"https://app.framerstatic.com/chunk-ARMSKNUK.mjs";import{d as ti}from"https://app.framerstatic.com/chunk-PPOWLCIV.mjs";import{p as Ke}from"https://app.framerstatic.com/chunk-MKASFDMK.mjs";import{b as we,d as B,f as eo,i as O,l as lr}from"https://app.framerstatic.com/chunk-ZQUNXESX.mjs";import{a as Zn,b as Hr}from"https://app.framerstatic.com/chunk-NIDOI5EE.mjs";import{g as ot}from"https://app.framerstatic.com/chunk-BK4VWPYG.mjs";import{c as ei}from"https://app.framerstatic.com/chunk-53WSEHWE.mjs";import{D as $r,E as Yo,I as K,K as Ve,L as nt,Y as Ee,da as Zo,e as Qo,ea as jr,fa as qr,ha as ae,ja as Wr,l as Xo,m as _r,p as dr,v as D}from"https://app.framerstatic.com/chunk-CQ6F5PRQ.mjs";import{a as h,b as ye}from"https://app.framerstatic.com/chunk-WNSBRACC.mjs";import{e as Tt,j as u,k as b,l as ne,m as Ge,n as Ko}from"https://app.framerstatic.com/chunk-AHQIRSXG.mjs";var Oc=D("DocumentLoader"),yo=D("remote:verify"),Cn=class o{constructor(t,e){this.parser=t;this.settings=e;u(this,"canvasTreeVersion",0);u(this,"chunkingHints");this.canvasTreeVersion=this.parser.version,this.chunkingHints=this.parser.getChunkingHints()}static async createPartialParser(t,e){if(typeof t=="string"){let r=new aa(t);return new o(r,e)}else{let r=new ca(t);return new o(r,e)}}readFirstPage(){let t=!1,e=[];if(this.settings.activeNodeId&&(e.push(...this.parser.getPagesContainingId(this.settings.activeNodeId)),t=e.some(r=>ut(this.parser.getShallowPage(r)))),!t){let r=this.parser.getShallowPages(),n=Js(r,this.parser.getHomePageNodeID());e.push(n.id);let i=0,s;for(let a of r){if(L(a,!0)&&i++,i>1)break;X(a,!0)&&(s??=a.id)}i===1&&s&&s!==n.id&&e.push(s)}return Oc.debug("loadPartialDocument():",e),oa(this.parser,e,this.settings.treeServices)}getScopesToLoad(){return this.parser.getPagesToLoad()}getParsedPageById(t){return this.parser.getParsedPageById(t)}buildPage(t){if(!t)return;let e=[],r=yo.isLoggingTraceMessages()?[]:void 0,n=lt(t,this.parser.root.id,{extraChecksAndFixes:!0,errors:e,warnings:r});if(n&&hn(n,e),e.length>0&&yo.warn("errors loading server tree: "+e.join(`
`)),r&&r.length>0&&yo.trace("warnings loading server tree: "+r.join(`
`)),!!n)return n}};var So=D("app");function ku(o){return o.treeReflectsDocument?zc(o.tree):null}function zc(o){return o.toJS()}function Eu(o){function t(e){let{__class:r,width:n,height:i,top:s,bottom:a,left:c,right:d}=e,{children:p}=e;return p?(p=p.map(t),{__class:r,width:n,height:i,top:s,bottom:a,left:c,right:d,children:p}):e.styledText?{__class:r,width:n,height:i,top:s,bottom:a,left:c,right:d,text:e.styledText.blocks.map(l=>l.text)}:{__class:r,width:n,height:i,top:s,bottom:a,left:c,right:d}}return t(o.tree.toJS().root)}function Pu(o){let t,e=new XMLHttpRequest;e.open("GET",o.toString(),!1);try{e.send(),t=JSON.parse(e.responseText)}catch(r){So.error(`Retrieving document \u201C${o}\u201D failed. (${r})`)}return vo(t)}function Na(o){ot.isTest||o.forEach(t=>{So.warn("[repaired]",t)})}function vo(o){let t=[];try{let e=mn(o,t);return Na(t),e}catch(e){throw Na(t),So.warn("tree failed to verify:",e),e}}var gr=class extends Error{constructor(){super("cancelled"),this.name="CancelledError"}},Tn=class{constructor(t){this.requestIdleCallback=t;u(this,"resumePromiseResolve");u(this,"resumePromise");u(this,"backgroundMode",!1);u(this,"done",!1);u(this,"firstError");u(this,"debugStepListener")}debugResumeOneStep(){this.resume(),this.pause()}currentMode(){return this.backgroundMode?"slow":"fast"}isDone(){return!!this.firstError||this.done}isSuccess(){return!this.firstError&&this.done}isCancelled(){return!!this.firstError&&this.firstError instanceof gr}isError(){return!!this.firstError&&!(this.firstError instanceof gr)}getError(){return this.firstError}cancel(){this.isDone()||(this.firstError=new gr)}error(t){return this.isDone()||(this.firstError=t),t}pause(){this.firstError||this.resumePromise||(this.resumePromise=new Promise(t=>{this.resumePromiseResolve=t}))}resume(){let t=this.resumePromiseResolve;t&&(this.resumePromise=void 0,this.resumePromiseResolve=void 0,t())}isPaused(){return!!this.resumePromise}fast(){this.backgroundMode=!1}slow(){this.backgroundMode=!0}async run(t){h(!this.isDone(),"task is already done");try{await t()}catch(e){throw e instanceof Error?this.error(e):this.error(new Error(String(e??"Unknown Error")))}finally{this.done=!0}}async sleep(t){if(this.debugStepListener?.(),await Qo(t),this.resumePromise&&await this.resumePromise,this.debugStepListener?.(),this.resumePromise&&await this.resumePromise,this.firstError)throw this.firstError}async yield(){if(this.debugStepListener?.(),this.resumePromise?await this.resumePromise:this.backgroundMode?await new Promise(t=>{this.requestIdleCallback?this.requestIdleCallback(t):typeof requestIdleCallback=="function"?requestIdleCallback(t):setTimeout(t,0)}):await qr(),this.resumePromise&&await this.resumePromise,this.debugStepListener?.(),this.resumePromise&&await this.resumePromise,this.firstError)throw this.firstError}};var z=D("DocumentLoader"),wn=10,yr=1e3;function Rt(o){return o<1024*.75?`${Math.round(o)}b`:o<1024*1024*.75?`${(o/1024).toFixed(2)}kb`:`${(o/1024/1024).toFixed(2)}Mb`}function pe(o){return o<200?`${o.toFixed(1)}ms`:o<20*1e3?`${(o/1e3).toFixed(3)}s`:`${Math.round(o/1e3)}s`}var xt=class extends ea{constructor(e,r,n){super();this.treeVersion=e;this.documentURL=r;this.settings=n;u(this,"scheduler");u(this,"retryCount",0);u(this,"scopesToLoad",new Set);u(this,"prioritizedScopeIds",new Set);u(this,"currentLoadingScope");u(this,"partialParser");u(this,"canvasTreeVersion",0);u(this,"documentSize",0);u(this,"loadedFirstScope",!1);u(this,"loadingDuration",0);u(this,"parsingDuration",0);u(this,"debugPaused",!1);u(this,"loadingScopesPaused",!1);u(this,"loadAllDataPriority",0);u(this,"updatePauseResumeState",()=>{if(!this.loadedFirstScope){this.scheduler.fast(),this.scheduler.resume();return}let e=this.loadAllDataPriority>0||this.prioritizedScopeIds.size>0,r=this.loadingScopesPaused||this.debugPaused;e?this.scheduler.fast():this.scheduler.slow(),e||!r||this.scopesToLoad.size<=0?this.scheduler.resume():this.scheduler.pause()});u(this,"tree");u(this,"loadCallbacksPerScope",new Map);u(this,"addedByDiff",new Set);u(this,"removedByDiff",new Set);this.scheduler=new Tn(n.requestIdleCallback),z.debug("new:",this.treeVersion,this.documentURL)}pauseLoadingScopes(){this.loadingScopesPaused||(this.loadingScopesPaused=!0,z.debug("pauseLoadingScopes"),this.updatePauseResumeState())}resumeLoadingScopes(){this.loadingScopesPaused&&(this.loadingScopesPaused=!1,z.debug("resumeLoadingScopes"),this.updatePauseResumeState())}prioritizeLoadingAllData(e){let r="preload"in e&&e.preload;if(r&&Ke.isOn("debugEditWhileNeverLoadingRest"))return()=>{};let n=performance.now(),i=this.numberOfScopesToLoad();this.loadAllDataPriority=Math.max(1,this.loadAllDataPriority+1),z.debug("prioritizeLoadingScopes:",this.loadAllDataPriority),this.updatePauseResumeState();let s=r||"doNotTrack"in e&&e.doNotTrack,a=!1,c=s?void 0:this.afterAllDataLoaded(()=>{if(a)return;h("operationName"in e,"operationName is required");let p=performance.now()-n;Xe("fulltree_force_load",{operationName:e.operationName,durationMs:Math.round(p),background:e.operationInBackground,shallowScopesCount:i})});return()=>{a||(a=!0,c?.(),this.stopPrioritizingLoadingAllData())}}stopPrioritizingLoadingAllData(){this.loadAllDataPriority-=1,z.debug("stopPrioritizingLoadingScopes:",this.loadAllDataPriority),this.updatePauseResumeState()}debugPause(){this.debugPaused||(this.debugPaused=!0,z.debug("debugPause"),this.updatePauseResumeState())}debugResume(){this.debugPaused&&(this.debugPaused=!1,z.debug("debugResume"),this.updatePauseResumeState())}isDebugPaused(){return this.debugPaused}afterAllDataLoaded(e){let r=this.scopesToLoad.size===0;if(e){if(r){let n=!1;return queueMicrotask(()=>{n||e()}),()=>{n=!0}}return this.once("loadedAllData",e),()=>{this.off("loadedAllData",e)}}return r?Promise.resolve():new Promise(n=>{this.once("loadedAllData",n)})}async start(){await this.scheduler.run(async()=>{z.debug("start"),fe("parsingInit"),this.updatePauseResumeState();let e=performance.now(),r=await this.loadData();if(this.loadingDuration=performance.now()-e,await this.scheduler.yield(),!this.settings.partialParsing||typeof r=="string"&&!sa(r))return this.parseFullDocumentSync(r);let n=await this.loadDocumentVersion(r);for(await this.scheduler.yield(),this.tree=await this.loadFirstTree(n),this.loadedFirstScope=!0,this.updatePauseResumeState(),await this.scheduler.yield(),fe("parsingResume");this.hasNextScopeToLoad();)this.updatePauseResumeState(),await this.scheduler.yield(),await this.loadNextScopeAsync();await this.scheduler.yield(),await this.emitWrapped(()=>{h(this.tree,"tree must have been set"),this.tree.setService("loader",void 0),this.emit("loadedAllData")}),z.debug("done",Rt(this.documentSize),"loading:",pe(this.loadingDuration),"parsing:",pe(this.parsingDuration))})}async loadData(){if(this.settings.loadedData)return this.settings.loadedData;z.debug("Document in cache is not up to date. Tree version:",this.treeVersion);let e=this.settings.initData,r=e?.version===this.treeVersion,n=e?.prefetchPromise;if(e&&delete e.prefetchPromise,r&&n){z.debug("loadData: prefetch");let c=await n;if(n.then(d=>d.duration).then(d=>{fe("dataLoad",d)}),await this.scheduler.yield(),c.buffer){z.debug("loadData: prefetch bytes parser");let d=await c.buffer;return await this.scheduler.yield(),c.status<200||c.status>=300?this.handleErrorAndRetry(c.status,"Error loading project data"):new Uint8Array(d)}if(c.text){let d=await c.text;return await this.scheduler.yield(),c.status<200||c.status>=300?this.handleErrorAndRetry(c.status,d):d}}z.debug("loadData: fetch");let i;this.settings.refreshAccessToken&&(i=await this.settings.refreshAccessToken({}),await this.scheduler.yield());let s=await fetch(this.documentURL,i);await this.scheduler.yield();function a(c){if(!c.body)return!1;let d=new URLSearchParams(window.location.search).has("bytes"),p=document.cookie.includes("bytes-parser=true"),l=parseInt(c.headers.get("Uncompressed-Content-Length")??"0",10)>2e8;return d&&(document.cookie="bytes-parser=true; path=/;"),d||p||l}if(fe("dataLoad"),s.status<200||s.status>=300){let c=await s.text();return this.handleErrorAndRetry(s.status,c)}if(a(s)){z.debug("loadData: using streaming parser");let c=await s.arrayBuffer();return new Uint8Array(c)}else{z.debug("loadData: using text parser");let c=await s.text();return await this.scheduler.yield(),c}}async handleErrorAndRetry(e,r){let n=!1;try{n=JSON.parse(r).retry}catch{}if(n&&this.retryCount<wn)return z.debug("onErrorStatusLoaded, retry:",this.retryCount),await this.scheduler.sleep(this.retryCount*yr+Math.random()*yr),this.retryCount+=1,this.loadData();throw Error(n?"Too many retries":`Fetch Error: ${e} - ${r}`)}parseFullDocumentSync(e){if(typeof e!="string")throw new Error("Full document sync parsing requires string data, not ReadableStream");let r=performance.now();this.documentSize=e.length;let n=JSON.parse(e);if(!B(n.version))throw Error("cannot read document version");if(this.canvasTreeVersion=n.version,z.debug("parseFullDocumentSync",this.canvasTreeVersion,Rt(this.documentSize),pe(this.loadingDuration)),this.emit("loadedDocumentVersion",n.version),this.scheduler.isDone())return;let i=vo(n);this.emit("loadedFirstData",i),!this.scheduler.isDone()&&(this.emit("loadedAllData"),this.parsingDuration+=performance.now()-r,fe("parsingFirstPage"),z.debug("done",Rt(this.documentSize),"loading:",pe(this.loadingDuration),"parsing:",pe(this.parsingDuration)))}hasLoadedScope(e){let r=this.scopesToLoad.has(e),n=this.currentLoadingScope?.id===e;return!r&&!n}numberOfScopesToLoad(){return this.scopesToLoad.size}prioritizeLoadingScope(e,r){let n,i;if(typeof r=="function")this.addScopeLoadCallback(e,r);else if(r&&"onLoaded"in r)this.addScopeLoadCallback(e,r.onLoaded),i=r;else{let s=jr();n=s,this.addScopeLoadCallback(e,s.resolve),i=r}if(!(i?.preload&&Ke.isOn("debugEditWhileNeverLoadingRest")))return this.scopesToLoad.has(e)&&(this.prioritizedScopeIds.add(e),this.updatePauseResumeState(),this.addScopeLoadCallback(e,this.updatePauseResumeState)),n}nextScopeIdToLoad(){for(let r of this.prioritizedScopeIds)if(this.prioritizedScopeIds.delete(r),!!this.scopesToLoad.has(r))return this.scopesToLoad.delete(r),this.scheduler.fast(),r;let e=this.loadAllDataPriority>0;this.settings.loadInBackground&&!e?this.scheduler.slow():this.scheduler.fast();for(let r of this.scopesToLoad)return this.scopesToLoad.delete(r),r;throw Error("No next scope to load")}async loadDocumentVersion(e){let r=performance.now(),n=await Cn.createPartialParser(e,this.settings);return typeof e=="string"?this.documentSize=e.length:this.documentSize=0,this.canvasTreeVersion=n.canvasTreeVersion,this.parsingDuration+=performance.now()-r,z.debug("loadDocumentVersion",this.canvasTreeVersion,typeof e=="string"?Rt(this.documentSize):"stream",pe(this.loadingDuration)),await this.emitWrapped(()=>{if(this.scheduler.isDone())return;let i=performance.now();this.emit("loadedDocumentVersion",this.canvasTreeVersion),this.parsingDuration+=performance.now()-i}),this.partialParser=n,n}async loadFirstTree(e){let r=performance.now(),n=e.readFirstPage();this.scopesToLoad=e.getScopesToLoad();for(let i of this.scopesToLoad){let s=n.get(i);s&&(s.cache.isShallowLoad=!0)}return this.parsingDuration+=performance.now()-r,z.debug("loadFirstTree",pe(this.parsingDuration)),await this.emitWrapped(()=>{if(this.scheduler.isDone())return;let i=performance.now();n.setService("loader",this),n.chunkingHints=e.chunkingHints,this.emit("loadedFirstData",n),fe("parsingFirstPage"),this.parsingDuration+=performance.now()-i}),n}hasNextScopeToLoad(){return this.scopesToLoad.size>0}async loadNextScopeAsync(){h(!this.currentLoadingScope,"already have a currently loading scope");let e=this.nextScopeIdToLoad();this.currentLoadingScope=this.createLoadingScope(e);let r=await this.currentLoadingScope.run(this.scheduler);z.debug("loadScopeAsync:",e,pe(r.duration),"scheduler mode:",this.scheduler.currentMode()),r.hasNode()&&await this.emitWrapped(()=>{if(this.scheduler.isDone())return;let n=performance.now(),i=r.take();this.currentLoadingScope=void 0,i&&(this.emit("loadedScope",i),this.parsingDuration+=r.duration+performance.now()-n,this.signalScopeLoadCallbacks(i.id))})}createLoadingScope(e){return h(this.partialParser,"loadScope before the parser is available"),new bo(e,this.partialParser)}loadScope(e){if(this.currentLoadingScope?.id===e){let n=this.currentLoadingScope.force();return this.parsingDuration+=n.duration,this.currentLoadingScope=void 0,n.take()}if(this.prioritizedScopeIds.delete(e),!this.scopesToLoad.has(e))return;this.scopesToLoad.delete(e);let r=this.createLoadingScope(e).force();return this.parsingDuration+=r.duration,z.debug("loadScope:",e,pe(r.duration)),this.signalScopeLoadCallbacks(e),r.take()}addScopeLoadCallback(e,r){if(!r)return;if(this.hasLoadedScope(e)){setTimeout(r);return}let n=this.loadCallbacksPerScope.get(e)??[];n.push(r),this.loadCallbacksPerScope.set(e,n)}signalScopeLoadCallbacks(e){setTimeout(()=>{let r=this.loadCallbacksPerScope.get(e);if(r){for(let n of r)n();this.loadCallbacksPerScope.delete(e)}})}async emitWrapped(e){this.settings.asyncEventWrapper?(await this.scheduler.yield(),await this.settings.asyncEventWrapper(e)):(await this.scheduler.yield(),e())}resetTreeForRecovery(e){e.setService("loader",this);for(let r of this.scopesToLoad){let n=e.get(r);n&&(n.cache.isShallowLoad=!0)}this.tree=e}async nodeIdsToLoad(){let e=performance.now(),r=new Set;if(!this.partialParser)return r;let n=performance.now();for(let i of this.scopesToLoad){performance.now()-n>50&&(await qr(),n=performance.now());let s=this.partialParser.getParsedPageById(i);Ra(r,s)}for(let i of this.addedByDiff)r.add(i);for(let i of this.removedByDiff)r.delete(i);return z.debug("nodeIdsToLoad",r.size,pe(performance.now()-e)),r}addNodeChanges(e){for(let r of e){let n=r.id;r.added?(this.addedByDiff.add(n),this.removedByDiff.delete(n)):r.removed&&(this.addedByDiff.delete(n),this.removedByDiff.add(n))}}};function Ra(o,t){if(t&&(o.add(t.id),!!t.children))for(let e of t.children)Ra(o,e)}var Dt=class{constructor(t,e){this.node=t;this.duration=e}hasNode(){return!!this.node}take(){let t=this.node;return this.node=void 0,t}},bo=class{constructor(t,e){this.id=t;this.parser=e;u(this,"data");u(this,"loadedScope")}async run(t){if(this.loadedScope)return this.loadedScope;let e=performance.now();this.data=this.parser.getParsedPageById(this.id);let r=performance.now()-e;if(await t.yield(),this.loadedScope)return this.loadedScope;let n=performance.now(),i=this.parser.buildPage(this.data);return i&&(i.cache.isShallowLoad=!1),this.loadedScope=new Dt(i,r+performance.now()-n),this.loadedScope}force(){if(this.loadedScope)return this.loadedScope;let t=performance.now();this.data||(this.data=this.parser.getParsedPageById(this.id));let e=this.parser.buildPage(this.data);return e&&(e.cache.isShallowLoad=!1),this.loadedScope=new Dt(e,performance.now()-t),this.loadedScope}};async function Qu(o){return Ls.get(`/web/v1/sites/hostnames/${o}`)}var xa=class extends Xr{};var Sr=class{constructor(){u(this,"cache",new Map)}set(t,e,r){let n=this.cache.get(t);n||(n=new Map,this.cache.set(t,n)),n.set(e,r)}getSubMap(t){return this.cache.get(t)}get(t,e){return this.cache.get(t)?.get(e)}clear(){this.cache.clear()}};var In=class{constructor(t){u(this,"seqs",[]);u(this,"idxs",[]);u(this,"maxSize");this.maxSize=t?.maxSize}clear(){this.seqs=[],this.idxs=[]}get(t){let e=this.seqs.length;if(e===0)return 0;let r=Da(this.seqs,t);return r<e&&this.seqs[r]===t?this.idxs[r]:0}add(t,e){if(this.maxSize&&this.seqs.length>=this.maxSize&&this.seqs[0]>t)return;let i=Da(this.seqs,t);if(i<this.seqs.length&&this.seqs[i]===t){e<this.idxs[i]&&(this.idxs[i]=e,this.propagateLeftFrom(i));return}this.seqs.splice(i,0,t),this.idxs.splice(i,0,e),i+1<this.idxs.length&&(this.idxs[i]=Math.min(this.idxs[i],this.idxs[i+1])),this.propagateLeftFrom(i),this.evict()}evict(){if(this.maxSize){let t=this.seqs.length-this.maxSize;t>0&&(this.seqs.splice(0,t),this.idxs.splice(0,t))}}propagateLeftFrom(t){let e=this.idxs[t];for(let r=t-1;r>=0&&!(this.idxs[r]<=e);r--)this.idxs[r]=e}__snapshot(){return this.seqs.map((t,e)=>({seq:t,idx:this.idxs[e]}))}};function Da(o,t){let e=0,r=o.length;for(;e<r;){let n=e+r>>>1;o[n]<t?e=n+1:r=n}return e}var vr=class{constructor(t){this.buffer=t;u(this,"view");u(this,"decoder",new TextDecoder);u(this,"byteOffset",0);this.view=new DataView(t.buffer,t.byteOffset,t.byteLength)}align(t){let e=(t-this.byteOffset%t)%t;this.byteOffset+=e}endOfFile(){return this.byteOffset>=this.buffer.byteLength}readUint8(){let t=this.view.getUint8(this.byteOffset);return this.byteOffset+=1,t}readUint16(){let t=this.view.getUint16(this.byteOffset,!0);return this.byteOffset+=2,t}readVarUint(){let t=0,e=0;for(;;){let r=this.readUint8();if(t+=(r&127)*2**e,(r&128)===0)break;if(e+=7,e>53)throw new Error("VarUint is too big")}return t}readString(){let t=this.readVarUint(),e=this.buffer.subarray(this.byteOffset,this.byteOffset+t);return this.byteOffset+=t,this.decoder.decode(e)}readTypedArray(t){let e=this.readVarUint(),r=t.BYTES_PER_ELEMENT;this.align(r);let n=this.byteOffset+this.buffer.byteOffset,i=e*r;if(n%r!==0){let s=new ArrayBuffer(i);return new Uint8Array(s).set(new Uint8Array(this.buffer.buffer,n,i)),this.byteOffset+=i,new t(s,0,e)}return this.byteOffset+=i,new t(this.buffer.buffer,n,e)}};var _c=1024*1024,br=class{constructor(t=new Uint8Array(_c)){this.buffer=t;u(this,"view");u(this,"encoder",new TextEncoder);u(this,"byteOffset",0);this.view=new DataView(this.buffer.buffer)}ensureCapacity(t){let e=this.byteOffset+t;if(e>this.buffer.length){let r=this.buffer.length*2;for(;r<e;)r*=2;let n=new Uint8Array(r);n.set(this.buffer),this.buffer=n,this.view=new DataView(this.buffer.buffer)}}align(t){let e=this.byteOffset+t-1&~(t-1);this.ensureCapacity(e-this.byteOffset),this.byteOffset=e}writeUint8(t){return this.ensureCapacity(1),this.view.setUint8(this.byteOffset,t),this.byteOffset+=1,1}writeUint16(t){this.ensureCapacity(2),this.view.setUint16(this.byteOffset,t,!0),this.byteOffset+=2}writeVarUint(t){let e=t;for(;e>=128;)this.writeUint8(e%128|128),e=Math.floor(e/128);this.writeUint8(e)}writeString(t){let e=this.encoder.encode(t);this.writeVarUint(e.length),this.ensureCapacity(e.length),this.buffer.set(e,this.byteOffset),this.byteOffset+=e.length}writeTypedArray(t,e=t.length){this.writeVarUint(e);let r=this.preallocateTypedArray(t.BYTES_PER_ELEMENT,e),n=new Uint8Array(t.buffer,t.byteOffset,r);this.buffer.set(n,this.byteOffset),this.byteOffset+=r}preallocateTypedArray(t,e){this.align(t);let r=e*t;return this.ensureCapacity(r),r}writeBytes(t){this.ensureCapacity(t.length),this.buffer.set(t,this.byteOffset),this.byteOffset+=t.length}getBuffer(){return this.buffer.slice(0,this.byteOffset)}};function Cr(o){if(o===Uint8Array)return"U8";if(o===Uint16Array)return"U16";if(o===Uint32Array)return"U32";if(o===Float64Array)return"F64";throw new Error("Invalid array name")}var qt=class{constructor(t,e,r){this.capacity=t;u(this,"buffer");u(this,"length",0);r?(this.buffer=r.buffer,this.length=r.length,h(this.buffer.length===this.capacity,"Buffer capacity mismatch:",this.buffer.length,"!=",this.capacity)):this.buffer=new e(t)}push(t){this.buffer[this.length]=t,this.length+=1}};var $c=2**17,Wt=class{constructor(t,e=$c){this.arrayConstructor=t;this.bucketSize=e;u(this,"buckets",[]);u(this,"_length",0);u(this,"bucketShift");u(this,"bucketMask");h((e&e-1)===0,`Bucket size must be a power of 2, got: ${e}`),this.bucketShift=Math.log2(e),this.bucketMask=e-1}get type(){return`BucketedColumn(${Cr(this.arrayConstructor)})`}add(t){let e=this.buckets[this.buckets.length-1];(!e||e.length>=e.capacity)&&(e=new qt(this.bucketSize,this.arrayConstructor),this.buckets.push(e)),e.push(t);let r=this._length;return this._length+=1,r}get(t){h(t>=0&&t<this._length,"index",t,"out of bounds (column size:",this._length,")");let e=t>>this.bucketShift,r=t&this.bucketMask,n=this.buckets[e];return h(n,"invalid bucket index"),n.buffer[r]}get length(){return this._length}slice(t,e){t<0&&(t=this.length+t),e<0&&(e=this.length+e);let r=t>>this.bucketShift,n=e>>this.bucketShift,i=Math.min(this.length,e)-t;if(i<=0)return[];let s=Array.from({length:i}),a=0,c=t&this.bucketMask,d=this.buckets[r];if(r===n){let g=e&this.bucketMask;for(let y=c;y<g;++y)s[a++]=d.buffer[y];return s}for(let g=c;g<this.bucketSize;++g)s[a++]=d.buffer[g];for(let g=r+1;g<n;++g){let y=this.buckets[g];for(let m=0;m<y.length;++m)s[a++]=y.buffer[m]}let p=e&this.bucketMask,l=this.buckets[n];if(l)for(let g=0;g<p;++g)s[a++]=l.buffer[g];return s}serialize(t){t.writeVarUint(this.length),t.preallocateTypedArray(this.arrayConstructor.BYTES_PER_ELEMENT,this.length);for(let e of this.buckets)t.writeBytes(new Uint8Array(e.buffer.buffer,e.buffer.byteOffset,e.length*this.arrayConstructor.BYTES_PER_ELEMENT))}deserialize(t){let e=t.readTypedArray(this.arrayConstructor);this._length=e.length;let r=0;for(r=0;r<e.length-this.bucketSize;r+=this.bucketSize){let n=e.subarray(r,r+this.bucketSize);this.buckets.push(new qt(this.bucketSize,this.arrayConstructor,{buffer:n,length:n.length}))}if(r<e.length){let n=new qt(this.bucketSize,this.arrayConstructor);for(;r<e.length;++r)n.push(e[r]);this.buckets.push(n)}}};var Tr=class o{constructor(t,e){this.arrayConstructor=t;u(this,"uniques",[]);u(this,"maxUniques");u(this,"indices");u(this,"count",0);u(this,"lookup");u(this,"cursor",0);if(this.indices=new Wt(t,e),t===Uint8Array)this.maxUniques=2**8-1;else if(t===Uint16Array)this.maxUniques=2**16-1;else if(t===Uint32Array)this.maxUniques=2**32-1;else if(t===Float64Array)this.maxUniques=Number.MAX_SAFE_INTEGER;else throw new Error(`Unsupported array constructor: ${t.name}`)}get type(){return`LazyNormalizedBucketedColumn(ref: ${Cr(this.arrayConstructor)})`}static withBuckets({buffer:t,size:e}){return{create:()=>new o(t,e)}}hydrateThrough(t){for(this.lookup||(this.lookup=new Map);this.cursor<=t;++this.cursor){let e=this.uniques[this.cursor];this.lookup.set(e,this.cursor)}}indexOfExisting(t){if(this.lookup?.has(t))return this.lookup.get(t);for(;this.cursor<this.uniques.length;++this.cursor){let e=this.uniques[this.cursor];if(this.lookup??=new Map,this.lookup.set(e,this.cursor),Object.is(e,t))return this.cursor}}add(t){let e=this.indexOfExisting(t);e===void 0&&(h(this.uniques.length<this.maxUniques,"limit reached for unique values"),e=this.uniques.length,this.uniques.push(t),this.lookup??=new Map,this.lookup.set(t,e),this.cursor=this.uniques.length);let r=this.count;return this.indices.add(e),this.count=r+1,r}get(t){h(t>=0&&t<this.count,"index out of bounds");let e=this.indices.get(t);return this.uniques[e]}slice(t,e){let r=Math.max(0,e-t),n=new Array(r),i=this.indices.slice(t,e);for(let s=0;s<r;++s)n[s]=this.uniques[i[s]];return n}get length(){return this.count}serialize(t){t.writeString(JSON.stringify(this.uniques)),this.indices.serialize(t)}deserialize(t){let e=t.readString();this.indices.deserialize(t),this.uniques=JSON.parse(e),this.count=this.indices.length,this.lookup=void 0,this.cursor=0}rehydrate(){this.cursor<this.uniques.length&&this.hydrateThrough(this.uniques.length-1)}};var Jt=class{constructor(t=1024){u(this,"uniques",[]);u(this,"indices");u(this,"count",0);u(this,"lookup");u(this,"cursor",0);this.indices=new Uint32Array(t)}get type(){return"LazyNormalizedColumn"}ensureCapacity(t){if(t<=this.indices.length)return;let e=this.indices.length||1;for(;e<t;)e<<=1;let r=new Uint32Array(e);r.set(this.indices),this.indices=r}hydrateThrough(t){for(this.lookup||(this.lookup=new Map);this.cursor<=t;++this.cursor){let e=this.uniques[this.cursor];this.lookup.set(e,this.cursor)}}indexOfExisting(t){if(this.lookup?.has(t))return this.lookup.get(t);for(;this.cursor<this.uniques.length;++this.cursor){let e=this.uniques[this.cursor];if(this.lookup??=new Map,this.lookup.set(e,this.cursor),Object.is(e,t))return this.cursor}}add(t){let e=this.indexOfExisting(t);e===void 0&&(e=this.uniques.length,this.uniques.push(t),this.lookup??=new Map,this.lookup.set(t,e),this.cursor=this.uniques.length);let r=this.count;return this.ensureCapacity(r+1),this.indices[r]=e,this.count=r+1,r}get(t){if(t<0||t>=this.count)throw RangeError("index out of bounds");return this.uniques[this.indices[t]]}slice(t,e){let r=Math.max(0,e-t),n=new Array(r);for(let i=0;i<r;++i)n[i]=this.uniques[this.indices[t+i]];return n}get length(){return this.count}serialize(t){t.writeString(JSON.stringify(this.uniques)),t.writeTypedArray(this.indices.subarray(0,this.count))}deserialize(t){let e=t.readString(),r=t.readTypedArray(Uint32Array);this.uniques=JSON.parse(e),this.indices=new Uint32Array(r),this.count=this.indices.length,this.lookup=void 0,this.cursor=this.uniques.length}rehydrate(){this.cursor<this.uniques.length&&this.hydrateThrough(this.uniques.length-1)}};var Ye=class Ye{constructor(){u(this,"columns",{client:Tr.withBuckets({buffer:Uint32Array}).create(),seq:new Wt(Float64Array),id:new Jt,key:new Jt,value:new Jt,user:Tr.withBuckets({buffer:Uint8Array}).create()})}getRowInternal(t){return{client:this.columns.client.get(t),seq:this.columns.seq.get(t),id:this.columns.id.get(t),key:this.columns.key.get(t),value:this.columns.value.get(t),user:this.columns.user.get(t)}}getRow(t){if(t<0||t>=this.columns.client.length)throw new Error("Index out of bounds");return this.getRowInternal(t)}getRows(t=0,e=this.columns.client.length){if(t<0||e>this.columns.client.length||t>e)throw new Error("Index out of bounds");let r=new Array(e-t);for(let n=t;n<e;n++)r[n-t]=this.getRowInternal(n);return r}toBuffer(){let t=new br;t.writeString(Ye.MAGIC),t.writeUint16(Ye.VERSION);let e;for(e in this.columns){let r=this.columns[e];t.writeString(e),t.writeString(r.type),r.serialize(t)}return t.getBuffer()}fromBuffer(t){let e=new vr(t),r=e.readString();h(r===Ye.MAGIC,"Not a framer document:",r);let n=e.readUint16();for(h(n===Ye.VERSION,"Version mismatch:",n,"(actual)","!=",Ye.VERSION,"(expected)");!e.endOfFile();){let i=e.readString(),s=this.columns[i];h(s,"Column",i,"not found");let a=e.readString();h(a===s.type,"Column type does not match:",a,"(actual)","!=",s.type,"(expected)"),s.deserialize(e)}}get length(){return this.columns.client.length}};u(Ye,"VERSION",1),u(Ye,"MAGIC","FRAMERCRDT");var Ht=Ye;function To(o,t){let e=o.length,r=t.length,n=Array.from({length:e+1},()=>new Array(r+1).fill(0));for(let c=e-1;c>=0;--c)for(let d=r-1;d>=0;--d)o[c]===t[d]?n[c][d]=n[c+1][d+1]+1:n[c][d]=Math.max(n[c+1][d],n[c][d+1]);let i=[],s=0,a=0;for(;s<e&&a<r;)o[s]===t[a]?(s+=1,a+=1):n[s+1][a]>n[s][a+1]?(i.push({operation:"delete",index:s}),s+=1):(i.push({operation:"insert",index:a,value:t[a]}),a+=1);for(;s<e;)i.push({operation:"delete",index:s}),s+=1;for(;a<r;)i.push({operation:"insert",index:a,value:t[a]}),a+=1;return i}function wo(o,t,e,r,n,i){let s=t-o;if(s<1e-8)return o+s/2;let a;if(r!==null&&r===e&&n!==null){let d=i-n;a=Math.min(.01*d,.5)}else a=.01+((e^i)>>>0)%100/100*.98;let c=o+s*a;return c<=o||c>=t?o+s/2:c}var Pa=new ArrayBuffer(8),jc=new Float64Array(Pa),ka=new Uint32Array(Pa),qc=o=>(jc[0]=o,[ka[0]>>>0,ka[1]>>>0]),Ea=(o,t)=>o<<t|o>>>32-t,Rn=(o,t)=>{let e=Math.imul(t,3432918353);e=Ea(e,15),e=Math.imul(e,461845907);let r=o^e;return r=Ea(r,13),Math.imul(r,5)+3864292196>>>0},Io=o=>{let t=o;return t^=t>>>16,t=Math.imul(t,2246822507),t^=t>>>13,t=Math.imul(t,3266489909),(t^t>>>16)>>>0},Nn=o=>{let t=0,e=0;for(;e+1<o.length;e+=2){let r=o.charCodeAt(e)|o.charCodeAt(e+1)<<16;t=Rn(t,r)}return e<o.length&&(t=Rn(t,o.charCodeAt(e))),Io(t^o.length)},Wc=2097151,Jc=o=>{let t=2654435769,e=2135587861,r=i=>{t=Rn(t,i),e=Rn(e,i^2915580697)},n=i=>{switch(typeof i){case"string":r(Nn(i));break;case"number":{let[s,a]=qc(i);r(s),r(a)}break;case"boolean":r(i?1:0);break;case"undefined":r(2);break;case"symbol":r(Nn(i.description??""));break;case"bigint":r(Number(i&0xffffffffn)),r(Number(i>>32n&0xffffffffn));break;case"function":r(Nn(i.toString()));break;case"object":{if(i===null){r(7);break}if(Array.isArray(i)){let a=i.length;if(r(165),r(a),a>32){for(let d=0;d<8;++d)n(i[d]);for(let d=a-8;d<a;++d)n(i[d]);let c=(a-16)/16|0;for(let d=8;d<a-8;d+=c)n(i[d])}else for(let c=0;c<a;++c)n(i[c]);break}r(195);let s=0;for(let a in i){if(++s>32)break;r(Nn(a)),n(i[a])}r(s);break}default:r(13)}};return n(o),t=Io(t),e=Io(e),(t&Wc)*4294967296+e},No=Jc;function wr(o){return typeof o=="object"&&o!==null}function Hc(o,t){if(o.length!==t.length)return!1;let e=o.length;for(let r=0;r<e;r++)if(o[r]!==t[r])return!1;return!0}var Y="$deleted",ft="$keep",xn="$keep_value";function Gc(o,t,e,r){return o===e?t>r:o>e}function Kc(o,t){return o.seq===t.seq?o.client-t.client:o.seq-t.seq}function Ro(o){if(typeof o=="string"&&o.startsWith("arr("))return o.slice(4,-1)}function Ir(o){if(typeof o=="string"&&o.startsWith("obj("))return o.slice(4,-1)}function La(o){return`arr(${o})`}function Gt(o){return`obj(${o})`}function Qc(o,t,e=0){let r={},n=r;for(let s=e;s<o.length-1;++s){let a=o[s];n[a]={},n=n[a]}let i=o[o.length-1];return n[i]=t,r}var kt=class o{constructor({client:t,user:e}){u(this,"_seq",0);u(this,"table",new Ht);u(this,"latest",new Sr);u(this,"resolved",new Map);u(this,"arraySortedIndicesCache",new Map);u(this,"parentIdOverrides",new Map);u(this,"parentIdHistoryByNodeId",new Map);u(this,"minIndexCache",new In({maxSize:1e3}));u(this,"client");u(this,"user");u(this,"getIdFromObject");u(this,"transactionSeq");u(this,"readTransactionLevel",0);u(this,"foundIds",new Set);this.client=t,this.user=e,this.reset()}reset(){this._seq=0,this.transactionSeq=void 0,this.table=new Ht,this.latest.clear(),this.resolved.clear(),this.arraySortedIndicesCache.clear(),this.minIndexCache.clear(),this.parentIdOverrides.clear(),this.parentIdHistoryByNodeId.clear()}fromBuffer(t){h(this.transactionSeq===void 0,"You cannot intialise from a buffer during a transaction"),this.reset(),this.table.fromBuffer(t),this.indexRowsOptimized(),this.fixHierarchy()}toBuffer(){return this.table.toBuffer()}get seq(){return this._seq}getRows(t,e){return this.table.getRows(t,e)}getRowsSorted(){return this.getRows().sort(Kc)}getFirstRowForSeq(t){return this.minIndexCache.get(t)}indexRowsOptimized(){let{client:t,id:e,key:r,seq:n,value:i}=this.table.columns;for(let s=this.length-1;s>=0;s--)this.updateRowIndex(s,n.get(s),e.get(s),r.get(s),i.get(s),t.get(s))}clone(t){let e=new o({client:t??this.client,user:this.user});return e.fromBuffer(this.toBuffer()),e.indexRowsOptimized(),e.getIdFromObject=this.getIdFromObject,e}createUniqueKeyFromRow(t){return`${t.client}/${t.seq}/${t.id}/${t.key}`}merge(t){return this.mergeRows(t.getRows())}mergeRows(t){h(this.transactionSeq===void 0,"You cannot add rows during a transaction");let e=new Set(this.getRows().map(i=>this.createUniqueKeyFromRow(i))),r=1/0,n=!1;for(let i of t){i.key==="parentid"&&(n=!0);let s=this.createUniqueKeyFromRow(i);e.has(s)||(e.add(s),this.addRowData(i.id,i.key,i.value,i.client,i.seq,i.user),r=Math.min(r,i.seq))}return this.resolved.clear(),this.arraySortedIndicesCache.clear(),n&&this.fixHierarchy(r),r}addRows(t){h(this.transactionSeq===void 0,"You cannot add rows during a transaction");let e=1/0,r=!1;for(let n of t)n.key==="parentid"&&(r=!0),this.addRowData(n.id,n.key,n.value,n.client,n.seq,n.user),e=Math.min(e,n.seq);return this.resolved.clear(),this.arraySortedIndicesCache.clear(),r&&this.fixHierarchy(e),e}transaction(t){h(this.transactionSeq===void 0,"You cannot nest transactions"),this.transactionSeq=this._seq;try{return t()}finally{this.transactionSeq=void 0}}updateKeyValue(t,e,r){let n=this.transactionSeq??this._seq;this.addRowData(t,e,r,this.client,n,this.user)}addRowData(t,e,r,n,i,s){let a=this.table.columns.client.length;if(!this.shouldAddRow(t,e,r,i,n))return;let c=this.table.columns;c.client.add(n),c.seq.add(i),c.id.add(t),c.key.add(e),c.value.add(r),c.user.add(s),this.updateRowIndex(a,i,t,e,r,n)}shouldAddRow(t,e,r,n,i){let s=this.latest.get(t,e);if(s===void 0)return!0;let a=this.table.columns;if(a.value.get(s)!==r)return!0;let d=a.seq.get(s),p=a.client.get(s);return!(d===n&&p===i)}updateRowIndex(t,e,r,n,i,s){e>=this._seq&&(this._seq=e+1);let a=this.latest.get(r,n),c=this.table.columns;if((a===void 0||Gc(e,s,c.seq.get(a),c.client.get(a)))&&this.latest.set(r,n,t),this.resolved.delete(r),this.arraySortedIndicesCache.delete(r),n==="parentid"){let d=this.parentIdHistoryByNodeId.get(r);d||(d=[],this.parentIdHistoryByNodeId.set(r,d)),d.push(t)}this.minIndexCache.add(e,t)}getPrevParentId(t,e,r){let n,i=this.parentIdHistoryByNodeId.get(t);if(!i?.length)return n;let s=this.table.columns;for(let a of i){let c=s.seq.get(a);if(c>e||!r&&c===e)continue;let d=s.client.get(a);(!n||c>n.seq||c===n.seq&&d>n.client)&&(n={seq:c,client:d,value:s.value.get(a)})}return n}isAncestorOf(t,e,r,n=new Set){if(t===e)return!0;if(!t||t==="$deleted"||n.has(t))return!1;n.add(t);let i=this.getPrevParentId(t,r,!0);if(!i)return!1;let s=this.parentIdOverrides.get(t)?.get(i.seq)??i.value;return this.isAncestorOf(s,e,r,n)}fixHierarchy(t=0){this.parentIdHistoryByNodeId=new Map([...this.parentIdHistoryByNodeId.entries()].sort((r,n)=>r[0].localeCompare(n[0])));for(let[r,n]of this.parentIdOverrides)for(let[i,s]of n)i>=t&&n.delete(i);let e=this.table.columns;for(let[r,n]of this.parentIdHistoryByNodeId)for(let i of n){let s=e.seq.get(i);if(s<t)continue;let a=e.value.get(i);if(this.isAncestorOf(a,r,s)){let c=this.parentIdOverrides.get(r);c||(c=new Map,this.parentIdOverrides.set(r,c));let d=this.getPrevParentId(r,s,!1);c.set(s,d?d.value:Y)}}}getParentId(t){let e=this.latest.get(t,"parentid");if(!e)return;let r=this.table.columns.seq.get(e);return this.parentIdOverrides.get(t)?.get(r)??this.table.columns.value.get(e)}getChildrenIds(t){let e=this.getCurrentValue(t,"children");if(!e)return;let r=Ro(e);if(!r)return;let n=this.getArray(r,!1);if(!Array.isArray(n))return;let i=new Set;for(let a of n){let c=Ir(a);c&&this.getParentId(c)===t&&i.add(c)}let s=Array.from(this.parentIdOverrides.keys()).sort((a,c)=>a.localeCompare(c));for(let a of s)i.has(a)||this.getParentId(a)===t&&i.add(a);return Array.from(i)}_getIdFromObject(t){return this.getIdFromObject?.(t)}createReferenceId(t,e,r,n,i){if(e===0)return`${r}.${n}`;if(e===1)return`${r}.${i??No(t)}`;ye(e)}getOrCreateReferenceFromValue(t,e,r,n){if(Array.isArray(t)){let i=this.createReferenceId(t,e,r,n,void 0);return this.setArray(i,t),La(i)}if(wr(t)){let i=typeof t.id=="string"?t.id:void 0,s=this._getIdFromObject(t)??this.createReferenceId(t,e,r,n,i);return this.setObject(s,t),Gt(s)}return t}getReferenceValue(t,e,r,n){let i=Ro(t);if(i)return this.getArray(i,!0,r,n);let s=Ir(t);return s?this.getObjectInner(s,!0,e,r,n):t}getCurrentValue(t,e){let r=this.latest.get(t,e);if(r!==void 0)return this.table.columns.value.get(r)}getCurrentSeq(t,e){let r=this.latest.get(t,e);if(r!==void 0)return this.table.columns.seq.get(r)}validateObjectUpdate(t,e){if(!wr(e))throw new Error("Store.setObject: object is not an object");let r=this._getIdFromObject(e);if(r&&r!==t)throw new Error(`Store.getIdFromObject mismatch: ${r} !== ${t}: The id that we got to update the object is not equal to the result of getIdFromObject. See Store.update.test.ts`);return t}deleteRemovedKeys(t,e){let r=this.latest.getSubMap(t);if(r)for(let[n]of r)n!==ft&&(n in e||this.setObjectKey(t,n,Y))}tryReuseExistingReference(t,e){let r=Ro(t);if(Array.isArray(e)&&r)return this.setArray(r,e),!0;let n=Ir(t);return wr(e)&&n?(this.setObject(n,e),!0):!1}insertNode(t){h(typeof t?.id=="string","inserting node without a valid id"),this.setObject(t.id,t)}removeNode(t){h(this.latest.get(t,"id")!==void 0,"trying to remove a node that doesn't exist:",t),this.setObjectKey(t,"parentid",Y)}updateNode(t,e){h(this.latest.get(t,"id")!==void 0,"trying to update a node that doesn't exist:",t);for(let r in e)this.setObjectKey(t,r,e[r])}updateNestedObject(t,e){let[r,...n]=t;h(this.latest.get(r,"id")!==void 0,"trying to update nested properties on node doesn't exist:",r);for(let i in e)this.setObjectKeyPath(r,[...n,i],e[i])}moveNode(t,e){h(this.latest.get(t,"id")!==void 0,"trying to move a node that doesn't exist:",t),this.setObjectKey(t,"parentid",e)}setObject(t,e){let r=this.validateObjectUpdate(t,e);if(this.deleteRemovedKeys(r,e),Object.keys(e).length===0){this.setObjectKey(r,ft,xn);return}for(let n in e)this.setObjectKey(r,n,e[n])}setObjectKey(t,e,r){let n=this.getCurrentValue(t,e);if(this.tryReuseExistingReference(n,r))return n;let i=this.getOrCreateReferenceFromValue(r,0,t,e);return n===i||this.updateKeyValue(t,e,i),n}deleteObjectKey(t,e){this.getCurrentValue(t,e)!==void 0&&this.updateKeyValue(t,e,Y)}setObjectKeyPath(t,e,r){if(!e[0])return;let n=t;for(let s=0;s<e.length-1;++s){let a=e[s],c=this.getCurrentValue(n,a);if(c===Y){let p=Qc(e.slice(s+1),r);this.setObjectKey(n,a,p);return}c||(this.setObjectKey(n,a,{}),c=this.getCurrentValue(n,a));let d=Ir(c);if(!d){let p=e.slice(0,s+1);throw new Error(`${p.join(".")} is not an object`)}n=d}let i=e[e.length-1];this.setObjectKey(n,i,r)}getObjectKey(t,e){if(this.getCurrentValue(t,ft)!==Y)return this.getReferenceValue(this.getCurrentValue(t,e),!0,1/0,0)}getRawObjectData(t){return this.getObjectInner(t,!1,!0)}getObject(t){return this.getObjectInner(t,!0,!0)}getObjectWithShallowChildren(t,e){return this.getObjectInner(t,!0,!0,e,0)}getObjectInner(t,e,r,n=1/0,i=0){this.readTransactionLevel++;let s=()=>{this.readTransactionLevel--,this.foundIds.delete(t)};if(this.foundIds.has(t)){s();return}if(this.foundIds.add(t),!r&&this.resolved.has(t))return s(),this.resolved.get(t);let a=this.latest.getSubMap(t);if(!a){s();return}let c={};r||this.resolved.set(t,c);let d=this.table.columns;if(this.getCurrentValue(t,ft)===Y){s();return}let p=a.get("children");p!==void 0&&i<n&&(c.children=e?this.getChildrenIds(t)?.map(l=>this.getReferenceValue(Gt(l),r,n,i+1)):d.value.get(p)),a.has("parentid")&&(c.parentid=this.getParentId(t));for(let[l,g]of a){if(l===ft||g===void 0)continue;let y=d.value.get(g);y!==Y&&(l==="children"||l==="parentid"||(c[l]=e?this.getReferenceValue(y,r,n,i+1):y))}return s(),this.readTransactionLevel===0&&this.foundIds.clear(),c}applyArrayEdits(t,e){let r=0;for(let n of e)switch(n.operation){case"delete":this.arrayRemove(t,n.index+r,1),r--;break;case"insert":this.arrayInsert(t,n.index,n.value),r++;break}}setArray(t,e){let r=this.getArray(t,!1);r||(this.updateKeyValue(t,-1,xn),r=[]);let n=e.map(s=>this.getOrCreateReferenceFromValue(s,1,t,void 0)),i=To(r,n);this.applyArrayEdits(t,i)}getArraySortedIndicesCached(t){let e=this.arraySortedIndicesCache.get(t);if(e)return e;let r=this.latest.getSubMap(t);if(!r)return[];let n=this.table.columns,s=Array.from(r.values()).sort((a,c)=>n.key.get(a)-n.key.get(c)).filter(a=>{let c=n.value.get(a);return c!==Y&&c!==xn});return this.arraySortedIndicesCache.set(t,s),s}getArray(t,e=!0,r=1/0,n=0){if(!this.latest.getSubMap(t))return;let s=this.getArraySortedIndicesCached(t),a=this.table.columns,c=[];for(let d of s){let p=a.value.get(d);p===xn||p===Y||c.push(e?this.getReferenceValue(p,!0,r,n+1):p)}return c}arrayReplace(t,e,r){return this.arraySplice(t,e,1,r)}arraySplice(t,e,r,...n){if(!this.latest.getSubMap(t))return;let s=this.getArraySortedIndicesCached(t),a=s.length,c=e<0?Math.max(a+e,0):Math.min(e,a),d=r===void 0?a-c:Math.min(r,a-c),p=this.table.columns,l=[];for(let C of s.slice(c,c+d))l.push(p.value.get(C)),this.updateKeyValue(t,p.key.get(C),Y);let g=c>0?s[c-1]:void 0,y=g!==void 0?p.key.get(g):0,m=s[c],S=m!==void 0?p.key.get(m):y+1,I=y,T=g!==void 0?p.client.get(g):null,N=g!==void 0?p.seq.get(g):null;for(let C of n){let R=T===this.client&&N!==null?N+1:1,x=wo(I,S,this.client,T,N,R);this.updateKeyValue(t,x,this.getOrCreateReferenceFromValue(C,1,t,void 0)),I=x,T=this.client,N=R}return l}arrayInsert(t,e,...r){return this.arraySplice(t,e,0,...r)}arrayRemove(t,e,r=1){return this.arraySplice(t,e,r)}get length(){return this.table.columns.client.length}compact(){let t=new o({client:this.client,user:this.user});t.getIdFromObject=this.getIdFromObject;let e=new Set,r=this.table.columns;for(let n=0;n<this.length;n++)e.add(r.id.get(n));for(let n of e){let i=this.latest.getSubMap(n);if(i)for(let[s,a]of i){if(a===void 0)continue;let c=r.value.get(a),d=r.client.get(a),p=r.seq.get(a),l=r.user.get(a);c!==Y&&t.addRowData(n,s,c,d,p,l)}}return t}};function Ma(o,t=!0){let e=Ps(t),r=new kt({client:e,user:o});return r.getIdFromObject=n=>n.__class&&pr(n.__class)?n.id:void 0,r}var pt=D("tree:timeline"),Xc=6e4,Yc=6e4,xo=class{constructor(t){this.nodeChangesBuffers=t;u(this,"changes",new Map);this.nodeChangesBuffers.add(this)}trackChange(t,e){let r=this.changes.get(t);if(r){e&&r.push(e);return}this.changes.set(t,e?[e]:[])}read(){let t=this.changes;return this.changes=new Map,t}clear(){this.changes=new Map}dispose(){this.nodeChangesBuffers.delete(this)}},Dn=class{constructor(t,e,r=[],n=!1){this.tree=t;this.changes=e;this.editReasons=r;this.wasRebase=n;u(this,"wasScopeInsert",!1);u(this,"version",0);u(this,"timestamp",performance.now())}toDebugData(){return{version:this.version,changes:this.changes,editReasons:this.editReasons,wasScopeInsert:this.wasScopeInsert,wasRebase:this.wasRebase}}},kn=class{constructor(){u(this,"idToChanges",new Map)}getChanges(){return Array.from(this.idToChanges.values())}addChanges(t){if(t)for(let e of t){let r=this.idToChanges.get(e.id);r||(r={id:e.id,to:{}},this.idToChanges.set(e.id,r)),uo(r,e)}}},Va=class{constructor(t,e){u(this,"tree");u(this,"entries");u(this,"latestReversibleNodeChanges",null);u(this,"enableAddRemoveOptimizations",!0);u(this,"store");u(this,"trimmed",0);u(this,"isPartialLoading",!1);u(this,"internalRemoteTreeIndex",0);u(this,"inErrorRecovery",!1);u(this,"nodeChangesBuffers",new Set);u(this,"legacyMode",!1);u(this,"remoteTreeVersion",0);u(this,"recentEditReasons",[]);u(this,"flagsForNextCommit");u(this,"onlineStartTime",0);u(this,"validationEnabled",Ke.isOn("remoteDocumentSyncValidation")&&!0&&!hr());u(this,"extraChangesForNextCommit");u(this,"resetTime",0);u(this,"epoch",0);this.store=Ma(""),this.reset(t,e)}get length(){return this.entries.length+this.trimmed}get localTreeIndex(){return this.length-1}get remoteTreeIndex(){return this.internalRemoteTreeIndex}incrementRemoteTreeIndex(t){this.internalRemoteTreeIndex+=t}setOnline(t){this.online!==t&&(this.onlineStartTime=t?performance.now():0)}get online(){return this.onlineStartTime!==0}setFlagsForNextCommit(t){this.flagsForNextCommit=t}validateUpdatesAreSentToServer(){if(!this.validationEnabled||!this.online)return;let t=performance.now();if(t-this.onlineStartTime<Yc)return;let r=this.getOldestLocalEntry();if(!r)return;let n=t-r.timestamp;h(n<Xc,"Local changes not been processed in a while")}setExtraChangesForNextCommit(t){this.extraChangesForNextCommit=t}recordEditReasons(t){t&&this.recentEditReasons.push(t)}trackChange(t,e=null){for(let r of this.nodeChangesBuffers)r.trackChange(t,e)}getTreeForVersion(t){if(!this.isPartialLoading)return ms(this.entries,e=>e.version===t)?.tree}addEntry(t,e,r=[],n=!1){let i=new Dn(t,e,r,n);return this.entries.push(i),this.tree=t,i}getLastEntry(){let t=this.entries[this.entries.length-1];return h(t,"Timeline has no entries"),t}getOldestLocalEntry(){return this.getEntry(this.remoteTreeIndex+1)}getEntry(t){return this.entries[t]}reset(t,e){if(this.resetTime=performance.now(),this.inErrorRecovery&&t===this.tree){pt.debug("reset for error recovery..."),this.inErrorRecovery=!1,this.invalidateAllCursors(),this.clearNodeChangesReader();return}pt.debug("reset with tree:",t.root.id,"size:",t.size()),this.entries=[],this.addEntry(t,e?.initialChanges??[],["load"]),this.recentEditReasons=[],this.flagsForNextCommit=void 0,this.extraChangesForNextCommit=void 0,this.latestReversibleNodeChanges=null,this.trimmed=0,this.internalRemoteTreeIndex=0,this.isPartialLoading=!!e?.isLoading,this.invalidateAllCursors(),this.clearNodeChangesReader()}invalidateAllCursors(){this.epoch+=1}openNodeChangesReader(){return new xo(this.nodeChangesBuffers)}clearNodeChangesReader(){for(let t of this.nodeChangesBuffers)t.clear()}applyFlagsToChange(t){t&&this.flagsForNextCommit&&(this.flagsForNextCommit.ignoreInUndo&&(t.ignoreInUndo=!0),this.flagsForNextCommit.ignoreInCodeGeneration&&(t.ignoreInCodeGeneration=!0))}commitLocalTree(){this.validateUpdatesAreSentToServer();let t=this.getLastEntry();h(this.tree===t.tree,"tree out of sync");let e={};this.tree=this.tree.commit((n,i)=>{if(!n&&!i)return;let s=on(n,i);if(this.applyFlagsToChange(s),this.trackChange(n?.id??i.id,s),s){if(s.to.parentid&&s.to.parentid!==s.from?.parentid){let c=this.tree.getScopeNodeAtStartFor(n),d=this.tree.getScopeNodeFor(i);c&&c?.id!==d?.id&&(s.previousScope=c.id)}e[s.id]=s}let a=[];Ts(a,n,i);for(let c of a)this.applyFlagsToChange(c),this.trackChange(c.id,c),e[c.id]=c}),this.latestReversibleNodeChanges=Object.values(e);let r=this.latestReversibleNodeChanges;if(this.extraChangesForNextCommit){r=[...r];for(let n of this.extraChangesForNextCommit)this.applyFlagsToChange(n),this.trackChange(n.id,n),r.push(n)}if(this.flagsForNextCommit=void 0,this.extraChangesForNextCommit=void 0,pt.debug("commit local tree:",r.length,this.recentEditReasons),r.length>0){if(hr())for(let n of r)this.updateStoreFromChanges(n);h(t.tree!==this.tree,"must be a new tree"),t.tree.releaseMemory(),this.entries.push(new Dn(this.tree,r,this.recentEditReasons))}else this.tree!==t.tree&&(t.tree.releaseMemory(),t.tree=this.tree);return this.recentEditReasons=[],h(this.tree===this.getLastEntry().tree),this.tree}updateStoreFromChanges(t){this.store.transaction(()=>{let{_deleted:e,...r}=t.to;if(t.removed){this.store.removeNode(t.id);return}if(vs(t.id)){let[n,i]=bs(t.id),s={...r};if(e)for(let a of e)s[a]=Y;if(this.store.updateNestedObject([n,"replicaInfo","overrides",i],s),t.toChildren){this.store.updateNode(t.id,{children:t.toChildren.map(a=>Gt(a))});for(let a of t.toChildren)this.store.moveNode(a,t.id)}}else{let n={...r};if(t.toChildren&&(n.children=t.toChildren.map(i=>Gt(i))),t.added){n.id=t.id,n.__class=t.added,this.store.insertNode(n);return}if(e)for(let i of e)n[i]=void 0;this.store.updateNode(t.id,n)}})}getLatestChangesForUndo(){return this.latestReversibleNodeChanges}getChangeTrackingCursor(){let t=this.remoteTreeIndex,e=this.localTreeIndex;return{remoteTree:t,localTree:e,timeline:this,tree:this.tree,epoch:this.epoch}}invalidatedByLoadCompletedDocument(t){return!(!t||this.trimmed>0||t.timeline!==this||t.epoch+1!==this.epoch||t.remoteTree+1!==this.remoteTreeIndex)}fetchForwardChanges(t){if(!t||t.epoch!==this.epoch||t.tree.lineage!==this.tree.lineage||t.tree.root.id!==this.tree.root.id||t.timeline!==this||t.localTree>0&&t.localTree<=this.trimmed||t.remoteTree>0&&t.remoteTree<=this.trimmed||this.remoteTreeIndex>0&&this.trimmed>0&&t.remoteTree===0)return;let e=t.localTree;if(this.remoteTreeIndex>0)for(e=t.remoteTree-1;e<t.localTree&&!this.entries[e+1-this.trimmed]?.wasRebase;)e+=1;h(e-this.trimmed>=0,"buffer cut too close to remoteTree"),h(e<=t.localTree,"startIndex incorrectly calculated");let r=this.localTreeIndex;h(e<=r,"bad change tracking cursor");let n=t.tree;return t.remoteTree=this.remoteTreeIndex,t.localTree=r,t.tree=this.tree,this.computeForwardChanges(e,r,n)}computeForwardChanges(t,e,r){if(t>=e)return[];let n={};for(let s=t+1;s<=e;s++){let a=this.entries[s-this.trimmed];for(let c of a.changes){let d=c.id,p=n[d];p||(p=n[d]={id:d,to:{}});let l=p.added;uo(p,c),!r&&l&&p.removed&&this.enableAddRemoveOptimizations&&delete n[d]}}let i=r??this.entries[t-this.trimmed]?.tree;if(!i)throw new Error(`${t} - ${this.trimmed}`);return Object.values(n).filter(s=>{if(s.removed)return s.to={},!0;let a=i.getNodeAtStart(s.id);if(a&&this.enableAddRemoveOptimizations)for(let[l,g]of Object.entries(s.to))it(a[l],g)&&delete s.to[l];if(s.added||Object.keys(s.to).length>0)return!0;let c=s.toChildren;if(!c)return!1;if(!a)return!0;i.beginAllowPartialScopeAccess();let d=a.children;if(i.endAllowPartialScopeAccess(),!d||!this.enableAddRemoveOptimizations)return!0;let p=d.length;if(p!==c.length)return!0;for(let l=0;l<p;l++)if(d[l].id!==c[l])return!0;return!1})}getEditReasons(t,e){let r=[],n="";for(let i=t+1;i<=e;i++){let s=this.entries[i-this.trimmed].editReasons;for(let a of s)a&&n!==a&&(n=a,r.push(a))}return r.join(" ")}getChangesBetweenEntries(t,e){h(t<e,"inconsistency in getting local changes to send");let r=this.computeForwardChanges(t,e),n=this.getEditReasons(t,e);return{count:e-t,changes:r,reasons:n}}debugOverwriteCurrentTree(t){pt.debug("recover with tree:",t.root.id),this.tree=t,this.getLastEntry().tree=t}resetTreesForRecovery(t,e){pt.info("reset trees for recovery, remote:",this.remoteTreeIndex,"local:",this.localTreeIndex,"changes already sent:",e);let r=this.entries[t]?.tree;h(r,"unable to get remote tree");let n=r.getService("loader"),i=r.lineage.editHooks,s=[];try{r=mn(JSON.parse(JSON.stringify(r.toJS())),s)}catch(c){if(c instanceof RangeError&&c.message.includes("Invalid string length"))pt.warn("[recovery] Tree too large for JSON serialization, using original tree",{error:c.message,treeSize:r.size()}),s.push("Recovery skipped: tree too large for serialization");else throw c}n&&(n.resetTreeForRecovery(r),h(r.getService("loader")===n,"tree must have the same loader")),i&&(r.lineage.editHooks=i),s.length>0&&pt.warn("[recovery] encountered errors while reloading the tree:",s),this.entries[t].tree=r,this.entries.length=t+e+1;let a=r;for(let c=t+1;c<this.entries.length;c++){let d=this.entries[c];Ne(r,d.changes),r=r.commitDiffs(),d.tree=r,r!==a&&(a.releaseMemory(),a=r)}return this.inErrorRecovery=!0,this.tree=r,r}saveTimelineDataForRecovery(){if(window.localStorage)try{let t=`debugTimelineAtRecovery-${Math.floor(Math.random()*100)}`,e={date:new Date().toString(),entries:this.entries.map(r=>r.toDebugData())};window.localStorage.setItem(t,JSON.stringify(e))}catch(t){pt.warn("failed to store timeline in localStorage:",t)}}};var Zc={cache:!0,mutable:!0,update:!0,parentid:!0,originalid:!0,duplicatedFrom:!0,moduleSourceRevision:!0,moduleSourceRevisionHint:!0,moduleSourceRevisionCommittedHint:!0,kitSectionsStructure:!0,kitSectionHash:!0,kitSectionSource:!0,customizations:!0,customizationsDescription:!0,customizationsSectionId:!0,customizationsCategory:!0,customizationsRules:!0,isApplyingCustomizations:!0,layoutTemplateIdentifierOverride:!0};function Oe(o,t){if(!O(t)&&!Zc[o]&&!o.startsWith("export")&&!Ai(o))return t}function ed(o,t){if(o!=="children")return Oe(o,t)}function td(o,t,e,r,n){if(!yi(o)||!to(t))return t;if(t.type==="slot")return!eo(t.value)||at(e)&&e.slotsAreChildNodes?t:t.value.map(i=>{let s=n.get(i.reference);return sn(r,s)?s:void 0});if(t.type==="componentinstance"){if(!we(t.value))return t;let i=n.get(t.value);return sn(r,i)?i:void 0}else if(t.type==="array"){if(!eo(t.value))return t;let i=[],s=!1;for(let a of t.value){if(!to(a)||a.type!=="componentinstance"||(s=!0,!we(a.value)))continue;let c=n.get(a.value);sn(r,c)&&i.push(c)}return s?i:t}return t}function rd(o,t){return(e,r,n)=>Oe(e,td(e,r,n,t,o))}var Nr=D("ModuleSourceRevision");function qp(o){return Ee(ae(o,Oe))}function Wp(o,t,e){let r=Ee(ae(t,Oe));for(let n of e){let i=o.get(Bi(n.id,t.id));i&&(r+=Ee(ae(i,Oe)))}return r}function nd(o,t){switch(o.__class){case"CollectionItemNode":case"ImageStylePresetNode":case"InlineCodeStylePresetNode":case"LayoutTemplateNode":case"LinkStylePresetNode":case"SmartComponentNode":case"TableStylePresetNode":case"WebPageNode":return Ee(ae(o,Oe));case"FrameNode":{let e=t.get(o.parentid);return!e||!X(e)?void 0:Ee(ae(o,rd(t,e.id)))}case"CollectionNode":{h(G(o),"Expected collection node");let e=ae(t.root.locales),r=ae(o,ed),n=ae(o.getUnsortedChildren()?.map(i=>i.moduleSourceRevision));return Ee(e+r+n)}case"PresetsListNode":{let e=o.children?.filter(r=>!ve(r,t))??[];return Ee(ae(e,Oe))}case"TextStylePresetNode":case"BlockquoteStylePresetNode":{if(st(o))return o.moduleSourceRevision;let e=ae(o,Oe);return o.cache.replicaInstances?.forEach(r=>{let n=t.getNodeWithTrait(r,st);n&&(e+=ae(n,Oe))}),Ee(e)}case"VectorSetNode":{h(Q(o),"Expected VectorSetNode");let e=o.getVectorSetItems().map(r=>{let n=Ve("vector",r.id,"default").localId,i=t.getNodeWithTrait(n,Yi);return i?i.save.moduleId:""});return Ee(ae(e)+o.name)}case"ShapeContainerNode":{if(!ue(o))return;let e=t.getScopeNodeFor(o);if(!Q(e))return;let r=ae(o,Oe);return Ee(r+ae(e.variables))}case"CanvasPageNode":case"RootNode":return;case"ComponentPresetNode":return;case"AnalyticsScopeNode":case"BlockquoteEntityTypeRootNode":case"BooleanShapeNode":case"BoxShadow":case"CanvasNode":case"CanvasScopeNode":case"CustomCodeScopeNode":case"CustomCodeNode":case"DesignPageNode":case"ChatTool":case"CMSEntityTypeRootNode":case"CodeComponentNode":case"CodeFileEntityTypeRootNode":case"CollectionReferenceVariableEditTool":case"Color":case"ColorEntityTypeRootNode":case"ColorStyleTokenListNode":case"ColorStyleTokenNode":case"ComponentEntityTypeRootNode":case"ConicGradient":case"ContentManagementNode":case"CreateCodeComponentBaseTool":case"CreateFrameBaseTool":case"CreateShapeBaseTool":case"CreateTextTool":case"EntityFolderNode":case"EntityReferenceNode":case"EntityRootNode":case"ErrorListNode":case"ErrorNode":case"ExportOptions":case"ExternalModuleNode":case"ExternalModulesListNode":case"FeedbackTool":case"FormBooleanInputNode":case"FormPlainTextInputNode":case"FormSelectNode":case"FunnelNode":case"FunnelStepActionNode":case"FunnelStepNode":case"GapTool":case"GradientColorStop":case"GradientToolManagerTool":case"GuideMoveTool":case"HeaderRouteNode":case"HighlightStackItemTool":case"HighlightTool":case"InitialTool":case"InlineCodeEntityTypeRootNode":case"LayoutTemplateEntityTypeRootNode":case"LineAnchorMoveTool":case"LinearGradient":case"LinkEntityTypeRootNode":case"LinkTool":case"LoadingShieldTool":case"LocalizationGlossaryItemNode":case"LocalizationGlossaryNode":case"LocalModuleNode":case"LocalModulesListNode":case"Menu":case"MoveTool":case"MutableNode":case"OvalShapeNode":case"OverlayNode":case"PaddingTool":case"PageLinkTool":case"PanTool":case"PathCurveBendTool":case"PathDefaultTool":case"PathNode":case"PathSegment":case"PathSegmentAdditionTool":case"PathSegmentHandleMoveTool":case"PathSegmentMoveTool":case"PathSegmentSelectTool":case"PolygonShapeNode":case"PreviewSettings":case"ProxyRouteNode":case"RadialGradient":case"RadiusTool":case"RecoveryTool":case"RectangleShapeNode":case"RedirectRouteNode":case"ResizeTool":case"RewriteRouteNode":case"RichTextEditTool":case"RichTextNode":case"RichTextVariableEditTool":case"RotateTool":case"RouteNode":case"RouteLocaleNode":case"RouteSegmentNode":case"RouteSegmentRootNode":case"RoutesNode":case"SampleColorTool":case"ScaleTool":case"ScopeNode":case"SelectTool":case"Shadow":case"ShapeGroupNode":case"SlotConnectTool":case"SlotNode":case"SlotPropertyNode":case"StarShapeNode":case"StringVariableEditTool":case"DateVariableEditTool":case"EnumVariableEditTool":case"StyledTextDraft":case"SVGNode":case"TestTool":case"TextEditTool":case"TextEntityTypeRootNode":case"TextNode":case"VectorSetEntityTypeRootNode":case"VekterGradientTool":case"VekterPathEngine":case"VekterTool":case"ViewportResizeTool":case"ZoomSelectTool":case"ZoomTool":return;default:ye(o.__class,"getModuleRevision: node.__class must be a valid value")}}function ko(o,t){let e=o.get(t);return!e||!ve(e,o)?!1:O(e.moduleSourceRevisionHint)||e.moduleSourceRevisionCommittedHint===e.moduleSourceRevisionHint?(Nr.debug(`Hint hasn't changed for ${e.id}.`),!1):(Nr.debug(`Initial Revision: ${e.moduleSourceRevision}`),!0)}function Do(o,t){let e=o.get(t);if(!e||!ve(e,o))return;let r=performance.now(),n=nd(e,o);Nr.debug(`Spent ${performance.now()-r}ms computing module revision for ${e.id}`);let i=B(n)&&n!==e.moduleSourceRevision;Nr.debug(`Revisions: ${e.moduleSourceRevision}, ${n}`);let s=e.moduleSourceRevisionHint,a=i?{moduleSourceRevision:n,moduleSourceRevisionCommittedHint:s}:{moduleSourceRevisionCommittedHint:s};return Nr.debug(i?`Updating moduleSourceRevision for ${e.id}.`:`Updating moduleSourceRevisionCommittedHint for ${e.id}.`),e.setIgnoringReplica(a,o),i?n:void 0}function Fa(o,t){return t(e=>{if(e.isViewOnly)return;let r=e.get(o);return G(r)&&r.getUnsortedChildren()?.forEach(n=>{ko(e,n.id)&&Do(e,n.id)}),Do(e,o)})}function Ua(o,t){return t(e=>{if(!e.isViewOnly)return o.reduce((r,n)=>(r[n.id]=Do(e,n.id)??1,r),{})})}function Aa(o){window.addEventListener("beforeunload",t=>{o()&&(t.preventDefault(),t.returnValue="You have unsaved changes. They might be lost if you leave the page.")})}var od=D("CodeGenerationStore"),id="transform",Kt,Et,Pn=class{constructor(t){this.sourceNode=t;ne(this,Kt,[]);ne(this,Et)}start(t){let e=performance.now();return{end:r=>{b(this,Kt).push([t,performance.now()-e]),Ge(this,Et,b(this,Et)??r),t===id&&this.completeSession()}}}restartSession(){Ge(this,Kt,[]),Ge(this,Et,void 0)}completeSession(){b(this,Et)?.forEach(({type:t,source:e,artifacts:r})=>{let n=sd(t,this.sourceNode);if(!n)return;let i={codeType:n,durationMs:0,updateCount:0,updateDurationMs:0,serializationDurationMs:0,compilationDurationMs:0,synchronizationDurationMs:0,size:e.length,id:this.sourceNode.id,nodes:r?.metrics?.nodes??1,variants:r?.metrics?.variants??0,svgBytes:r?.metrics?.svgBytes,textBytes:r?.metrics?.textBytes};for(let[a,c]of b(this,Kt))switch(i.durationMs+=c,a){case"update":i.updateCount++,i.updateDurationMs+=c;break;case"serialize":i.serializationDurationMs+=c;break;case"transform":i.compilationDurationMs+=c;break;case"synchronize":i.synchronizationDurationMs+=c;break;default:ye(a)}let s;for(s in i){let a=i[s];B(a)&&(i[s]=Math.round(a))}od.trace("Code Generation Metrics",i),Xe("code_generation",i)}),this.restartSession()}};Kt=new WeakMap,Et=new WeakMap;function sd(o,t){switch(o){case"canvasComponent":return"smart_component";case"css":return"styles_preset";case"collection":return"collection";case"draftCollection":return"draft_collection";case"componentPresets":return"component_presets";case"screen":return L(t)?"web_page":"prototype_screen";case"prototype":return"prototype";case"vector":return"vector";case"vectorSet":return"vector_set";case"codeFile":case"config":case"siteMetadata":case"webPageMetadata":case"layoutTemplate":case"localization":case"design":case"kit":return;default:ye(o)}}function ad(o,t){let e={};if(!t||bi(o))return e;for(let r of o.cases)for(let n of t){let i=r.nameLocalized;if(!i)continue;let s=i[n.id]?.value;if(!we(s))continue;let a=e[r.id]??{};e[r.id]=a,a[n.id]=s}return e}function Ba(o,t,e){if(o.cases.length===0)return f`(value) => value`;let r=ad(o,t),n=f`value`,i=f`locale`,s=f`fallbackLocale`;return new w(M.lines(f`(${n}, ${i}) => {`,f`const ${s} = ${i}?.fallback;`,f`switch (${n}) {`,...o.cases.map(({id:a,name:c})=>{let d=r[a];return d?new w(M.lines(f`case ${a}:`,f`switch (${i}?.id) {`,...Object.entries(d).map(([p,l])=>f`case ${p}: return ${l};`),f`default:`,f`if (${s}) return ${w.fn(e,n,s)};`,f`return ${c};`,f`}`)):f`case ${a}: return ${c};`}),f`default: return "";`,f`}`,f`}`))}var Eo="framercms";function Oa(o,t,e){return`${o}-${t}.${e}`}var Ln=class{constructor(t){this.componentSourceNodeId=t;u(this,"assets",{})}create(t,e,r){let n=Oa(this.componentSourceNodeId,t,e);return this.assets[n]=r,f`new URL(${`./${n}`}, import.meta.url).href`}};var za=Tt(Zn());function _(o,...t){if(!o)throw Error("Assertion Error"+(t.length>0?": "+t.join(" "):""))}function Rr(o){throw new Error(`Unexpected value: ${o}`)}var cd=Tt(Hr());var _a=`// src/code-generation/components/cms/bundled/getRichTextJsonResolver.tsx?bundle
import { ComponentPresetsConsumer, Link, motion } from "framer";

// ../../library/src/router/lazy.tsx
import { forwardRef, isValidElement, useEffect } from "react";
var preloadKey = "preload";
function isLazyComponentType(componentType) {
  return typeof componentType === "object" && componentType !== null && !isValidElement(componentType) && preloadKey in componentType;
}

// src/code-generation/components/cms/bundled/getRichTextJsonResolver.tsx?bundle
import { Fragment, createElement } from "react";

// src/code-generation/components/cms/bundled/assert.ts
function assert(condition, ...msg) {
  if (condition) return;
  throw Error("Assertion Error" + (msg.length > 0 ? ": " + msg.join(" ") : ""));
}

// src/code-generation/components/cms/bundled/getRichTextJsonResolver.tsx?bundle
var RichTextJsonType = /* @__PURE__ */ ((RichTextJsonType2) => {
  RichTextJsonType2[RichTextJsonType2["Fragment"] = 1] = "Fragment";
  RichTextJsonType2[RichTextJsonType2["Link"] = 2] = "Link";
  RichTextJsonType2[RichTextJsonType2["Module"] = 3] = "Module";
  RichTextJsonType2[RichTextJsonType2["Tag"] = 4] = "Tag";
  RichTextJsonType2[RichTextJsonType2["Text"] = 5] = "Text";
  return RichTextJsonType2;
})(RichTextJsonType || {});
function getRichTextJsonResolver(components) {
  const cache = /* @__PURE__ */ new Map();
  function deserializeChildren(children) {
    return children.map(deserializeNode);
  }
  function deserializeNode(node) {
    switch (node[0]) {
      case 1 /* Fragment */: {
        const [, ...children] = node;
        const childNodes = deserializeChildren(children);
        return createElement(Fragment, void 0, ...childNodes);
      }
      case 2 /* Link */: {
        const [, props, ...children] = node;
        const childNodes = deserializeChildren(children);
        return createElement(Link, props, ...childNodes);
      }
      case 3 /* Module */: {
        const [, identifier, props] = node;
        const Component = components[identifier];
        assert(Component, "Module not found");
        if (isLazyComponentType(Component)) {
          void Component.preload();
        }
        return <ComponentPresetsConsumer componentIdentifier={identifier}>
                        {(presetProps) => <Component {...presetProps} {...props} />}
                    </ComponentPresetsConsumer>;
      }
      case 4 /* Tag */: {
        const [, tag, props, ...children] = node;
        const childNodes = deserializeChildren(children);
        if (tag === "a") {
          return createElement(motion.a, props, ...childNodes);
        }
        return createElement(tag, props, ...childNodes);
      }
      case 5 /* Text */: {
        const [, text] = node;
        return text;
      }
    }
  }
  return (pointer) => {
    const cached = cache.get(pointer);
    if (cached) return cached;
    const json = JSON.parse(pointer);
    const result = deserializeNode(json);
    cache.set(pointer, result);
    return result;
  };
}
export {
  RichTextJsonType,
  getRichTextJsonResolver
};
`;var Mn=class{constructor(t,e,r,n,i,s,a,c){this.collectionNode=t;this.treeStore=e;this.imports=r;this.submodules=n;this.bindings=i;this.declarations=s;this.assets=a;this.links=c;u(this,"scopeNode");u(this,"cache",new Map);u(this,"components",{});u(this,"resolvers");u(this,"serializers",{fragment:t=>[1,...t],link:(t,e)=>[2,t,...e],module:(t,e)=>{if(this.addModuleImport(t))return[3,t,e]},tag:(t,e,r)=>[4,t,e,...r],text:t=>[5,t]});u(this,"resolveRichTextBinding");this.resolveRichTextBinding=this.bindings.create("resolveRichText"),this.scopeNode=this.treeStore.tree.getScopeNodeFor(this.collectionNode),this.resolvers=Os(this.assets,this.links,void 0,void 0)}addModuleImport(t){if(t in this.components)return!0;let e=nt(t),r=this.imports.addModuleImport(e,{lazy:!0});return r?(this.components[t]=r,!0):!1}add(t){let e=this.cache.get(t);if(e)return e;let r=Bs(t,this.resolvers,this.serializers,{definitionProvider:de,tree:this.treeStore.tree,nodeId:this.collectionNode.id,scopeId:this.scopeNode?.id}),n=JSON.stringify(r);return this.cache.set(t,n),n}serialize(){let t=this.imports.addImport(this.submodules.create(_a).submoduleImport,{exportSpecifier:"getRichTextJsonResolver"}),e=this.declarations.dedupe("richTextComponents",this.components);this.declarations.create(f`const ${this.resolveRichTextBinding} = ${w.fn(t,e)}`)}};var Vn=class{constructor(){u(this,"values",new Map)}add(t){let e=this.values.get(t);if(B(e))return e;let r=this.values.size;return this.values.set(t,r),r}serialize(t,e){let r=[];for(let[i,s]of this.values){let a=nt(i),{importSpecifier:c}=Qi(a,"collection",t);h(c,"Import specifier must be defined"),r[s]=f`() => import(${c})`}let n=e.dedupe("vectors",r);return e.dedupe("resolveVectorSetItem",f`(pointer: number) => {${f.joinLines(f`const vector = ${n}[pointer]`,f`if (vector) return vector().then(v => v.default)`)}}`)}};var q={Uint8:1,Uint16:2,Uint32:4,BigUint64:8,Int8:1,Int16:2,Int32:4,BigInt64:8,Float32:4,Float64:8},Fn=class{constructor(t){this.bytes=t;u(this,"offset",0);u(this,"view");u(this,"decoder",new TextDecoder);this.view=Qt(this.bytes)}getOffset(){return this.offset}ensureLength(t){let e=this.bytes.length;if(!(this.offset+t<=e))throw new Error("Reading out of bounds")}readUint8(){let t=q.Uint8;this.ensureLength(t);let e=this.view.getUint8(this.offset);return this.offset+=t,e}readUint16(){let t=q.Uint16;this.ensureLength(t);let e=this.view.getUint16(this.offset);return this.offset+=t,e}readUint32(){let t=q.Uint32;this.ensureLength(t);let e=this.view.getUint32(this.offset);return this.offset+=t,e}readUint64(){let t=this.readBigUint64();return Number(t)}readBigUint64(){let t=q.BigUint64;this.ensureLength(t);let e=this.view.getBigUint64(this.offset);return this.offset+=t,e}readInt8(){let t=q.Int8;this.ensureLength(t);let e=this.view.getInt8(this.offset);return this.offset+=t,e}readInt16(){let t=q.Int16;this.ensureLength(t);let e=this.view.getInt16(this.offset);return this.offset+=t,e}readInt32(){let t=q.Int32;this.ensureLength(t);let e=this.view.getInt32(this.offset);return this.offset+=t,e}readInt64(){let t=this.readBigInt64();return Number(t)}readBigInt64(){let t=q.BigInt64;this.ensureLength(t);let e=this.view.getBigInt64(this.offset);return this.offset+=t,e}readFloat32(){let t=q.Float32;this.ensureLength(t);let e=this.view.getFloat32(this.offset);return this.offset+=t,e}readFloat64(){let t=q.Float64;this.ensureLength(t);let e=this.view.getFloat64(this.offset);return this.offset+=t,e}readBytes(t){let e=this.offset,r=e+t,n=this.bytes.subarray(e,r);return this.offset=r,n}readString(){let t=this.readUint32(),e=this.readBytes(t);return this.decoder.decode(e)}readJson(){let t=this.readString();return JSON.parse(t)}};function Qt(o){return new DataView(o.buffer,o.byteOffset,o.byteLength)}var dd=1024,ld=1.5,Po=o=>2**o-1,Lo=o=>-(2**(o-1)),Mo=o=>2**(o-1)-1,ze={Uint8:0,Uint16:0,Uint32:0,Uint64:0,BigUint64:0,Int8:Lo(8),Int16:Lo(16),Int32:Lo(32),Int64:Number.MIN_SAFE_INTEGER,BigInt64:-(BigInt(2)**BigInt(63))},_e={Uint8:Po(8),Uint16:Po(16),Uint32:Po(32),Uint64:Number.MAX_SAFE_INTEGER,BigUint64:BigInt(2)**BigInt(64)-BigInt(1),Int8:Mo(8),Int16:Mo(16),Int32:Mo(32),Int64:Number.MAX_SAFE_INTEGER,BigInt64:BigInt(2)**BigInt(63)-BigInt(1)};function $e(o,t,e,r){_(o>=t,o,"outside lower bound for",r),_(o<=e,o,"outside upper bound for",r)}var Pt=class{constructor(){u(this,"offset",0);u(this,"bytes",new Uint8Array(dd));u(this,"view",Qt(this.bytes));u(this,"encoder",new TextEncoder);u(this,"encodedStrings",new Map)}getOffset(){return this.offset}slice(t=0,e=this.offset){return this.bytes.slice(t,e)}subarray(t=0,e=this.offset){return this.bytes.subarray(t,e)}ensureLength(t){let e=this.bytes.length;if(this.offset+t<=e)return;let r=Math.ceil(e*ld)+t,n=new Uint8Array(r);n.set(this.bytes),this.bytes=n,this.view=Qt(n)}writeUint8(t){$e(t,ze.Uint8,_e.Uint8,"Uint8");let e=q.Uint8;this.ensureLength(e),this.view.setUint8(this.offset,t),this.offset+=e}writeUint16(t){$e(t,ze.Uint16,_e.Uint16,"Uint16");let e=q.Uint16;this.ensureLength(e),this.view.setUint16(this.offset,t),this.offset+=e}writeUint32(t){$e(t,ze.Uint32,_e.Uint32,"Uint32");let e=q.Uint32;this.ensureLength(e),this.view.setUint32(this.offset,t),this.offset+=e}writeUint64(t){$e(t,ze.Uint64,_e.Uint64,"Uint64");let e=BigInt(t);this.writeBigUint64(e)}writeBigUint64(t){$e(t,ze.BigUint64,_e.BigUint64,"BigUint64");let e=q.BigUint64;this.ensureLength(e),this.view.setBigUint64(this.offset,t),this.offset+=e}writeInt8(t){$e(t,ze.Int8,_e.Int8,"Int8");let e=q.Int8;this.ensureLength(e),this.view.setInt8(this.offset,t),this.offset+=e}writeInt16(t){$e(t,ze.Int16,_e.Int16,"Int16");let e=q.Int16;this.ensureLength(e),this.view.setInt16(this.offset,t),this.offset+=e}writeInt32(t){$e(t,ze.Int32,_e.Int32,"Int32");let e=q.Int32;this.ensureLength(e),this.view.setInt32(this.offset,t),this.offset+=e}writeInt64(t){$e(t,ze.Int64,_e.Int64,"Int64");let e=BigInt(t);this.writeBigInt64(e)}writeBigInt64(t){$e(t,ze.BigInt64,_e.BigInt64,"BigInt64");let e=q.BigInt64;this.ensureLength(e),this.view.setBigInt64(this.offset,t),this.offset+=e}writeFloat32(t){let e=q.Float32;this.ensureLength(e),this.view.setFloat32(this.offset,t),this.offset+=e}writeFloat64(t){let e=q.Float64;this.ensureLength(e),this.view.setFloat64(this.offset,t),this.offset+=e}writeBytes(t){let e=t.length;this.ensureLength(e),this.bytes.set(t,this.offset),this.offset+=e}encodeString(t){let e=this.encodedStrings.get(t);if(e)return e;let r=this.encoder.encode(t);return this.encodedStrings.set(t,r),r}writeString(t){let e=this.encodeString(t),r=e.length;this.writeUint32(r),this.writeBytes(e)}writeJson(t){let e=JSON.stringify(t);this.writeString(e)}};var $a=`var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// ../../../node_modules/dataloader/index.js
var require_dataloader = __commonJS({
  "../../../node_modules/dataloader/index.js"(exports, module) {
    "use strict";
    var DataLoader2 = /* @__PURE__ */ function() {
      function DataLoader3(batchLoadFn, options) {
        if (typeof batchLoadFn !== "function") {
          throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
        }
        this._batchLoadFn = batchLoadFn;
        this._maxBatchSize = getValidMaxBatchSize(options);
        this._batchScheduleFn = getValidBatchScheduleFn(options);
        this._cacheKeyFn = getValidCacheKeyFn(options);
        this._cacheMap = getValidCacheMap(options);
        this._batch = null;
        this.name = getValidName(options);
      }
      var _proto = DataLoader3.prototype;
      _proto.load = function load(key) {
        if (key === null || key === void 0) {
          throw new TypeError("The loader.load() function must be called with a value, " + ("but got: " + String(key) + "."));
        }
        var batch = getCurrentBatch(this);
        var cacheMap = this._cacheMap;
        var cacheKey = this._cacheKeyFn(key);
        if (cacheMap) {
          var cachedPromise = cacheMap.get(cacheKey);
          if (cachedPromise) {
            var cacheHits = batch.cacheHits || (batch.cacheHits = []);
            return new Promise(function(resolve) {
              cacheHits.push(function() {
                resolve(cachedPromise);
              });
            });
          }
        }
        batch.keys.push(key);
        var promise = new Promise(function(resolve, reject) {
          batch.callbacks.push({
            resolve,
            reject
          });
        });
        if (cacheMap) {
          cacheMap.set(cacheKey, promise);
        }
        return promise;
      };
      _proto.loadMany = function loadMany(keys) {
        if (!isArrayLike(keys)) {
          throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + keys + "."));
        }
        var loadPromises = [];
        for (var i = 0; i < keys.length; i++) {
          loadPromises.push(this.load(keys[i])["catch"](function(error) {
            return error;
          }));
        }
        return Promise.all(loadPromises);
      };
      _proto.clear = function clear(key) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          var cacheKey = this._cacheKeyFn(key);
          cacheMap["delete"](cacheKey);
        }
        return this;
      };
      _proto.clearAll = function clearAll() {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          cacheMap.clear();
        }
        return this;
      };
      _proto.prime = function prime(key, value) {
        var cacheMap = this._cacheMap;
        if (cacheMap) {
          var cacheKey = this._cacheKeyFn(key);
          if (cacheMap.get(cacheKey) === void 0) {
            var promise;
            if (value instanceof Error) {
              promise = Promise.reject(value);
              promise["catch"](function() {
              });
            } else {
              promise = Promise.resolve(value);
            }
            cacheMap.set(cacheKey, promise);
          }
        }
        return this;
      };
      return DataLoader3;
    }();
    var enqueuePostPromiseJob = typeof process === "object" && typeof process.nextTick === "function" ? function(fn) {
      if (!resolvedPromise) {
        resolvedPromise = Promise.resolve();
      }
      resolvedPromise.then(function() {
        process.nextTick(fn);
      });
    } : typeof setImmediate === "function" ? function(fn) {
      setImmediate(fn);
    } : function(fn) {
      setTimeout(fn);
    };
    var resolvedPromise;
    function getCurrentBatch(loader) {
      var existingBatch = loader._batch;
      if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {
        return existingBatch;
      }
      var newBatch = {
        hasDispatched: false,
        keys: [],
        callbacks: []
      };
      loader._batch = newBatch;
      loader._batchScheduleFn(function() {
        dispatchBatch(loader, newBatch);
      });
      return newBatch;
    }
    function dispatchBatch(loader, batch) {
      batch.hasDispatched = true;
      if (batch.keys.length === 0) {
        resolveCacheHits(batch);
        return;
      }
      var batchPromise;
      try {
        batchPromise = loader._batchLoadFn(batch.keys);
      } catch (e) {
        return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function " + ("errored synchronously: " + String(e) + ".")));
      }
      if (!batchPromise || typeof batchPromise.then !== "function") {
        return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(batchPromise) + ".")));
      }
      batchPromise.then(function(values) {
        if (!isArrayLike(values)) {
          throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(values) + "."));
        }
        if (values.length !== batch.keys.length) {
          throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + ("\\n\\nKeys:\\n" + String(batch.keys)) + ("\\n\\nValues:\\n" + String(values)));
        }
        resolveCacheHits(batch);
        for (var i = 0; i < batch.callbacks.length; i++) {
          var value = values[i];
          if (value instanceof Error) {
            batch.callbacks[i].reject(value);
          } else {
            batch.callbacks[i].resolve(value);
          }
        }
      })["catch"](function(error) {
        failedDispatch(loader, batch, error);
      });
    }
    function failedDispatch(loader, batch, error) {
      resolveCacheHits(batch);
      for (var i = 0; i < batch.keys.length; i++) {
        loader.clear(batch.keys[i]);
        batch.callbacks[i].reject(error);
      }
    }
    function resolveCacheHits(batch) {
      if (batch.cacheHits) {
        for (var i = 0; i < batch.cacheHits.length; i++) {
          batch.cacheHits[i]();
        }
      }
    }
    function getValidMaxBatchSize(options) {
      var shouldBatch = !options || options.batch !== false;
      if (!shouldBatch) {
        return 1;
      }
      var maxBatchSize = options && options.maxBatchSize;
      if (maxBatchSize === void 0) {
        return Infinity;
      }
      if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
        throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
      }
      return maxBatchSize;
    }
    function getValidBatchScheduleFn(options) {
      var batchScheduleFn = options && options.batchScheduleFn;
      if (batchScheduleFn === void 0) {
        return enqueuePostPromiseJob;
      }
      if (typeof batchScheduleFn !== "function") {
        throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
      }
      return batchScheduleFn;
    }
    function getValidCacheKeyFn(options) {
      var cacheKeyFn = options && options.cacheKeyFn;
      if (cacheKeyFn === void 0) {
        return function(key) {
          return key;
        };
      }
      if (typeof cacheKeyFn !== "function") {
        throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
      }
      return cacheKeyFn;
    }
    function getValidCacheMap(options) {
      var shouldCache = !options || options.cache !== false;
      if (!shouldCache) {
        return null;
      }
      var cacheMap = options && options.cacheMap;
      if (cacheMap === void 0) {
        return /* @__PURE__ */ new Map();
      }
      if (cacheMap !== null) {
        var cacheFunctions = ["get", "set", "delete", "clear"];
        var missingFunctions = cacheFunctions.filter(function(fnName) {
          return cacheMap && typeof cacheMap[fnName] !== "function";
        });
        if (missingFunctions.length !== 0) {
          throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
        }
      }
      return cacheMap;
    }
    function getValidName(options) {
      if (options && options.name) {
        return options.name;
      }
      return null;
    }
    function isArrayLike(x) {
      return typeof x === "object" && x !== null && typeof x.length === "number" && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));
    }
    module.exports = DataLoader2;
  }
});

// src/code-generation/components/cms/bundled/DatabaseCollection.ts?bundle
var import_dataloader = __toESM(require_dataloader());

// src/code-generation/components/cms/bundled/BufferReader.ts
var BYTE_LENGTH = {
  Uint8: 1,
  Uint16: 2,
  Uint32: 4,
  BigUint64: 8,
  Int8: 1,
  Int16: 2,
  Int32: 4,
  BigInt64: 8,
  Float32: 4,
  Float64: 8
};
var BufferReader = class {
  constructor(bytes) {
    this.bytes = bytes;
    __publicField(this, "offset", 0);
    __publicField(this, "view");
    __publicField(this, "decoder", new TextDecoder());
    this.view = getDataView(this.bytes);
  }
  getOffset() {
    return this.offset;
  }
  ensureLength(requiredBytes) {
    const oldLength = this.bytes.length;
    if (this.offset + requiredBytes <= oldLength) return;
    throw new Error("Reading out of bounds");
  }
  readUint8() {
    const size = BYTE_LENGTH.Uint8;
    this.ensureLength(size);
    const value = this.view.getUint8(this.offset);
    this.offset += size;
    return value;
  }
  readUint16() {
    const size = BYTE_LENGTH.Uint16;
    this.ensureLength(size);
    const value = this.view.getUint16(this.offset);
    this.offset += size;
    return value;
  }
  readUint32() {
    const size = BYTE_LENGTH.Uint32;
    this.ensureLength(size);
    const value = this.view.getUint32(this.offset);
    this.offset += size;
    return value;
  }
  readUint64() {
    const bigint = this.readBigUint64();
    return Number(bigint);
  }
  readBigUint64() {
    const size = BYTE_LENGTH.BigUint64;
    this.ensureLength(size);
    const value = this.view.getBigUint64(this.offset);
    this.offset += size;
    return value;
  }
  readInt8() {
    const size = BYTE_LENGTH.Int8;
    this.ensureLength(size);
    const value = this.view.getInt8(this.offset);
    this.offset += size;
    return value;
  }
  readInt16() {
    const size = BYTE_LENGTH.Int16;
    this.ensureLength(size);
    const value = this.view.getInt16(this.offset);
    this.offset += size;
    return value;
  }
  readInt32() {
    const size = BYTE_LENGTH.Int32;
    this.ensureLength(size);
    const value = this.view.getInt32(this.offset);
    this.offset += size;
    return value;
  }
  readInt64() {
    const bigint = this.readBigInt64();
    return Number(bigint);
  }
  readBigInt64() {
    const size = BYTE_LENGTH.BigInt64;
    this.ensureLength(size);
    const value = this.view.getBigInt64(this.offset);
    this.offset += size;
    return value;
  }
  readFloat32() {
    const size = BYTE_LENGTH.Float32;
    this.ensureLength(size);
    const value = this.view.getFloat32(this.offset);
    this.offset += size;
    return value;
  }
  readFloat64() {
    const size = BYTE_LENGTH.Float64;
    this.ensureLength(size);
    const value = this.view.getFloat64(this.offset);
    this.offset += size;
    return value;
  }
  readBytes(length) {
    const start = this.offset;
    const end = start + length;
    const value = this.bytes.subarray(start, end);
    this.offset = end;
    return value;
  }
  readString() {
    const length = this.readUint32();
    const bytes = this.readBytes(length);
    return this.decoder.decode(bytes);
  }
  readJson() {
    const string = this.readString();
    return JSON.parse(string);
  }
};
function getDataView(bytes) {
  return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
}

// src/code-generation/components/cms/bundled/DatabaseDictionaryIndex.ts
import { ControlType as ControlType2 } from "framer";

// ../../library/src/utils/utils.ts
var isWindow = typeof window !== "undefined";
var supportsRequestIdleCallback = isWindow && typeof window.requestIdleCallback === "function";

// src/code-generation/components/cms/bundled/assert.ts
function assert(condition, ...msg) {
  if (condition) return;
  throw Error("Assertion Error" + (msg.length > 0 ? ": " + msg.join(" ") : ""));
}
function assertNever(condition) {
  throw new Error(\`Unexpected value: \${condition}\`);
}

// src/code-generation/components/cms/bundled/BufferWriter.ts
var INITIAL_BUFFER_SIZE = 1024;
var GROWTH_FACTOR = 1.5;
var maxUnsignedNumber = (bits) => 2 ** bits - 1;
var minSignedNumber = (bits) => -(2 ** (bits - 1));
var maxSignedNumber = (bits) => 2 ** (bits - 1) - 1;
var MIN_VALUE = {
  Uint8: 0,
  Uint16: 0,
  Uint32: 0,
  Uint64: 0,
  BigUint64: 0,
  Int8: minSignedNumber(8),
  Int16: minSignedNumber(16),
  Int32: minSignedNumber(32),
  Int64: Number.MIN_SAFE_INTEGER,
  BigInt64: -(BigInt(2) ** BigInt(63))
};
var MAX_VALUE = {
  Uint8: maxUnsignedNumber(8),
  Uint16: maxUnsignedNumber(16),
  Uint32: maxUnsignedNumber(32),
  Uint64: Number.MAX_SAFE_INTEGER,
  BigUint64: BigInt(2) ** BigInt(64) - BigInt(1),
  Int8: maxSignedNumber(8),
  Int16: maxSignedNumber(16),
  Int32: maxSignedNumber(32),
  Int64: Number.MAX_SAFE_INTEGER,
  BigInt64: BigInt(2) ** BigInt(63) - BigInt(1)
};
function assertRange(value, min, max, dataType) {
  assert(value >= min, value, "outside lower bound for", dataType);
  assert(value <= max, value, "outside upper bound for", dataType);
}
var BufferWriter = class {
  constructor() {
    __publicField(this, "offset", 0);
    __publicField(this, "bytes", new Uint8Array(INITIAL_BUFFER_SIZE));
    __publicField(this, "view", getDataView(this.bytes));
    __publicField(this, "encoder", new TextEncoder());
    __publicField(this, "encodedStrings", /* @__PURE__ */ new Map());
  }
  getOffset() {
    return this.offset;
  }
  slice(start = 0, end = this.offset) {
    return this.bytes.slice(start, end);
  }
  subarray(start = 0, end = this.offset) {
    return this.bytes.subarray(start, end);
  }
  ensureLength(requiredBytes) {
    const oldLength = this.bytes.length;
    if (this.offset + requiredBytes <= oldLength) return;
    const newLength = Math.ceil(oldLength * GROWTH_FACTOR) + requiredBytes;
    const newBytes = new Uint8Array(newLength);
    newBytes.set(this.bytes);
    this.bytes = newBytes;
    this.view = getDataView(newBytes);
  }
  writeUint8(value) {
    assertRange(value, MIN_VALUE.Uint8, MAX_VALUE.Uint8, "Uint8");
    const size = BYTE_LENGTH.Uint8;
    this.ensureLength(size);
    this.view.setUint8(this.offset, value);
    this.offset += size;
  }
  writeUint16(value) {
    assertRange(value, MIN_VALUE.Uint16, MAX_VALUE.Uint16, "Uint16");
    const size = BYTE_LENGTH.Uint16;
    this.ensureLength(size);
    this.view.setUint16(this.offset, value);
    this.offset += size;
  }
  writeUint32(value) {
    assertRange(value, MIN_VALUE.Uint32, MAX_VALUE.Uint32, "Uint32");
    const size = BYTE_LENGTH.Uint32;
    this.ensureLength(size);
    this.view.setUint32(this.offset, value);
    this.offset += size;
  }
  writeUint64(value) {
    assertRange(value, MIN_VALUE.Uint64, MAX_VALUE.Uint64, "Uint64");
    const bigint = BigInt(value);
    this.writeBigUint64(bigint);
  }
  writeBigUint64(value) {
    assertRange(value, MIN_VALUE.BigUint64, MAX_VALUE.BigUint64, "BigUint64");
    const size = BYTE_LENGTH.BigUint64;
    this.ensureLength(size);
    this.view.setBigUint64(this.offset, value);
    this.offset += size;
  }
  writeInt8(value) {
    assertRange(value, MIN_VALUE.Int8, MAX_VALUE.Int8, "Int8");
    const size = BYTE_LENGTH.Int8;
    this.ensureLength(size);
    this.view.setInt8(this.offset, value);
    this.offset += size;
  }
  writeInt16(value) {
    assertRange(value, MIN_VALUE.Int16, MAX_VALUE.Int16, "Int16");
    const size = BYTE_LENGTH.Int16;
    this.ensureLength(size);
    this.view.setInt16(this.offset, value);
    this.offset += size;
  }
  writeInt32(value) {
    assertRange(value, MIN_VALUE.Int32, MAX_VALUE.Int32, "Int32");
    const size = BYTE_LENGTH.Int32;
    this.ensureLength(size);
    this.view.setInt32(this.offset, value);
    this.offset += size;
  }
  writeInt64(value) {
    assertRange(value, MIN_VALUE.Int64, MAX_VALUE.Int64, "Int64");
    const bigint = BigInt(value);
    this.writeBigInt64(bigint);
  }
  writeBigInt64(value) {
    assertRange(value, MIN_VALUE.BigInt64, MAX_VALUE.BigInt64, "BigInt64");
    const size = BYTE_LENGTH.BigInt64;
    this.ensureLength(size);
    this.view.setBigInt64(this.offset, value);
    this.offset += size;
  }
  writeFloat32(value) {
    const size = BYTE_LENGTH.Float32;
    this.ensureLength(size);
    this.view.setFloat32(this.offset, value);
    this.offset += size;
  }
  writeFloat64(value) {
    const size = BYTE_LENGTH.Float64;
    this.ensureLength(size);
    this.view.setFloat64(this.offset, value);
    this.offset += size;
  }
  writeBytes(value) {
    const size = value.length;
    this.ensureLength(size);
    this.bytes.set(value, this.offset);
    this.offset += size;
  }
  encodeString(value) {
    const cached = this.encodedStrings.get(value);
    if (cached) return cached;
    const bytes = this.encoder.encode(value);
    this.encodedStrings.set(value, bytes);
    return bytes;
  }
  writeString(value) {
    const bytes = this.encodeString(value);
    const size = bytes.length;
    this.writeUint32(size);
    this.writeBytes(bytes);
  }
  writeJson(value) {
    const json = JSON.stringify(value);
    this.writeString(json);
  }
};

// src/utils/typeChecks.ts
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return Number.isFinite(value);
}
function isNull(value) {
  return value === null;
}

// src/code-generation/components/cms/bundled/models/DatabaseItemPointerModel.ts
var DatabaseItemPointerModel = class _DatabaseItemPointerModel {
  constructor(chunkId, offset, length) {
    this.chunkId = chunkId;
    this.offset = offset;
    this.length = length;
  }
  static fromString(value) {
    const [chunkId, offset, length] = value.split("/").map(Number);
    assert(isNumber(chunkId), "Invalid chunkId");
    assert(isNumber(offset), "Invalid offset");
    assert(isNumber(length), "Invalid length");
    return new _DatabaseItemPointerModel(chunkId, offset, length);
  }
  toString() {
    return \`\${this.chunkId}/\${this.offset}/\${this.length}\`;
  }
  static read(reader) {
    const chunkId = reader.readUint16();
    const offset = reader.readUint32();
    const length = reader.readUint32();
    return new _DatabaseItemPointerModel(chunkId, offset, length);
  }
  write(writer) {
    writer.writeUint16(this.chunkId);
    writer.writeUint32(this.offset);
    writer.writeUint32(this.length);
  }
  compare(other) {
    if (this.chunkId < other.chunkId) return -1;
    if (this.chunkId > other.chunkId) return 1;
    if (this.offset < other.offset) return -1;
    if (this.offset > other.offset) return 1;
    assert(this.length === other.length);
    return 0;
  }
};

// src/code-generation/components/cms/bundled/models/DatabaseValueModel.ts
import { ControlType } from "framer";
function getValueType(value) {
  if (isNull(value)) {
    return 0 /* Null */;
  }
  switch (value.type) {
    case ControlType.Array:
      return 1 /* Array */;
    case ControlType.Boolean:
      return 2 /* Boolean */;
    case ControlType.Color:
      return 3 /* Color */;
    case ControlType.Date:
      return 4 /* Date */;
    case ControlType.Enum:
      return 5 /* Enum */;
    case ControlType.File:
      return 6 /* File */;
    case ControlType.ResponsiveImage:
      return 10 /* ResponsiveImage */;
    case ControlType.Link:
      return 7 /* Link */;
    case ControlType.Number:
      return 8 /* Number */;
    case ControlType.Object:
      return 9 /* Object */;
    case ControlType.RichText:
      return 11 /* RichText */;
    case ControlType.String:
      return 12 /* String */;
    case ControlType.VectorSetItem:
      return 13 /* VectorSetItem */;
    default:
      assertNever(value);
  }
}
var DatabaseValueModel;
((DatabaseValueModel2) => {
  function read(reader) {
    const type = reader.readUint8();
    switch (type) {
      case 0 /* Null */:
        return null;
      case 1 /* Array */:
        return readArray(reader);
      case 2 /* Boolean */:
        return readBoolean(reader);
      case 3 /* Color */:
        return readColor(reader);
      case 4 /* Date */:
        return readDate(reader);
      case 5 /* Enum */:
        return readEnum(reader);
      case 6 /* File */:
        return readFile(reader);
      case 7 /* Link */:
        return readLink(reader);
      case 8 /* Number */:
        return readNumber(reader);
      case 9 /* Object */:
        return readObject(reader);
      case 10 /* ResponsiveImage */:
        return readResponsiveImage(reader);
      case 11 /* RichText */:
        return readRichText(reader);
      case 12 /* String */:
        return readString(reader);
      case 13 /* VectorSetItem */:
        return readVectorSetItem(reader);
      default:
        assertNever(type);
    }
  }
  DatabaseValueModel2.read = read;
  function write(writer, value) {
    const type = getValueType(value);
    writer.writeUint8(type);
    if (isNull(value)) return;
    switch (value.type) {
      case ControlType.Array:
        return writeArray(writer, value);
      case ControlType.Boolean:
        return writeBoolean(writer, value);
      case ControlType.Color:
        return writeColor(writer, value);
      case ControlType.Date:
        return writeDate(writer, value);
      case ControlType.Enum:
        return writeEnum(writer, value);
      case ControlType.File:
        return writeFile(writer, value);
      case ControlType.Link:
        return writeLink(writer, value);
      case ControlType.Number:
        return writeNumber(writer, value);
      case ControlType.Object:
        return writeObject(writer, value);
      case ControlType.ResponsiveImage:
        return writeResponsiveImage(writer, value);
      case ControlType.RichText:
        return writeRichText(writer, value);
      case ControlType.VectorSetItem:
        return writeVectorSetItem(writer, value);
      case ControlType.String:
        return writeString(writer, value);
      default:
        assertNever(value);
    }
  }
  DatabaseValueModel2.write = write;
  function compare(left, right, collation) {
    const leftType = getValueType(left);
    const rightType = getValueType(right);
    if (leftType < rightType) return -1;
    if (leftType > rightType) return 1;
    if (isNull(left) || isNull(right)) return 0;
    switch (left.type) {
      case ControlType.Array:
        assert(right.type === ControlType.Array);
        return compareArray(left, right, collation);
      case ControlType.Boolean:
        assert(right.type === ControlType.Boolean);
        return compareBoolean(left, right);
      case ControlType.Color:
        assert(right.type === ControlType.Color);
        return compareColor(left, right);
      case ControlType.Date:
        assert(right.type === ControlType.Date);
        return compareDate(left, right);
      case ControlType.Enum:
        assert(right.type === ControlType.Enum);
        return compareEnum(left, right);
      case ControlType.File:
        assert(right.type === ControlType.File);
        return compareFile(left, right);
      case ControlType.Link:
        assert(right.type === ControlType.Link);
        return compareLink(left, right);
      case ControlType.Number:
        assert(right.type === ControlType.Number);
        return compareNumber(left, right);
      case ControlType.Object:
        assert(right.type === ControlType.Object);
        return compareObject(left, right, collation);
      case ControlType.ResponsiveImage:
        assert(right.type === ControlType.ResponsiveImage);
        return compareResponsiveImage(left, right);
      case ControlType.RichText:
        assert(right.type === ControlType.RichText);
        return compareRichText(left, right);
      case ControlType.VectorSetItem:
        assert(right.type === ControlType.VectorSetItem);
        return compareVectorSetItem(left, right);
      case ControlType.String:
        assert(right.type === ControlType.String);
        return compareString(left, right, collation);
      default:
        assertNever(left);
    }
  }
  DatabaseValueModel2.compare = compare;
})(DatabaseValueModel || (DatabaseValueModel = {}));
function readArray(reader) {
  const length = reader.readUint16();
  const value = [];
  for (let i = 0; i < length; i++) {
    const item = DatabaseValueModel.read(reader);
    value.push(item);
  }
  return {
    type: ControlType.Array,
    value
  };
}
function writeArray(writer, value) {
  writer.writeUint16(value.value.length);
  for (const item of value.value) {
    DatabaseValueModel.write(writer, item);
  }
}
function compareArray(left, right, collation) {
  const leftLength = left.value.length;
  const rightLength = right.value.length;
  if (leftLength < rightLength) return -1;
  if (leftLength > rightLength) return 1;
  for (let i = 0; i < leftLength; i++) {
    const leftItem = left.value[i];
    const rightItem = right.value[i];
    const result = DatabaseValueModel.compare(leftItem, rightItem, collation);
    if (result !== 0) return result;
  }
  return 0;
}
function readBoolean(reader) {
  return {
    type: ControlType.Boolean,
    value: reader.readUint8() !== 0
  };
}
function writeBoolean(writer, value) {
  writer.writeUint8(value.value ? 1 : 0);
}
function compareBoolean(left, right) {
  if (left.value < right.value) return -1;
  if (left.value > right.value) return 1;
  return 0;
}
function readColor(reader) {
  return {
    type: ControlType.Color,
    value: reader.readString()
  };
}
function writeColor(writer, value) {
  writer.writeString(value.value);
}
function compareColor(left, right) {
  if (left.value < right.value) return -1;
  if (left.value > right.value) return 1;
  return 0;
}
function readDate(reader) {
  const timestamp = reader.readInt64();
  const date = new Date(timestamp);
  return {
    type: ControlType.Date,
    value: date.toISOString()
  };
}
function writeDate(writer, value) {
  const date = new Date(value.value);
  const timestamp = date.getTime();
  writer.writeInt64(timestamp);
}
function compareDate(left, right) {
  const leftDate = new Date(left.value);
  const rightDate = new Date(right.value);
  if (leftDate < rightDate) return -1;
  if (leftDate > rightDate) return 1;
  return 0;
}
function readEnum(reader) {
  return {
    type: ControlType.Enum,
    value: reader.readString()
  };
}
function writeEnum(writer, value) {
  writer.writeString(value.value);
}
function compareEnum(left, right) {
  if (left.value < right.value) return -1;
  if (left.value > right.value) return 1;
  return 0;
}
function readFile(reader) {
  return {
    type: ControlType.File,
    value: reader.readString()
  };
}
function writeFile(writer, value) {
  writer.writeString(value.value);
}
function compareFile(left, right) {
  if (left.value < right.value) return -1;
  if (left.value > right.value) return 1;
  return 0;
}
function readLink(reader) {
  return {
    type: ControlType.Link,
    value: reader.readJson()
  };
}
function writeLink(writer, value) {
  writer.writeJson(value.value);
}
function compareLink(left, right) {
  const leftEncoded = JSON.stringify(left.value);
  const rightEncoded = JSON.stringify(right.value);
  if (leftEncoded < rightEncoded) return -1;
  if (leftEncoded > rightEncoded) return 1;
  return 0;
}
function readNumber(reader) {
  return {
    type: ControlType.Number,
    value: reader.readFloat64()
  };
}
function writeNumber(writer, value) {
  writer.writeFloat64(value.value);
}
function compareNumber(left, right) {
  if (left.value < right.value) return -1;
  if (left.value > right.value) return 1;
  return 0;
}
function readObject(reader) {
  const length = reader.readUint16();
  const result = {};
  for (let i = 0; i < length; i++) {
    const key = reader.readString();
    result[key] = DatabaseValueModel.read(reader);
  }
  return {
    type: ControlType.Object,
    value: result
  };
}
function writeObject(writer, value) {
  const entries = Object.entries(value.value);
  writer.writeUint16(entries.length);
  for (const [key, item] of entries) {
    writer.writeString(key);
    DatabaseValueModel.write(writer, item);
  }
}
function compareObject(left, right, collation) {
  const leftKeys = Object.keys(left.value).sort();
  const rightKeys = Object.keys(right.value).sort();
  if (leftKeys.length < rightKeys.length) return -1;
  if (leftKeys.length > rightKeys.length) return 1;
  for (let i = 0; i < leftKeys.length; i++) {
    const leftKey = leftKeys[i];
    const rightKey = rightKeys[i];
    if (leftKey < rightKey) return -1;
    if (leftKey > rightKey) return 1;
    const leftValue = left.value[leftKey] ?? null;
    const rightValue = right.value[rightKey] ?? null;
    const result = DatabaseValueModel.compare(leftValue, rightValue, collation);
    if (result !== 0) return result;
  }
  return 0;
}
function readResponsiveImage(reader) {
  return {
    type: ControlType.ResponsiveImage,
    value: reader.readJson()
  };
}
function writeResponsiveImage(writer, value) {
  writer.writeJson(value.value);
}
function compareResponsiveImage(left, right) {
  const leftEncoded = JSON.stringify(left.value);
  const rightEncoded = JSON.stringify(right.value);
  if (leftEncoded < rightEncoded) return -1;
  if (leftEncoded > rightEncoded) return 1;
  return 0;
}
function readRichText(reader) {
  const type = reader.readInt8();
  if (type === 0) {
    return {
      type: ControlType.RichText,
      value: reader.readUint32()
    };
  }
  if (type === 1) {
    return {
      type: ControlType.RichText,
      value: reader.readString()
    };
  }
  throw new Error(\`Invalid rich text pointer\`);
}
function writeRichText(writer, value) {
  if (isNumber(value.value)) {
    writer.writeInt8(0);
    writer.writeUint32(value.value);
    return;
  }
  if (isString(value.value)) {
    writer.writeInt8(1);
    writer.writeString(value.value);
    return;
  }
  throw new Error(\`Invalid rich text pointer\`);
}
function compareRichText(left, right) {
  const leftValue = left.value;
  const rightValue = right.value;
  if (isNumber(leftValue) && isNumber(rightValue)) {
    if (leftValue < rightValue) return -1;
    if (leftValue > rightValue) return 1;
    return 0;
  }
  if (isString(leftValue) && isString(rightValue)) {
    if (leftValue < rightValue) return -1;
    if (leftValue > rightValue) return 1;
    return 0;
  }
  throw new Error(\`Invalid rich text pointer\`);
}
function readString(reader) {
  return {
    type: ControlType.String,
    value: reader.readString()
  };
}
function writeString(writer, value) {
  writer.writeString(value.value);
}
function compareString(left, right, collation) {
  let leftValue = left.value;
  let rightValue = right.value;
  if (collation.type === 0 /* CaseInsensitive */) {
    leftValue = left.value.toLowerCase();
    rightValue = right.value.toLowerCase();
  }
  if (leftValue < rightValue) return -1;
  if (leftValue > rightValue) return 1;
  return 0;
}
function readVectorSetItem(reader) {
  return {
    type: ControlType.VectorSetItem,
    value: reader.readUint32()
  };
}
function writeVectorSetItem(writer, value) {
  writer.writeUint32(value.value);
}
function compareVectorSetItem(left, right) {
  const leftValue = left.value;
  const rightValue = right.value;
  if (leftValue < rightValue) return -1;
  if (leftValue > rightValue) return 1;
  return 0;
}

// src/code-generation/components/cms/bundled/models/DatabaseDictionaryIndexModel.ts
var DatabaseDictionaryIndexModel = class _DatabaseDictionaryIndexModel {
  constructor(fieldNames, options) {
    this.fieldNames = fieldNames;
    this.options = options;
    __publicField(this, "entries", []);
  }
  sortEntries() {
    this.entries.sort((left, right) => {
      for (let i = 0; i < this.fieldNames.length; i++) {
        const leftValue = left.values[i];
        const rightValue = right.values[i];
        const result = DatabaseValueModel.compare(leftValue, rightValue, this.options.collation);
        if (result !== 0) return result;
      }
      return left.pointer.compare(right.pointer);
    });
  }
  static deserialize(bytes) {
    const reader = new BufferReader(bytes);
    const collation = reader.readJson();
    const fieldCount = reader.readUint8();
    const fieldNames = [];
    for (let i = 0; i < fieldCount; i++) {
      const fieldName = reader.readString();
      fieldNames.push(fieldName);
    }
    const index = new _DatabaseDictionaryIndexModel(fieldNames, {
      collation
    });
    const entryCount = reader.readUint32();
    for (let i = 0; i < entryCount; i++) {
      const values = [];
      for (let j = 0; j < fieldCount; j++) {
        const fieldValue = DatabaseValueModel.read(reader);
        values.push(fieldValue);
      }
      const pointer = DatabaseItemPointerModel.read(reader);
      index.entries.push({ values, pointer });
    }
    return index;
  }
  serialize() {
    const writer = new BufferWriter();
    writer.writeJson(this.options.collation);
    writer.writeUint8(this.fieldNames.length);
    for (const fieldName of this.fieldNames) {
      writer.writeString(fieldName);
    }
    this.sortEntries();
    writer.writeUint32(this.entries.length);
    for (const entry of this.entries) {
      const { values, pointer } = entry;
      for (const value of values) {
        DatabaseValueModel.write(writer, value);
      }
      pointer.write(writer);
    }
    return writer.subarray();
  }
  addItem(item, pointer) {
    const values = this.fieldNames.map((fieldName) => {
      return item.getField(fieldName) ?? null;
    });
    this.entries.push({ values, pointer });
  }
};

// src/code-generation/components/cms/bundled/fetchWithRetries.ts
var maxRetries = 3;
var baseDelay = 250;
var retriableHTTPCodes = [
  408,
  // Request Timeout
  429,
  // Too Many Requests
  500,
  // Internal Server Error
  502,
  // Bad Gateway
  503,
  // Service Unavailable
  504
  // Gateway Timeout
];
var fetchWithRetries = async (input, init) => {
  let retryCount = 0;
  while (true) {
    try {
      const res = await fetch(input, init);
      if (!retriableHTTPCodes.includes(res.status) || ++retryCount > maxRetries) {
        return res;
      }
    } catch (error) {
      if (init?.signal?.aborted || ++retryCount > maxRetries) {
        throw error;
      }
    }
    await retryDelay(retryCount);
  }
};
async function retryDelay(retryCount) {
  const backoffExponent = retryCount - 1;
  const jitter = Math.random() + 1;
  const timeout = Math.floor(baseDelay * jitter * 2 ** backoffExponent);
  await new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}

// src/code-generation/components/cms/bundled/rangeRequest.ts
async function rangeRequest(url, ranges) {
  const collapsedRanges = collapseRanges(ranges);
  const rangeStrings = [];
  let expectedLength = 0;
  for (const range of collapsedRanges) {
    rangeStrings.push(\`\${range.from}-\${range.to - 1}\`);
    expectedLength += range.to - range.from;
  }
  const rangeUrl = new URL(url);
  const rangeQuery = rangeStrings.join(",");
  rangeUrl.searchParams.set("range", rangeQuery);
  const response = await fetchWithRetries(rangeUrl);
  if (response.status !== 200) {
    throw new Error(\`Request failed: \${response.status} \${response.statusText}\`);
  }
  const buffer = await response.arrayBuffer();
  const bytes = new Uint8Array(buffer);
  if (bytes.length !== expectedLength) {
    throw new Error("Request failed: Unexpected response length");
  }
  const file = new PartialFile();
  let start = 0;
  for (const range of collapsedRanges) {
    const length = range.to - range.from;
    const end = start + length;
    const part = bytes.subarray(start, end);
    file.write(range.from, part);
    start = end;
  }
  return ranges.map((range) => {
    return file.read(range.from, range.to - range.from);
  });
}
var PartialFile = class {
  constructor() {
    __publicField(this, "chunks", []);
  }
  read(position, length) {
    for (const chunk of this.chunks) {
      if (position < chunk.start) {
        throw new Error("Missing data");
      }
      if (position > chunk.end) {
        continue;
      }
      if (position + length > chunk.end) {
        throw new Error("Missing data");
      }
      const from = position - chunk.start;
      const to = from + length;
      return chunk.data.slice(from, to);
    }
    throw new Error("Missing data");
  }
  write(position, data) {
    let start = position;
    let end = start + data.length;
    let fromIndex = 0;
    let toIndex = this.chunks.length;
    for (; fromIndex < toIndex; fromIndex++) {
      const chunk2 = this.chunks[fromIndex];
      assert(chunk2, "Missing chunk");
      if (start > chunk2.end) {
        continue;
      }
      if (start > chunk2.start) {
        const offset = start - chunk2.start;
        const prefix = chunk2.data.subarray(0, offset);
        data = join(prefix, data);
        start = chunk2.start;
      }
      break;
    }
    for (; toIndex > fromIndex; toIndex--) {
      const chunk2 = this.chunks[toIndex - 1];
      assert(chunk2, "Missing chunk");
      if (end < chunk2.start) {
        continue;
      }
      if (end < chunk2.end) {
        const offset = end - chunk2.start;
        const suffix = chunk2.data.subarray(offset);
        data = join(data, suffix);
        end = chunk2.end;
      }
      break;
    }
    const chunk = {
      start,
      end,
      data
    };
    const deleteCount = toIndex - fromIndex;
    this.chunks.splice(fromIndex, deleteCount, chunk);
  }
};
function join(left, right) {
  const length = left.length + right.length;
  const result = new Uint8Array(length);
  result.set(left, 0);
  result.set(right, left.length);
  return result;
}
function collapseRanges(ranges) {
  assert(ranges.length > 0, "Must have at least one range");
  const sorted = [...ranges].sort((a, b) => a.from - b.from);
  const collapsed = [];
  for (const range of sorted) {
    const index = collapsed.length - 1;
    const previous = collapsed[index];
    if (previous && range.from <= previous.to) {
      collapsed[index] = {
        from: previous.from,
        to: Math.max(previous.to, range.to)
      };
    } else {
      collapsed.push(range);
    }
  }
  return collapsed;
}

// src/code-generation/components/cms/bundled/DatabaseDictionaryIndex.ts
var DatabaseDictionaryIndex = class {
  constructor(options) {
    this.options = options;
    __publicField(this, "schema");
    __publicField(this, "fields");
    __publicField(this, "supportedLookupTypes", [
      "All" /* All */,
      "Equals" /* Equals */,
      "NotEquals" /* NotEquals */,
      "LessThan" /* LessThan */,
      "GreaterThan" /* GreaterThan */,
      "Contains" /* Contains */,
      "StartsWith" /* StartsWith */,
      "EndsWith" /* EndsWith */
    ]);
    __publicField(this, "modelPromise");
    __publicField(this, "model");
    __publicField(this, "collation");
    const schema = {};
    const fields = [];
    for (const fieldName of this.options.fieldNames) {
      const definition = this.options.collectionSchema[fieldName];
      assert(definition, "Missing definition for field", fieldName);
      schema[fieldName] = definition;
      fields.push({ type: "Identifier", name: fieldName });
    }
    this.schema = schema;
    this.fields = fields;
    this.collation = this.options.collation;
  }
  async loadModel() {
    const [bytes] = await rangeRequest(this.options.url, [this.options.range]);
    assert(bytes, "Failed to load model");
    return DatabaseDictionaryIndexModel.deserialize(bytes);
  }
  async getModel() {
    this.modelPromise ??= this.loadModel();
    this.model ??= await this.modelPromise;
    return this.model;
  }
  async lookupItems(queries) {
    assert(queries.length === this.fields.length, "Invalid query length");
    const model = await this.getModel();
    const chunks = queries.reduce(
      (memo, query, position) => memo.flatMap((entries) => {
        switch (query.type) {
          case "All" /* All */:
            return [entries];
          case "Equals" /* Equals */:
            return this.queryEquals(entries, query, position);
          case "NotEquals" /* NotEquals */:
            return this.queryNotEquals(entries, query, position);
          case "LessThan" /* LessThan */:
            return this.queryLessThan(entries, query, position);
          case "GreaterThan" /* GreaterThan */:
            return this.queryGreaterThan(entries, query, position);
          case "Contains" /* Contains */:
            return this.queryContains(entries, query, position);
          case "StartsWith" /* StartsWith */:
            return this.queryStartsWith(entries, query, position);
          case "EndsWith" /* EndsWith */:
            return this.queryEndsWith(entries, query, position);
          default:
            assertNever(query);
        }
      }),
      [model.entries]
    );
    const result = [];
    for (const entries of chunks) {
      for (const entry of entries) {
        const data = {};
        for (let i = 0; i < this.options.fieldNames.length; i++) {
          const fieldName = this.options.fieldNames[i];
          const fieldValue = entry.values[i];
          data[fieldName] = fieldValue;
        }
        result.push({ pointer: entry.pointer.toString(), data });
      }
    }
    return result;
  }
  queryEquals(entries, query, position) {
    const leftMost = this.getLeftMost(entries, position, query.value);
    const rightMost = this.getRightMost(entries, position, query.value);
    const slice = entries.slice(leftMost, rightMost + 1);
    return slice.length > 0 ? [slice] : [];
  }
  queryNotEquals(entries, query, position) {
    const leftMost = this.getLeftMost(entries, position, query.value);
    const rightMost = this.getRightMost(entries, position, query.value);
    const result = [];
    const before = entries.slice(0, leftMost);
    if (before.length > 0) result.push(before);
    const after = entries.slice(rightMost + 1);
    if (after.length > 0) result.push(after);
    return result;
  }
  queryLessThan(entries, query, position) {
    const nullBound = this.getRightMost(entries, position, null);
    entries = entries.slice(nullBound + 1);
    if (query.inclusive) {
      const rightMost = this.getRightMost(entries, position, query.value);
      const slice2 = entries.slice(0, rightMost + 1);
      return slice2.length > 0 ? [slice2] : [];
    }
    const leftMost = this.getLeftMost(entries, position, query.value);
    const slice = entries.slice(0, leftMost);
    return slice.length > 0 ? [slice] : [];
  }
  queryGreaterThan(entries, query, position) {
    const nullBound = this.getRightMost(entries, position, null);
    entries = entries.slice(nullBound + 1);
    if (query.inclusive) {
      const leftMost = this.getLeftMost(entries, position, query.value);
      const slice2 = entries.slice(leftMost);
      return slice2.length > 0 ? [slice2] : [];
    }
    const rightMost = this.getRightMost(entries, position, query.value);
    const slice = entries.slice(rightMost + 1);
    return slice.length > 0 ? [slice] : [];
  }
  queryContains(entries, query, position) {
    return this.findItems(entries, position, (current) => {
      if (current?.type !== ControlType2.String) return false;
      if (query.value?.type !== ControlType2.String) return false;
      let source = current.value;
      let target = query.value.value;
      if (this.collation.type === 0 /* CaseInsensitive */) {
        source = source.toLowerCase();
        target = target.toLowerCase();
      }
      return source.includes(target);
    });
  }
  queryStartsWith(entries, query, position) {
    return this.findItems(entries, position, (current) => {
      if (current?.type !== ControlType2.String) return false;
      if (query.value?.type !== ControlType2.String) return false;
      let source = current.value;
      let target = query.value.value;
      if (this.collation.type === 0 /* CaseInsensitive */) {
        source = source.toLowerCase();
        target = target.toLowerCase();
      }
      return source.startsWith(target);
    });
  }
  queryEndsWith(entries, query, position) {
    return this.findItems(entries, position, (current) => {
      if (current?.type !== ControlType2.String) return false;
      if (query.value?.type !== ControlType2.String) return false;
      let source = current.value;
      let target = query.value.value;
      if (this.collation.type === 0 /* CaseInsensitive */) {
        source = source.toLowerCase();
        target = target.toLowerCase();
      }
      return source.endsWith(target);
    });
  }
  /**
   * Returns the index of the left most entry that is equal to the target.
   *
   * \`\`\`text
   *   Left most
   *       \u2193
   * \u250C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2510
   * \u2502 1 \u2502 2 \u2502 2 \u2502 2 \u2502 2 \u2502 3 \u2502
   * \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518
   * \`\`\`
   *
   * @param entries The entries array to search in.
   * @param position The position of the value in the entry.
   * @param target The target value to search for.
   * @returns The index of the left most entry that is equal to the target.
   */
  getLeftMost(entries, position, target) {
    let left = 0;
    let right = entries.length;
    while (left < right) {
      const middle = left + right >> 1;
      const entry = entries[middle];
      const value = entry.values[position];
      if (DatabaseValueModel.compare(value, target, this.collation) < 0) {
        left = middle + 1;
      } else {
        right = middle;
      }
    }
    return left;
  }
  /**
   * Returns the index of the right most entry that is equal to the target.
   *
   * \`\`\`text
   *              Right most
   *                   \u2193
   * \u250C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2510
   * \u2502 1 \u2502 2 \u2502 2 \u2502 2 \u2502 2 \u2502 3 \u2502
   * \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518
   * \`\`\`
   *
   * @param entries The entries array to search in.
   * @param position The position of the value in the entry.
   * @param target The target value to search for.
   * @returns The index of the right most entry that is equal to the target.
   */
  getRightMost(entries, position, target) {
    let left = 0;
    let right = entries.length;
    while (left < right) {
      const middle = left + right >> 1;
      const entry = entries[middle];
      const value = entry.values[position];
      if (DatabaseValueModel.compare(value, target, this.collation) > 0) {
        right = middle;
      } else {
        left = middle + 1;
      }
    }
    return right - 1;
  }
  /**
   * Finds all items that are matching the predicate and groups adjacent items together.
   *
   * @param entries The entries array to search in.
   * @param position The position of the value in the entry.
   * @param predicate The predicate to match the values against.
   * @returns An array of chunks that match the predicate.
   */
  findItems(entries, position, predicate) {
    const result = [];
    let start = 0;
    for (let i = 0; i < entries.length; i++) {
      const entry = entries[i];
      const value = entry.values[position];
      const isMatching = predicate(value);
      if (isMatching) continue;
      if (start < i) {
        const slice = entries.slice(start, i);
        result.push(slice);
      }
      start = i + 1;
    }
    if (start < entries.length) {
      const slice = entries.slice(start);
      result.push(slice);
    }
    return result;
  }
};

// src/code-generation/components/cms/bundled/models/DatabaseItemModel.ts
var DatabaseItemModel = class _DatabaseItemModel {
  constructor() {
    __publicField(this, "fields", /* @__PURE__ */ new Map());
  }
  static read(reader) {
    const item = new _DatabaseItemModel();
    const fieldCount = reader.readUint16();
    for (let i = 0; i < fieldCount; i++) {
      const key = reader.readString();
      const value = DatabaseValueModel.read(reader);
      item.setField(key, value);
    }
    return item;
  }
  write(writer) {
    writer.writeUint16(this.fields.size);
    for (const [key, value] of this.fields) {
      writer.writeString(key);
      DatabaseValueModel.write(writer, value);
    }
  }
  getData() {
    const data = {};
    for (const [key, value] of this.fields) {
      data[key] = value;
    }
    return data;
  }
  setField(key, value) {
    this.fields.set(key, value);
  }
  getField(key) {
    return this.fields.get(key);
  }
};

// src/code-generation/components/cms/bundled/DatabaseCollection.ts?bundle
var DatabaseChunk = class {
  constructor(id, url) {
    this.id = id;
    this.url = url;
    __publicField(this, "itemsPromise");
    __publicField(this, "itemLoader", new import_dataloader.default(async (pointers) => {
      const ranges = pointers.map((pointer) => {
        const pointerModel = DatabaseItemPointerModel.fromString(pointer);
        return { from: pointerModel.offset, to: pointerModel.offset + pointerModel.length };
      });
      const rangeBytes = await rangeRequest(this.url, ranges);
      return rangeBytes.map((bytes, index) => {
        const reader = new BufferReader(bytes);
        const itemModel = DatabaseItemModel.read(reader);
        const pointer = pointers[index];
        assert(pointer, "Missing pointer");
        return {
          pointer,
          data: itemModel.getData()
        };
      });
    }));
  }
  scanItems() {
    this.itemsPromise ??= fetchWithRetries(this.url).then(async (response) => {
      if (!response.ok) {
        throw new Error(\`Request failed: \${response.status} \${response.statusText}\`);
      }
      const buffer = await response.arrayBuffer();
      const bytes = new Uint8Array(buffer);
      const reader = new BufferReader(bytes);
      const items = [];
      const itemCount = reader.readUint32();
      for (let i = 0; i < itemCount; i++) {
        const offset = reader.getOffset();
        const itemModel = DatabaseItemModel.read(reader);
        const length = reader.getOffset() - offset;
        const pointerModel = new DatabaseItemPointerModel(this.id, offset, length);
        const pointer = pointerModel.toString();
        const item = {
          pointer,
          data: itemModel.getData()
        };
        this.itemLoader.prime(pointer, item);
        items.push(item);
      }
      return items;
    });
    return this.itemsPromise;
  }
  resolveItem(pointer) {
    return this.itemLoader.load(pointer);
  }
};
var DatabaseCollection = class {
  constructor(options) {
    this.options = options;
    __publicField(this, "id");
    __publicField(this, "schema");
    __publicField(this, "indexes");
    __publicField(this, "resolveRichText");
    __publicField(this, "resolveVectorSetItem");
    __publicField(this, "chunks");
    this.chunks = this.options.chunks.map((url, id) => {
      return new DatabaseChunk(id, url);
    });
    this.schema = options.schema;
    this.indexes = options.indexes;
    this.resolveRichText = options.resolveRichText;
    this.resolveVectorSetItem = options.resolveVectorSetItem;
    this.id = options.id;
  }
  async scanItems() {
    const chunkedItems = await Promise.all(
      this.chunks.map(async (chunk) => {
        return chunk.scanItems();
      })
    );
    return chunkedItems.flat();
  }
  resolveItems(pointers) {
    return Promise.all(
      pointers.map((pointer) => {
        const pointerModel = DatabaseItemPointerModel.fromString(pointer);
        const chunk = this.chunks[pointerModel.chunkId];
        assert(chunk, "Missing chunk");
        return chunk.resolveItem(pointer);
      })
    );
  }
  compareItems(left, right) {
    const leftModel = DatabaseItemPointerModel.fromString(left.pointer);
    const rightModel = DatabaseItemPointerModel.fromString(right.pointer);
    return leftModel.compare(rightModel);
  }
  compareValues(left, right, collation) {
    return DatabaseValueModel.compare(left, right, collation);
  }
};
export {
  DatabaseCollection,
  DatabaseDictionaryIndex
};
`;var ja=`var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/code-generation/components/cms/bundled/DraftDatabaseCollection.ts?bundle
import { ControlType } from "framer";

// src/utils/typeChecks.ts
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return Number.isFinite(value);
}

// src/code-generation/components/cms/bundled/assert.ts
function assert(condition, ...msg) {
  if (condition) return;
  throw Error("Assertion Error" + (msg.length > 0 ? ": " + msg.join(" ") : ""));
}

// src/code-generation/components/cms/bundled/DraftDatabaseCollection.ts?bundle
var DraftDatabaseCollection = class {
  constructor(draftCollection, originalCollection, previousItemId, nextItemId) {
    this.draftCollection = draftCollection;
    this.originalCollection = originalCollection;
    this.previousItemId = previousItemId;
    this.nextItemId = nextItemId;
    __publicField(this, "schema");
    // We cannot use the original indexes because the draft items
    // are not in the original collection.
    // Having no indexes means that we perform a full collection scan for every query.
    __publicField(this, "indexes", []);
    __publicField(this, "itemsPromise");
    this.schema = originalCollection.schema;
    this.itemsPromise = this.getItems();
  }
  async getItems() {
    const [[...draftItems], [...originalItems]] = await Promise.all([
      this.draftCollection.scanItems(),
      this.originalCollection.scanItems()
    ]);
    const lastDraftItem = draftItems.pop();
    const firstOriginalItem = originalItems.shift();
    if (lastDraftItem) {
      draftItems.push({
        ...lastDraftItem,
        data: {
          ...lastDraftItem.data,
          [this.nextItemId]: firstOriginalItem?.data.id ?? null
        }
      });
    }
    if (firstOriginalItem) {
      originalItems.unshift({
        ...firstOriginalItem,
        data: {
          ...firstOriginalItem.data,
          [this.previousItemId]: lastDraftItem?.data.id ?? null
        }
      });
    }
    return draftItems.map(draftItem).concat(...originalItems);
  }
  /**
   * Get all items, updating pointers for draft items.
   */
  scanItems() {
    return this.itemsPromise;
  }
  /**
   * Depending on the pointer, resolve draft rich text from the draft
   * collection, and original rich text from the original collection.
   */
  resolveRichText(pointer) {
    if (isDraftRichTextPointer(pointer)) {
      const originalPointer = undraftRichTextPointer(pointer);
      return this.draftCollection.resolveRichText(originalPointer);
    }
    return this.originalCollection.resolveRichText(pointer);
  }
  resolveVectorSetItem(pointer) {
    if (isDraftVectorSetItemPointer(pointer)) {
      const originalPointer = undraftVectorSetItemPointer(pointer);
      return this.draftCollection.resolveVectorSetItem?.(originalPointer);
    }
    return this.originalCollection.resolveVectorSetItem?.(pointer);
  }
  async resolveItems(pointers) {
    const items = await this.itemsPromise;
    return pointers.map((pointer) => {
      const item = items.find((current) => current.pointer === pointer);
      assert(item, "Item must exist");
      return item;
    });
  }
  /**
   * Compare two items, the draft items should come first.
   */
  compareItems(left, right) {
    const leftIsDraft = isDraftPointer(left.pointer);
    const rightIsDraft = isDraftPointer(right.pointer);
    if (leftIsDraft && rightIsDraft) {
      const originalLeft = undraftItem(left);
      const originalRight = undraftItem(right);
      return this.draftCollection.compareItems(originalLeft, originalRight);
    }
    if (leftIsDraft) return -1;
    if (rightIsDraft) return 1;
    return this.originalCollection.compareItems(left, right);
  }
};
var draftPrefix = "draft:";
function isDraftPointer(pointer) {
  return pointer.startsWith(draftPrefix);
}
function draftPointer(pointer) {
  assert(!isDraftPointer(pointer), "Should be a non-draft pointer");
  return draftPrefix + pointer;
}
function undraftPointer(pointer) {
  assert(isDraftPointer(pointer), "Should be a draft pointer");
  return pointer.slice(draftPrefix.length);
}
function isDraftRichTextPointer(pointer) {
  if (isNumber(pointer)) {
    return pointer < 0;
  }
  if (isString(pointer)) {
    return pointer.startsWith(draftPrefix);
  }
  throw new Error("Invalid rich text pointer");
}
function draftRichTextPointer(pointer) {
  assert(!isDraftRichTextPointer(pointer), "Should be a non-draft rich text pointer");
  if (isNumber(pointer)) {
    return -pointer - 1;
  }
  if (isString(pointer)) {
    return draftPrefix + pointer;
  }
  throw new Error("Invalid rich text pointer");
}
function undraftRichTextPointer(pointer) {
  assert(isDraftRichTextPointer(pointer), "Should be a draft rich text pointer");
  if (isNumber(pointer)) {
    return -pointer - 1;
  }
  if (isString(pointer)) {
    return pointer.slice(draftPrefix.length);
  }
  throw new Error("Invalid rich text pointer");
}
function isDraftVectorSetItemPointer(pointer) {
  assert(isNumber(pointer), "Invalid vector set item pointer");
  return pointer < 0;
}
function draftVectorSetItemPointer(pointer) {
  assert(isNumber(pointer), "Invalid vector set item pointer");
  assert(!isDraftVectorSetItemPointer(pointer), "Should be a non-draft vector set item pointer");
  return -pointer - 1;
}
function undraftVectorSetItemPointer(pointer) {
  assert(isNumber(pointer), "Invalid vector set item pointer");
  assert(isDraftVectorSetItemPointer(pointer), "Should be a draft vector set item pointer");
  return -pointer - 1;
}
function draftItem(item) {
  const data = {};
  for (const [key, value] of Object.entries(item.data)) {
    if (value?.type === ControlType.RichText) {
      data[key] = {
        type: ControlType.RichText,
        value: draftRichTextPointer(value.value)
      };
    } else if (value?.type === ControlType.VectorSetItem) {
      data[key] = {
        type: ControlType.VectorSetItem,
        value: draftVectorSetItemPointer(value.value)
      };
    } else {
      data[key] = value;
    }
  }
  return {
    pointer: draftPointer(item.pointer),
    data
  };
}
function undraftItem(item) {
  const data = {};
  for (const [key, value] of Object.entries(item.data)) {
    if (value?.type === ControlType.RichText) {
      data[key] = {
        type: ControlType.RichText,
        value: undraftRichTextPointer(value.value)
      };
    } else if (value?.type === ControlType.VectorSetItem) {
      data[key] = {
        type: ControlType.VectorSetItem,
        value: undraftVectorSetItemPointer(value.value)
      };
    } else {
      data[key] = value;
    }
  }
  return {
    pointer: undraftPointer(item.pointer),
    data
  };
}
export {
  DraftDatabaseCollection
};
`;var Xt=class o{constructor(t,e,r){this.chunkId=t;this.offset=e;this.length=r}static fromString(t){let[e,r,n]=t.split("/").map(Number);return _(B(e),"Invalid chunkId"),_(B(r),"Invalid offset"),_(B(n),"Invalid length"),new o(e,r,n)}toString(){return`${this.chunkId}/${this.offset}/${this.length}`}static read(t){let e=t.readUint16(),r=t.readUint32(),n=t.readUint32();return new o(e,r,n)}write(t){t.writeUint16(this.chunkId),t.writeUint32(this.offset),t.writeUint32(this.length)}compare(t){return this.chunkId<t.chunkId?-1:this.chunkId>t.chunkId?1:this.offset<t.offset?-1:this.offset>t.offset?1:(_(this.length===t.length),0)}};function Vo(o){if(lr(o))return 0;switch(o.type){case"array":return 1;case"boolean":return 2;case"color":return 3;case"date":return 4;case"enum":return 5;case"file":return 6;case"responsiveimage":return 10;case"link":return 7;case"number":return 8;case"object":return 9;case"richtext":return 11;case"string":return 12;case"vectorsetitem":return 13;default:Rr(o)}}var he;(r=>{function o(n){let i=n.readUint8();switch(i){case 0:return null;case 1:return fd(n);case 2:return hd(n);case 3:return Sd(n);case 4:return Cd(n);case 5:return Id(n);case 6:return xd(n);case 7:return Ed(n);case 8:return Md(n);case 9:return Ud(n);case 10:return Od(n);case 11:return $d(n);case 12:return Wd(n);case 13:return Gd(n);default:Rr(i)}}r.read=o;function t(n,i){let s=Vo(i);if(n.writeUint8(s),!lr(i))switch(i.type){case"array":return pd(n,i);case"boolean":return gd(n,i);case"color":return vd(n,i);case"date":return Td(n,i);case"enum":return Nd(n,i);case"file":return Dd(n,i);case"link":return Pd(n,i);case"number":return Vd(n,i);case"object":return Ad(n,i);case"responsiveimage":return zd(n,i);case"richtext":return jd(n,i);case"vectorsetitem":return Kd(n,i);case"string":return Jd(n,i);default:Rr(i)}}r.write=t;function e(n,i,s){let a=Vo(n),c=Vo(i);if(a<c)return-1;if(a>c)return 1;if(lr(n)||lr(i))return 0;switch(n.type){case"array":return _(i.type==="array"),md(n,i,s);case"boolean":return _(i.type==="boolean"),yd(n,i);case"color":return _(i.type==="color"),bd(n,i);case"date":return _(i.type==="date"),wd(n,i);case"enum":return _(i.type==="enum"),Rd(n,i);case"file":return _(i.type==="file"),kd(n,i);case"link":return _(i.type==="link"),Ld(n,i);case"number":return _(i.type==="number"),Fd(n,i);case"object":return _(i.type==="object"),Bd(n,i,s);case"responsiveimage":return _(i.type==="responsiveimage"),_d(n,i);case"richtext":return _(i.type==="richtext"),qd(n,i);case"vectorsetitem":return _(i.type==="vectorsetitem"),Qd(n,i);case"string":return _(i.type==="string"),Hd(n,i,s);default:Rr(n)}}r.compare=e})(he||={});function fd(o){let t=o.readUint16(),e=[];for(let r=0;r<t;r++){let n=he.read(o);e.push(n)}return{type:"array",value:e}}function pd(o,t){o.writeUint16(t.value.length);for(let e of t.value)he.write(o,e)}function md(o,t,e){let r=o.value.length,n=t.value.length;if(r<n)return-1;if(r>n)return 1;for(let i=0;i<r;i++){let s=o.value[i],a=t.value[i],c=he.compare(s,a,e);if(c!==0)return c}return 0}function hd(o){return{type:"boolean",value:o.readUint8()!==0}}function gd(o,t){o.writeUint8(t.value?1:0)}function yd(o,t){return o.value<t.value?-1:o.value>t.value?1:0}function Sd(o){return{type:"color",value:o.readString()}}function vd(o,t){o.writeString(t.value)}function bd(o,t){return o.value<t.value?-1:o.value>t.value?1:0}function Cd(o){let t=o.readInt64(),e=new Date(t);return{type:"date",value:e.toISOString()}}function Td(o,t){let r=new Date(t.value).getTime();o.writeInt64(r)}function wd(o,t){let e=new Date(o.value),r=new Date(t.value);return e<r?-1:e>r?1:0}function Id(o){return{type:"enum",value:o.readString()}}function Nd(o,t){o.writeString(t.value)}function Rd(o,t){return o.value<t.value?-1:o.value>t.value?1:0}function xd(o){return{type:"file",value:o.readString()}}function Dd(o,t){o.writeString(t.value)}function kd(o,t){return o.value<t.value?-1:o.value>t.value?1:0}function Ed(o){return{type:"link",value:o.readJson()}}function Pd(o,t){o.writeJson(t.value)}function Ld(o,t){let e=JSON.stringify(o.value),r=JSON.stringify(t.value);return e<r?-1:e>r?1:0}function Md(o){return{type:"number",value:o.readFloat64()}}function Vd(o,t){o.writeFloat64(t.value)}function Fd(o,t){return o.value<t.value?-1:o.value>t.value?1:0}function Ud(o){let t=o.readUint16(),e={};for(let r=0;r<t;r++){let n=o.readString();e[n]=he.read(o)}return{type:"object",value:e}}function Ad(o,t){let e=Object.entries(t.value);o.writeUint16(e.length);for(let[r,n]of e)o.writeString(r),he.write(o,n)}function Bd(o,t,e){let r=Object.keys(o.value).sort(),n=Object.keys(t.value).sort();if(r.length<n.length)return-1;if(r.length>n.length)return 1;for(let i=0;i<r.length;i++){let s=r[i],a=n[i];if(s<a)return-1;if(s>a)return 1;let c=o.value[s]??null,d=t.value[a]??null,p=he.compare(c,d,e);if(p!==0)return p}return 0}function Od(o){return{type:"responsiveimage",value:o.readJson()}}function zd(o,t){o.writeJson(t.value)}function _d(o,t){let e=JSON.stringify(o.value),r=JSON.stringify(t.value);return e<r?-1:e>r?1:0}function $d(o){let t=o.readInt8();if(t===0)return{type:"richtext",value:o.readUint32()};if(t===1)return{type:"richtext",value:o.readString()};throw new Error("Invalid rich text pointer")}function jd(o,t){if(B(t.value)){o.writeInt8(0),o.writeUint32(t.value);return}if(we(t.value)){o.writeInt8(1),o.writeString(t.value);return}throw new Error("Invalid rich text pointer")}function qd(o,t){let e=o.value,r=t.value;if(B(e)&&B(r)||we(e)&&we(r))return e<r?-1:e>r?1:0;throw new Error("Invalid rich text pointer")}function Wd(o){return{type:"string",value:o.readString()}}function Jd(o,t){o.writeString(t.value)}function Hd(o,t,e){let r=o.value,n=t.value;return e.type===0&&(r=o.value.toLowerCase(),n=t.value.toLowerCase()),r<n?-1:r>n?1:0}function Gd(o){return{type:"vectorsetitem",value:o.readUint32()}}function Kd(o,t){o.writeUint32(t.value)}function Qd(o,t){let e=o.value,r=t.value;return e<r?-1:e>r?1:0}var je=class o{constructor(t,e){this.fieldNames=t;this.options=e;u(this,"entries",[])}sortEntries(){this.entries.sort((t,e)=>{for(let r=0;r<this.fieldNames.length;r++){let n=t.values[r],i=e.values[r],s=he.compare(n,i,this.options.collation);if(s!==0)return s}return t.pointer.compare(e.pointer)})}static deserialize(t){let e=new Fn(t),r=e.readJson(),n=e.readUint8(),i=[];for(let c=0;c<n;c++){let d=e.readString();i.push(d)}let s=new o(i,{collation:r}),a=e.readUint32();for(let c=0;c<a;c++){let d=[];for(let l=0;l<n;l++){let g=he.read(e);d.push(g)}let p=Xt.read(e);s.entries.push({values:d,pointer:p})}return s}serialize(){let t=new Pt;t.writeJson(this.options.collation),t.writeUint8(this.fieldNames.length);for(let e of this.fieldNames)t.writeString(e);this.sortEntries(),t.writeUint32(this.entries.length);for(let e of this.entries){let{values:r,pointer:n}=e;for(let i of r)he.write(t,i);n.write(t)}return t.subarray()}addItem(t,e){let r=this.fieldNames.map(n=>t.getField(n)??null);this.entries.push({values:r,pointer:e})}};var Un=class o{constructor(){u(this,"fields",new Map)}static read(t){let e=new o,r=t.readUint16();for(let n=0;n<r;n++){let i=t.readString(),s=he.read(t);e.setField(i,s)}return e}write(t){t.writeUint16(this.fields.size);for(let[e,r]of this.fields)t.writeString(e),he.write(t,r)}getData(){let t={};for(let[e,r]of this.fields)t[e]=r;return t}setField(t,e){this.fields.set(t,e)}getField(t){return this.fields.get(t)}};function Fo(o){return f`${o}.replace("/modules/", "/cms/")`}var Xd=D("serializeDatabase"),Uo=4*1024*1024,Yd=5e3;async function qa(o,t,e,r,n,i,s,a,c,d,p,l){let g=new Mn(o,t,i,r,c,d,s,a),y=o.getPropertyControls(t.tree),m=Object.entries(y),S=Ui(t.tree,"includeDrafts"),I={[Qe]:{type:Nt("string",i),isNullable:!1},[no]:{type:Nt("date",i),isNullable:!0},[oo]:{type:Nt("date",i),isNullable:!0},[ur]:{type:Nt("string",i),isNullable:!0},[fr]:{type:Nt("string",i),isNullable:!0}};function T(j){return Nt(j,i)}for(let[j,A]of m){let re=wa(A,T);re&&(I[j]=re)}let N=d.dedupe("schema",new le(I,0)),C=ba(o.variables),R=o.variables.find(vi),x=r.create($a),V,P,Z=l?!0:void 0,$=o.getSortedChildren().filter(j=>j.isDraft===Z),xe=crypto.randomUUID();if(l){let j=K("collection",o.id);if(V=f`${i.addImport(`../${j}`,{exportSpecifier:"default",importBinding:"originalCollection"})}.collectionByLocaleId`,$.length===0){let re={id:xe,displayName:o.name??"Unknown",collectionByLocaleId:V};return f`${re}`}let A=r.create(ja);P=i.addImport(A.submoduleImport,{exportSpecifier:"DraftDatabaseCollection"})}let Te=i.addImport(x.submoduleImport,{exportSpecifier:"DatabaseCollection"}),De={};for(let j of S){let ir=function(){let k=new Pt;return k.writeUint32(0),k},ar=function(k){let E=ke.subarray(0,k);Qt(E).setUint32(0,sr),vt.push(E)};var St=ir,or=ar;let A=[new je([Qe],{collation:{type:1}}),new je([ur],{collation:{type:1}}),new je([fr],{collation:{type:1}})];R&&A.push(new je([Qe,R.id],{collation:{type:1}}),new je([R.id,Qe],{collation:{type:1}}));for(let[k]of m)A.push(new je([k],{collation:{type:0}}));let re=new Vn,We=$.filter(k=>{let E=ga(t.tree,k);return E?E.includes(j.id):!0}),Me=[];for(let k=0;k<We.length;k++){let E=We[k];h(E,"Node must exist");let J=new Un;J.setField(Qe,{type:"string",value:E.id});let Je=E.createdAt;Je&&J.setField(no,{type:"date",value:new Date(Je).toISOString()});let rt=E.updatedAt;rt&&J.setField(oo,{type:"date",value:new Date(rt).toISOString()});let He=We[k-1];He&&J.setField(ur,{type:"string",value:He.id});let Ut=We[k+1];Ut&&J.setField(fr,{type:"string",value:Ut.id});let Ct={resolveColor(ee){return p.addColor(ee)},resolveFile(ee){return s.resolve(ee)?.src},resolveImage(ee,ge){return s.resolveResponsiveImage(ee,{focalPoint:ge})},resolveLink(ee){let ge=a.create(ee);if(!O(ge)&&!Ci(ge))return ge},resolveRichTextPointer(ee){return g.add(ee)},resolveVectorSetItemPointer(ee){return re.add(ee)}};for(let[ee,ge]of m){let zr=Ca(ee,ge,C,y,E);if(O(zr))continue;let Go=Ta({control:ge,controlProp:zr,resolvers:Ct,locale:j});O(Go)||J.setField(ee,Go)}Me.push(J)}let vt=[],sr=0,ke=ir();for(let k of Me){let E=ke.getOffset();k.write(ke),ke.getOffset()>Uo&&(ar(E),ke=ir(),E=ke.getOffset(),sr=0,k.write(ke)),sr++;let J=ke.getOffset()-E,Je=new Xt(vt.length,E,J);for(let rt of A)rt.addItem(k,Je)}ke.getOffset()>0&&ar();let Yn=i.addImport(x.submoduleImport,{exportSpecifier:"DatabaseDictionaryIndex"}),Ur=vt.map((k,E)=>Fo(n.create(`chunk-${j.id}-${E}`,Eo,k)));vt.reduce((k,E)=>k+E.length,0)<Yd&&(A.length=0);let bt=[],cr=1/0;for(let k of A){let E=k.serialize();if(E.length>=Uo){Xd.warn("Skipping index:",E.length);continue}cr+E.length>Uo&&(bt.push([]),cr=0);let J=bt.at(-1);h(J,"Chunk must exist"),J.push({model:k,bytes:E}),cr+=E.length}let Ar=[];for(let k=0;k<bt.length;k++){let E=bt[k];h(E,"Chunk must exist");let J=new Pt,Je=[];for(let{bytes:Ct}of E){let ee=J.getOffset();J.writeBytes(Ct);let ge=J.getOffset();Je.push({from:ee,to:ge})}let rt=J.subarray(),He=Fo(n.create(`indexes-${j.id}-${k}`,Eo,rt)),Ut=E.map(({model:Ct},ee)=>{if(Ct instanceof je){let ge=Je[ee];h(ge,"Can't find range for index");let zr={url:He,range:ge,fieldNames:d.dedupe("fieldNames",Ct.fieldNames),collation:d.dedupe("collation",Ct.options.collation),collectionSchema:N};return f`new ${Yn}(${zr})`}throw new Error("Unsupported index type")});Ar.push(...Ut)}let Br=re.serialize(e,d),Or={id:xe+j.id,schema:N,chunks:Ur,indexes:Ar,resolveRichText:g.resolveRichTextBinding,resolveVectorSetItem:Br};if(V&&P){let k=f`new ${Te}(${Or})`,E=f`${V}[${j.id}]`;De[j.id]=f`new ${P}(${k}, ${E}, ${ur}, ${fr})`}else De[j.id]=f`new ${Te}(${Or})`}g.serialize();let Ft={id:xe,displayName:o.name??"Unknown",collectionByLocaleId:De};return f`${Ft}`}var Ja=ie(async(o,t,e)=>Promise.all([Wa(o.id,t,!1),Wa(o.id,t,!0)]));async function Wa(o,t,e){let{modulesStore:r,treeStore:n,assetMap:i}=t,{tree:s}=n,a=e?"draftCollection":"collection",c=new un(i),d=new Ln(o),p=new $s(a,r,o),l=s.getNodeWithTrait(o,G);h(l,"Must have a source node to serialize");let g=l.moduleSourceRevision,y=Es(l);await yn(y,r);let{module:m}=Ds(r,l);Xe("collection_update",{moduleId:m?.id,recordCount:l.getItemCount(),source:"unknown"});let S=ks(l)?.id,I=new wt,T=new zt(a,r,I),N=new en(I),C=new Yr(l,T,I,void 0,n,r),R=new Zr,x=await qa(l,n,r,p,d,T,c,C,I,N,R,e),V=dt("",{framerRecordIdKey:Qe,framerSlug:S,framerEnumToDisplayNameUtils:"2",framerCollectionUtils:"1",framerCollectionId:l.id,framerColorSyntax:R.hasColorsOfType("wideGamut"),framerAutoSizeImages:!0,framerData:""}),P=I.create("data"),Z=nl(l,P,t,{imports:T},a),$=el(T,N,P,Qe,S),xe=f.joinLines(...T.statements,...N.list(),V,f`const ${P} = ${x}`,f`export default ${P}`,Z,...Zd(l.variables,s.root.locales),$);return{type:a,revision:g,source:xe,artifacts:{assets:new Set(c.keys),binaryAssets:d.assets,submodules:p.serialize(),metrics:{nodes:l.getItemCount()}}}}function Zd(o,t){let e=[],r=new le;for(let n of o){if(n.type!=="enum")continue;let i=new w(js(n.id));e.push(f`export const ${i} = ${Ba(n,t,i)};`),r[n.id]=i}return e.push(f`export const ${new w(qs)} = ${r};`),e}function el(o,t,e,r,n){return f.joinLines(f`export const utils = {`,f`async getSlugByRecordId(id, locale) {`,n?tl(o,t,e,r,n):void 0,f`},`,f`async getRecordIdBySlug(slug, locale) {`,n?rl(o,t,e,r,n):void 0,f`},`,f`}`)}function Ha(o,t){let e=o.addImport("framer",{exportSpecifier:"QueryEngine"}),r=t.dedupe("queryEngine",f`new ${e}()`),n=o.addImport("framer",{exportSpecifier:"QueryCache"});return t.dedupe("queryCache",f`new ${n}(${r})`)}function tl(o,t,e,r,n){let i=Ha(o,t),s={from:{type:"Collection",data:e},select:[{type:"Identifier",name:n}],where:{type:"BinaryOperation",operator:"==",left:{type:"Identifier",name:r},right:{type:"LiteralValue",value:f`id`}},limit:{type:"LiteralValue",value:1}};return f.joinLines(f`const [item] = await ${i}.get(${s}, locale).readAsync()`,f`return item?.[${n}]`)}function rl(o,t,e,r,n){let i=Ha(o,t),s={from:{type:"Collection",data:e},select:[{type:"Identifier",name:r}],where:{type:"BinaryOperation",operator:"==",left:{type:"Identifier",name:n},right:{type:"LiteralValue",value:f`slug`}},limit:{type:"LiteralValue",value:1}};return f.joinLines(f`const [item] = await ${i}.get(${s}, locale).readAsync()`,f`return item?.[${r}]`)}function nl(o,t,e,r,n){let i=va(o,e,r,n);if(O(i))return;let s=r.imports.addImport("framer",{exportSpecifier:"addPropertyControls"});return w.fn(s,t,i)}function An({componentName:o,fontObjects:t,fontReferences:e,imports:r,declarations:n,sharedFontArrays:i=[]}){return f.joinLines(...n.list(),w.fn(r.addImport("framer",{exportSpecifier:"addFonts"}),o,xr({fontObjects:t,fontReferences:e,sharedFontArrays:i}),{supportsExplicitInterCodegen:!0}))}function xr({fontObjects:o,fontReferences:t,sharedFontArrays:e=[]}){let r=[],n={explicitInter:!0,fonts:[]};for(let i of o){try{new URL(i.url)}catch{throw new Error(`Expected URL for font "${i.uiFamilyName}" to be a valid, absolute URL, but got: ${i.url}`)}n.fonts.push(i)}r.push(n);for(let i of t.values())r.push(f`...${i}`);for(let i of e)r.push(f`...${i}`);return r}var Ga=ie(async(o,{assetMap:t,treeStore:e,modulesStore:r})=>{let n=new wt,i=new un(t),s=new zt("componentPresets",r,n),a=new Yr(o,s,n,void 0,e,r),c=new en(n),d=new rs(o),p=new Ws(o,e,d,c,n,s,i),l=new _s(n,d,p,i,a),g=o.moduleSourceRevision,y={},m={},S=o.getComponentPresets();await yn(S.map(N=>N.componentIdentifier),r);let I=new wt,T=new tn(I);for(let N of S){let C=de.reactComponentForIdentifier(N.componentIdentifier);h(C,"Can't find react component for preset");let R=N.getFontsForCodeGeneration(de);await ni.loadFonts(R);let x=new fn(T),V=Vi(os(C,"onlyPresets"),N.getRawControlProps()),P=zs(N,C.properties,V,{pixelSize:void 0,repeaterInfo:void 0,context:{assets:i,imports:s,links:a,fonts:x,fetches:l}});y[N.id]=new le(P),(x.fontObjects.size>0||x.fontReferences.size>0)&&(m[N.id]=xr({fontObjects:x.fontObjects,fontReferences:x.fontReferences}))}return[{revision:g,type:"componentPresets",source:f.joinLines(...s.statements,f`export const props = ${y}`,...T.list(),f`export const fonts = ${m}`),artifacts:{assets:i.keys,metrics:{nodes:Object.keys(y).length}}}]});var ol=D("CodeGenerationStore");function Ka(o,t,e){return e.add(o),t[o]?.forEach(r=>{e.has(r)||Ka(r,t,e)}),e}function il(o,t){let e={};for(let{fromNode:r,toNode:n}of t){let i=e[r]??new Set;i.add(n),e[r]=i}return Ka(o,e,new Set([o]))}var Qa=ie(async(o,{treeStore:t,modulesStore:e})=>{let r=F(`Prototype/${o.name||"Generated Prototype"}`),n=t.tree.get(o.homeNodeId);h(n,"Can't serialize",r,": home node must exist.");let i=t.tree.getRect(n),s=new zt("prototype",e);s.addImport("react",{exportSpecifier:"*",importBinding:"React"}),s.addImport("framer-motion",{exportSpecifier:"LayoutGroup"}),s.addImport("framer",{exportSpecifier:"PageRoot"}),s.addImport("framer",{exportSpecifier:"useInitialRouteComponent"});let a={};for(let g of il(n.id,t.treeIndex.getPrototypeScreenLinks(t.tree,o.id))){let m=`../${K("screen",g)}`;try{await Fs(de,[Ve("screen",g,"default").value],e);let S=s.addImport(m,{exportSpecifier:"default",importBinding:"Screen",lazy:g!==o.homeNodeId});a[g]={page:S,path:g}}catch{ol.error("Missing module for prototype screen",{screenId:g})}}let c=F(o.homeNodeId),d=F(a),p=f`${s.addImport("react",{exportSpecifier:"*",importBinding:"React"})}.useId`,l=new w(M.sections(M.linesFrom(s.statements),`const routes = ${d}`,M.lines("function Prototype({ layoutId }: { layoutId?: string }): JSX.Element {",`  const InitialRouteComponent = useInitialRouteComponent(routes, "${o.homeNodeId}")`,`  const defaultLayoutId = ${w.fn(p)};`,"  if (!InitialRouteComponent) return null","  return (","    <LayoutGroup id={layoutId ?? defaultLayoutId} inherit={false}>",`      <PageRoot RootComponent={InitialRouteComponent} isWebsite={false} routeId={${c}} routes={routes} />`,"    </LayoutGroup>","  )","}"),M.lines(dt("This is a generated Framer component.",{framerIntrinsicHeight:i?.height,framerIntrinsicWidth:i?.width,framerSupportedLayoutWidth:"fixed",framerSupportedLayoutHeight:"fixed",framerPrototype:""}),"const Component: React.ComponentType<{}> = React.memo(Prototype)","export default Component;"),`Component.displayName = ${r};`));return[{type:"prototype",source:l,revision:void 0}]});async function Bn(o,t,e,r,n,i){return Mi(t)&&t.usesDOMRectCached()&&!t.getDOMRect()&&(await sl(t,r,e,n),!t.cache.getRawDOMRect(t.id)&&i)?Jr.atOrigin(i):o.getRect(t)}async function sl(o,t,e,r){if(t){let s=(await t({ids:[o.id]}))?.measurements?.[0];if(s){let{layoutMetrics:a}=s,c=Jr.from(a);o.cache.setRawDOMRect(o.id,c);return}}if(!e)return;let n=al(e,r);if(n){let i=Jr.atOrigin(n);o.cache.setRawDOMRect(o.id,i)}}function al(o,t){if(!$r(o))return;let e=t.getPersistedModuleByLocalIdentifier(o);if(!e)return;let{intrinsicWidth:r,intrinsicHeight:n}=e.metadata;if(B(r)&&B(n))return{width:r,height:n}}var be={Screen:f`Screen`,activeVariantCallback:v.activeVariantCallback,css:v.css,delay:v.delay,ref:v.ref,serializationHash:v.serializationHash,sharedStyleClassNames:v.sharedStyleClassNames,restProps:v.restProps,refBinding:v.refBinding},cl=new Set(Object.values(be).map(o=>F(o))),Xa=ie(async(o,t,{serializationId:e,initialIntrinsicSize:r})=>{let n=t.treeStore.tree.getScopeNodeFor(o);if(!H(n))return[];let i=t.treeStore.tree.get(o.id);h(i,"Must have a source node to serialize. This should be a primary variant."),h(H(n),"Must have a scope node to serialize. This should be a CanvasPage Node.");let{assetMap:s,engineChanges:a,modulesStore:c,treeStore:d}=t,p={assetMap:s,engineChanges:a,modulesStore:c,treeStore:d},l=`FramerScreen${ct(o.id)}`,g=Ve("screen",o.id,"default").value,{jsx:y,ctx:m}=await pn(i,n,p,new Set(cl).add(l),e);h(y,"There must be JSX to serialize.");let S=m.imports,I=await Bn(p.treeStore.tree,i,g,t.measureNodes,p.modulesStore,r),T=m.events.navigationTargets.size>0,N=m.events.handlers.size>0,C=m.events.variantOnAppearId.get(o.id),R=m.events.keyBindHooks.size>0,x=[];for(let A of m.events.navigationTargets)A!==Ms&&x.push(A);let V=m.fonts.fontObjects,P=new Map(m.fonts.fontReferences),{variables:Z}=m.variables,$=[],xe=new Set(m.css.sharedStyleIds),Te=[];for(let A of xe){let re=K("css",A),We=S.addImport(`../${re}`,{exportSpecifier:"*",importBinding:"sharedStyle"});Te.push(We),$.push(w.fn(S.addImport("framer",{exportSpecifier:"getFontsFromSharedStyle"}),f`${We}.fonts`))}let De;for(let A of m.componentPresetIds){De??=S.addImport(`../${ln}`,{exportSpecifier:"*",importBinding:"componentPresets"});let re=f`${De}.fonts?.[${A}]`;$.push(f`(${re} ? ${w.fn(m.imports.addImport("framer",{exportSpecifier:"getFontsFromComponentPreset"}),re)} : [])`)}let Ft=new Map;_t(m.css.get(),Ft);let St=new w(l),or=S.addImport("react",{exportSpecifier:"useRef"}),j=M.lines(T&&`const preload = ${F(x)};`,...m.declarations.file.list(),f`const ${be.serializationHash} = ${e}`,f`const ${be.Screen} = ${dl({props:f`style, className`},f`const fallbackRef = ${w.fn(f`${or}<HTMLElement>`,f`null`)}`,f`const ${be.refBinding} = ${be.ref} ?? fallbackRef`,T?f`const navigate = ${w.fn(S.addImport("framer",{exportSpecifier:"usePrototypeNavigate"}),{preload:f`preload`})}`:void 0,N&&f`const { ${be.activeVariantCallback}, ${be.delay} } = ${w.fn(S.addImport("framer",{exportSpecifier:"useActiveVariantCallback"}))}`,...m.events.handlers.values(),f`const ${be.sharedStyleClassNames} = ${Te.map(A=>f`${A}.className`)}`,...m.declarations.component.list(),R&&M.linesFrom(m.events.keyBindHooks),C&&w.fn(S.addImport("framer",{exportSpecifier:"useOnAppear"}),C),Z.size>0&&f`const { ${f.listFrom(Z)} } = {}`,f`return ${y}`)}`,f`const ${be.css} = ${[...m.css.conditionalRules(e),rn,...$t(Ft),...Te.map(A=>f`...${A}.css`)]}`,nn(St,e,be.Screen,be.css,{framerIntrinsicHeight:I.height,framerIntrinsicWidth:I.width,framerSupportedLayoutWidth:"fixed",framerSupportedLayoutHeight:"fixed",framerScreen:void 0,framerDisplayContentsDiv:!1},S),f`${St}.displayName = ${`Screens/${n.name?.trim()||"Generated Component"}`};`,f`${St}.defaultProps = ${{width:I.width,height:I.height}};`,An({componentName:St,fontObjects:V,fontReferences:P,imports:S,declarations:m.declarations.font,sharedFontArrays:$}));return[{type:"screen",revision:void 0,source:new w(M.sections(M.linesFrom(S.statements),j)),artifacts:{assets:m.assets.keys,packageDependencies:m.packages.dependencies,metrics:m.metrics.get()}}]});function dl({props:o},...t){return new w(M.lines(f`React.forwardRef(function({ ${o}, ...${be.restProps} }, ${be.ref}) {`,...t,f`});`))}var Za="{serializationId}";function Ya(o){return`.${Za} ${o}`}var ec=ie(async(o,{treeStore:t},{serializationId:e})=>{let r=new wt,n=new tn(r),i=new fn(n),s=o.getFontsForCodeGeneration(),a=o.moduleSourceRevision,c=Di(o);for(let T of s)i.addFontObjectBySelector(T,c);let d=[],p=new Zr,l={colors:p};for(let{selectors:T,declarations:N}of o.getCSS(l)){let C=T.map(Ya);d.push(`${C.join(", ")} { ${N} }`)}let g=t.tree.getNodesWithTrait(o.cache.replicaInstances??[],is).filter(qi).sort((T,N)=>(N.breakpointWidth??0)-(T.breakpointWidth??0));for(let T=0;T<g.length;T++){let N=g[T];if(N===void 0)continue;let C=g[T+1],R=N.breakpointWidth-1,x=C?.breakpointWidth??0;for(let{selectors:V,declarations:P}of N.getCSS(l)){let $=`${V.map(Ya).join(", ")} { ${P} }`;d.push(`@media (max-width: ${R}px) and (min-width: ${x}px) { ${$} }`)}}let y=p.getWideGamutColorRules(`.${e}`);y.length&&d.push(`@supports (color: color(display-p3 1 1 1)) { ${y.join(" ")} }`);let m=d.map(T=>T.replaceAll(Za,e)),S=xr({fontObjects:i.fontObjects,fontReferences:i.fontReferences}),I=f.joinLines(f`import { fontStore } from "framer";`,f`fontStore.loadFonts(${s});`,...n.list(),f`export const fonts = ${S};`,f`export const css = ${m};`,f`export const className = ${e};`);return[{revision:a,type:"css",source:I,artifacts:{metrics:{nodes:d.length}}}]});function Bo(o){if(Ii(o))return{widthType:o.widthType,heightType:o.heightType,...$i(o)?{minHeight:o.minHeight,maxHeight:o.maxHeight,minWidth:o.minWidth,maxWidth:o.maxWidth}:_i}}function Oo(o,t){if(Pi(t))return{min:o.getRect(t).width}}var ll=new Set(Object.values(v).map(o=>F(o)));function ul(o,t){if(Bt(o)){let e=t.get(o.parentid);return!X(e)||!e.isLoaded()?null:e}return t.current(o)}var zo=ie(async(o,t,{serializationId:e,initialIntrinsicSize:r})=>{let{assetMap:n,engineChanges:i,modulesStore:s,treeStore:a,aiGenerationStore:c,measureNodes:d}=t,p=ve(o,a.tree)?o.moduleSourceRevision:void 0,l=ul(o,a.tree);h(l?.isLoaded(),"The scope node must be valid.");let g=Ks(l),y=Be(l)?l.baseVariantId:o.id,m=a.tree.get(y);h(m,"Must have a source node to serialize. This should be a primary variant.");let S={assetMap:n,engineChanges:i,modulesStore:s,treeStore:a},I=`Framer${o.id}`,T=new w(I),{jsx:N,ctx:C}=await pn(m,l,S,new Set(ll).add(I),e);h(N,"There must be JSX to serialize.");let R=C.imports,x=X(l),V=x?void 0:l.instanceIdentifier,P=await Bn(S.treeStore.tree,m,V,d,S.modulesStore,r),Z=Be(l)?l.getReplicaVariants():[],{variants:$,hook:xe}=C.preload.getHook(),{gestures:Te,breakpoints:De,classNames:Ft,sizes:St,appearEventMap:or}=Il(m,Z,C,S,$),j=Se(l)?[l.baseVariantId,...l.getTopLevelReplicaVariants().map(vn)]:[],A=j.length>1,re=!dr(Te),We=!dr(or),Me=!dr(De),ir=f`${R.addImport("react",{exportSpecifier:"*",importBinding:"React"})}.useId`,{mediaQueries:vt,sharedStyleImports:sr,sharedFontArrays:ke,css:ar}=Cl(e,C,Z,De,l),Yn=Ae.applyTransforms(N,Nl(l,C,bl(l,m,Z,vt,S.treeStore,C))),Ur=hl(l,t),Ho=L(l)?ma(l,Ur?.controlMap):new Set,bt={};for(let He of Ho){let Ut=ii(He,l.id);bt[He]=C.variables.create(Ut)}let{props:cr,types:Ar,propertyControls:Br,variableMap:Or}=bn(l,S,C,Hs(l),g,P),k=!Me&&f`const ${v.layoutDependency} = ${w.fn(C.declarations.file.dedupe("createLayoutDependency",f`(props, variants) => {${f.joinLines(f`if (props.layoutDependency) return variants.join('-') + props.layoutDependency`,f`return variants.join('-')`)}}`),f`props`,v.variants)}`,{cursors:E}=C.customCursors,J=R.addImport("react",{exportSpecifier:"useRef"}),Je=M.sections(re&&f`const ${v.enabledGestures} = ${Te};`,A&&`const ${v.cycleOrder} = ${F(j)};`,Me&&`const ${v.breakpoints} = ${F(vt)}`,Me&&`const ${v.isBrowser} = () => typeof document !== "undefined";`,x&&f`const ${v.variant} = undefined;`,x&&f`const ${v.breakpoints} = undefined;`,x&&f`const ${v.layoutId} = undefined;`,x&&f`const ${v.className} = undefined;`,x&&f`const ${v.style} = undefined;`,f`const ${v.serializationHash} = ${e}`,`const ${v.variantClassNames} = ${F(Ft)};`,!Me&&gl,...C.declarations.file.list(),`export interface Props extends React.HTMLAttributes<HTMLDivElement> { ${Ar} }`,`const ${v.Component} = ${pl(f`const fallbackRef = ${w.fn(f`${J}<HTMLElement>`,f`null`)}`,f`const ${v.refBinding} = ${v.ref} ?? fallbackRef`,f`const ${v.defaultLayoutId} = ${w.fn(ir)}`,`const { ${v.activeLocale}, ${v.setLocale} } = ${w.fn(R.addImport("framer",{exportSpecifier:"useLocaleInfo"}))}`,C.variables.shouldProvideLayoutDirection?f`const ${v.layoutDirection} = ${w.fn(R.addImport("framer",{exportSpecifier:"useLayoutDirection"}))}`:void 0,Se(l)||L(l)?f`const ${v.componentViewport} = ${w.fn(C.imports.addImport("framer",{exportSpecifier:"useComponentViewport"}))}`:void 0,vl({data:Ur,imports:R,variables:C.variables.variables}),cr,L(l)&&yl({webPageNodeId:o.id,metadataDependencies:bt,imports:R,bindings:C.bindings}),Me?f.joinLines(f`const [${v.baseVariant}, ${v.hydratedBaseVariant}] = ${w.fn(R.addImport("framer",{exportSpecifier:"useHydratedBreakpointVariants"}),v.variant,v.breakpoints,f`false`)};`,f`const ${v.gestureVariant} = undefined;`):fl(m.id,re,A,R),k,wl(C),...C.events.routeHandlers.values(),C.events.handlers.size>0&&f`const { ${v.activeVariantCallback}, ${v.delay} } = ${w.fn(R.addImport("framer",{exportSpecifier:"useActiveVariantCallback"}),Me?f`undefined`:v.baseVariant)}`,...C.events.handlers.values(),We&&w.fn(R.addImport("framer",{exportSpecifier:"useOnVariantChange"}),Me?v.hydratedBaseVariant:v.baseVariant,or),f`const ${v.sharedStyleClassNames} = ${sr.map(He=>f`${He}.className`)}`,...C.declarations.component.list(),E,xe?.(re?v.enabledGestures:f`undefined`),f`return (${Yn})`)}`,ar,nn(T,e,v.Component,v.css,ml(l,C,P,St,Or),R),`${I}.displayName = ${F(l.name?.trim()||"Generated Component")};`,`${I}.defaultProps = ${F({width:P.width,height:P.height})};`,Br&&w.fn(R.addImport("framer",{exportSpecifier:"addPropertyControls"}),T,new w(`${F(Br)} as any`)),An({componentName:T,fontObjects:C.fonts.fontObjects,fontReferences:C.fonts.fontReferences,imports:R,declarations:C.declarations.font,sharedFontArrays:ke})),[rt]=L(l)?await pa(l,t,{serializationId:e}):[];return gn([{type:g,revision:p,source:new w(M.sections(M.linesFrom(R.statements),Je)),artifacts:{packageDependencies:C.packages.dependencies,errors:C.errors.errors,assets:C.assets.keys,metrics:C.metrics.get(),kitSectionsStructure:c.cacheKitSectionsStructure(o.id,C.kitSectionsStructure.structure)}},rt,C.localizedValues.module(p)])});function fl(o,t,e,r){let n=le.fromEntries([[v.defaultVariant,o],[v.variant,v.variant],[v.variantClassNames,v.variantClassNames],[v.enabledGestures,t?v.enabledGestures:void 0],[v.cycleOrder,e?v.cycleOrder:void 0],[v.ref,v.refBinding]]),i=w.fn(r.addImport("framer",{exportSpecifier:"useVariantState"}),n),s=v.variants,a=v.baseVariant,c=f`setVariant`,d=v.gestureVariant,p=v.classNames,l=v.setGestureState,g=v.gestureHandlers,y=v.clearLoadingGesture,m=v.isLoading;return M.lines(f`const ${{variants:s,baseVariant:a,setVariant:c,gestureVariant:d,classNames:p,setGestureState:l,gestureHandlers:g,clearLoadingGesture:y,isLoading:m}} = ${i}`)}function pl(...o){return M.sections(f`React.forwardRef<HTMLDivElement, Props>(function(props, ${v.ref}) {`,...o,f`});`)}function ml(o,t,e,r,n){let{height:i,width:s}=e,a={propertyName:"variant",data:Object.fromEntries(Object.entries(r).map(([d,p])=>[d,Gi(p)]))},c={framerIntrinsicHeight:i,framerIntrinsicWidth:s,framerRootFontSize:Li(o)?o.getPrimaryVariant()?.rootFontSize:void 0,framerCanvasComponentVariantDetails:JSON.stringify(a),framerVariables:n&&JSON.stringify(n),framerImmutableVariables:!0,framerDisplayContentsDiv:!1,framerAutoSizeImages:!0,framerComponentViewportWidth:!0,framerColorSyntax:!0,framerVectorSets:t.vectorSets.annotation()};if(oe(o)){let d={},p=o.getBreakpointValues();for(let l in p){let g=t.treeStore.tree.get(l);d[l]={...p[l],canvasClassName:oc(l),minHeight:g?.height,viewportHeight:g?.viewportHeight,name:g?.name??void 0,width:g?.widthType===0?g?.width:void 0,rootFontSize:g?.rootFontSize??Ni}}c.framerHitTargets=t.hitTargets.annotation(),c.framerBreakpoints=JSON.stringify(d),c.framerDefaultVariant=o.baseVariantId,c.framerTrackingIds=t.trackingIds.annotation(),c.framerLayoutTemplate=""}else L(o)?(c.framerAcceptsLayoutTemplate=t.acceptsLayoutTemplate,c.framerTrackingIds=t.trackingIds.annotation(),c.framerScrollSections=t.elementIds.annotation(),c.framerResponsiveScreen=""):Se(o)?c.framerTrackingIds=t.trackingIds.annotation():X(o)?c.framerDesign="":Se(o)||(c.framerScreen="");return c}function hl(o,t){if(!L(o)||!di(o)||!Xi(t.treeStore.tree,o))return;let r=o.getVariableControlMap(t.treeStore.tree,de,de.activeBundleHash)??new Map;return{defaultCollectionAlias:Qs(o),identifier:o.dataIdentifier,controlMap:r}}var gl=M.lines("function addPropertyOverrides(overrides, ...variants) {","const nextOverrides = {}","variants?.forEach(variant => variant && Object.assign(nextOverrides, overrides[variant]))","return nextOverrides","}");function yl({webPageNodeId:o,metadataDependencies:t,imports:e,bindings:r}){let n=e.addImport(`../${ua(o).localId}`,{exportSpecifier:"default",importBinding:"metadataProvider"}),i=r.create("metadata"),s=e.addImport("framer",{exportSpecifier:"useMetadata"}),a=w.fn(n,t,v.activeLocale),c=Object.values(t).concat(v.activeLocale);return M.lines(f`const ${i} = React.useMemo(() => ${a}, ${c})`,w.fn(s,i))}function Sl(o){if(Ei(o))return{type:o.gesture,topLevel:o.replicaInfo.inheritsFrom}}function vl({data:o,imports:t,variables:e}){if(!o)return;let r=t.addImport("framer",{exportSpecifier:"useCurrentPathVariables"}),n=t.addImport("framer",{exportSpecifier:"NotFoundError"}),i=t.addImport("framer",{exportSpecifier:"useQueryData"}),s=t.addImport("framer",{exportSpecifier:"getWhereExpressionFromPathVariables"}),a=new Set;for(let[m]of o.controlMap){let S=ts(m,void 0,!0);e.has(S)&&a.add(m)}function c(m){let S=t.addModuleImport(m);return h(S,"Can't import collection"),S}let d=new Set,p=Ys(o.controlMap,a,d,o.defaultCollectionAlias,c),l=Xs(o.identifier,o.controlMap,d,o.defaultCollectionAlias,c),g=f`const [${v.currentRouteData}] = ${w.fn(i,{from:l,select:p,where:w.fn(s,v.currentPathVariables,o.defaultCollectionAlias)})};`;return f.joinLines(f`const ${v.currentPathVariables} = ${w.fn(r)};`,g,f`const ${v.getFromCurrentRouteData} = (key) => {
            if (!${v.currentRouteData}) throw new ${n}(\`No data matches path variables: \${JSON.stringify(${v.currentPathVariables})}\`);
            return ${v.currentRouteData}[key];
        };`)}function oc(o){return`framer-${ct(o)}-override`}function tc(o,t){if(!(!Ti(o)||wi(o)&&!o.fillEnabled))return o.fillType==="color"&&si(o.fillColor)?t(o.fillColor,o,"fill"):Wi(o)}function rc(o){if(!Ri(o))return;let t=o.rootFontSize/16*100;return xi(t,"%")}function nc(o,t){return we(o)?o:w.fn(t.imports.addImport("framer",{exportSpecifier:"safeCSSValue"}),o)}function bl(o,t,e,r,n,i){if(!oe(o)&&!L(o))return;let s=Gs(n,i.declarations,i.variables,i.valueTransforms),a=oe(o)?":root":"html",c=`${a} body`,d=rc(t),p=tc(t,s)??"none",l=[Ue`${c} { background: ${nc(p,i)}; }`];we(d)&&l.push(`${a} { font-size: ${d}; }`);for(let g of e){let y=r[g.id];if(y){let m=tc(g,s)??"none",S=rc(g),I=[];if(go(p,m)||I.push(Ue`${c} { background: ${nc(m,i)}; }`),go(d,S)||I.push(`${a} { font-size: ${S}; }`),I.length===0)continue;l.push(Ue`@media ${y} { ${Ue.join(I," ")} }`)}}return Ue.join(l," ")}function Cl(o,t,e,r,n){let i=us(ls(r)),s=[],a=new Map;if(oe(n)){let S=n.getPrimaryVariant(),I={marginBottom:co(S,t)};t.css.createRule(`[${ho}="true"] > #overlay`,so(I));for(let T of e){let N={marginBottom:co(T,t)},C=As(N,I);!C||dr(C)||t.css.createRule(`[${ho}="true"] > #overlay`,so(C),T.id)}}_t(t.css.get(),a);let c={},d={};for(let S of e){let I=i[S.id];if(I){let T=new Map;if(_t(t.css.get(S.id),T),!T.size)continue;oe(n)?(c[S.id]=$t(T),d[S.id]=`.${oc(S.id)}`):s.push(Ue`@media ${I} { ${Ue.join($t(T)," ")}}`)}else _t(t.css.get(S.id),a)}let p=[],l=[];for(let S of t.css.sharedStyleIds){let I=K("css",S),T=t.imports.addImport(`../${I}`,{exportSpecifier:"*",importBinding:"sharedStyle"});l.push(T),p.push(w.fn(t.imports.addImport("framer",{exportSpecifier:"getFontsFromSharedStyle"}),f`${T}.fonts`))}let g;for(let S of t.componentPresetIds){g??=t.imports.addImport(`../${ln}`,{exportSpecifier:"*",importBinding:"componentPresets"});let I=f`${g}.fonts?.[${S}]`;p.push(f`(${I} ? ${w.fn(t.imports.addImport("framer",{exportSpecifier:"getFontsFromComponentPreset"}),I)} : [])`)}let y=[rn,...$t(a),...l.map(S=>f`...${S}.css`),...t.css.conditionalRules(o)],m=Tl(n,t,y,s,c,d,i);return{sharedStyleImports:l,sharedFontArrays:p,mediaQueries:i,css:f`const ${v.css} = ${m}`}}function Tl(o,t,e,r,n,i,s){if(Se(o)||X(o))return e;if(L(o))return[...e,...r];if(oe(o)){let a=t.declarations.file.dedupe("breakpointRules",n),c=t.declarations.file.dedupe("breakpointKeys",f`Object.keys(${a})`),d=t.declarations.file.dedupe("selectors",i),p=t.declarations.file.dedupe("rules",e),l=t.declarations.file.dedupe("mediaQueries",s),g=t.bindings.create("target"),y=t.bindings.create("query"),m=t.bindings.create("selector"),S=t.bindings.create("rule"),I=t.imports.addImport("framer",{exportSpecifier:"RenderTarget"});return f`(target) => {${f.joinLines(f`const isStaticRenderer = ${g} === ${I}.canvas || ${g} === ${I}.export`,f`if (!isStaticRenderer) {${f.joinLines(f`return [...${p}, ...${c}.map(key => {${f.joinLines(f`const ${y} = ${l}[key]`,f`return ${Ue`@media ${y} { ${f`${a}[key].join(" ")`} }`}`)}})]`)}}`,f`return [...${p}, ...${c}.flatMap(key => {${f.joinLines(f`const ${m} = ${d}[key]`,f`return ${a}[key].map(${S} => ${Ue`${m} {${S}}`})`)}})]`)}}`}ye(o)}function wl(o){if(o.events.needsPathVariables)return`const ${Vs} = React.useContext(${o.imports.addImport("framer",{exportSpecifier:"PathVariablesContext"})});`}function Il(o,t,e,r,n){let i=Bo(o);h(i,"The primary variant should have a default size as it must be a FrameNode.");let s={default:i},a={[o.id]:`framer-v-${ct(o.id)}`},c={},d={},p={},l=Oo(r.treeStore.tree,o);l&&(p[o.id]=l);let g=e.events.variantOnAppearId.get(o.id),y={};!O(g)&&!w.isUndefined(g)&&(y.default=g);for(let m of t){e.metrics.count("variants");let S=Sl(m);if(S){let R=c[S.topLevel]??{};R[S.type]=S.type==="loading"?n?.has(S.topLevel):!0,c[S.topLevel]=R,d[S.topLevel]=[...d[S.topLevel]??[],m.id]}else a[m.id]=`framer-v-${ct(m.id)}`;let I=Bo(m);I&&(s[m.id]=I);let T=Oo(r.treeStore.tree,m);T&&(p[m.id]=T);let N=e.events.variantOnAppearId.get(m.id),C=F(y[m.replicaInfo.inheritsFrom??""]??g);!O(N)&&F(N)!==C&&(y[m.id]=N)}return{gestures:c,breakpoints:p,classNames:a,sizes:s,appearEventMap:y}}function Nl(o,t,e){let r=[];if((oe(o)||L(o))&&e){let i=t.declarations.file.dedupe("HTMLStyle",f`({value}) => {${f.joinLines(f`const onCanvas = ${w.fn(t.imports.addImport("framer",{exportSpecifier:"useIsOnFramerCanvas"}))}`,f`if (onCanvas) return null`,f`return ${Ae.tag(f`style`,new le({"data-framer-html-style":"",dangerouslySetInnerHTML:{__html:f`value`}}))}`)}}`);r.push(s=>Ae`${f.joinLines(Ae.tag(i,new le({value:e})),s)}`)}if(Se(o)){let i=t.imports.addImport("react",{exportSpecifier:"*",importBinding:"React"}),s=t.imports.addImport("framer-motion",{exportSpecifier:"motion.create"}),a=t.declarations.file.dedupe("Variants",w.fn(s,f`${i}.Fragment`));r.push(c=>Ae.tag(a,new le({initial:!1,animate:v.variants}),c))}if(L(o)||oe(o)||X(o)){let i=new le({id:oe(o)?hi:mi});r.push(s=>Ae`${f.joinLines(s,Ae.tag(f`div`,i))}`)}let n=t.imports.addImport("framer-motion",{exportSpecifier:"LayoutGroup"});if(r.push(i=>Ae.tag(n,new le({id:f`layoutId ?? ${v.defaultLayoutId}`}),i)),L(o)||oe(o)){let i=t.imports.addImport("framer",{exportSpecifier:"GeneratedComponentContext"});r.push(s=>Ae.tag(f`${i}.Provider`,new le({value:{primaryVariantId:o.baseVariantId,variantClassNames:v.variantClassNames,isLayoutTemplate:oe(o)?!0:void 0}}),s))}return r}function ic(){let o=new w("5e8f756");return f`// Generated by Framer (${o})`}var sc={ref:v.ref,restProps:v.restProps,style:v.style,className:v.className,layoutId:v.layoutId},_o=f`css`,Dr=f`Icon`,On=f`Component`,kr=f`Props`,Rl=[...Object.values(sc),_o,Dr,On,kr].map(o=>F(o)),ac=ie(async(o,t,e)=>{let{serializationId:r}=e,{assetMap:n,engineChanges:i,modulesStore:s,treeStore:a,vectorsStore:c}=t,d=a.tree.getScopeNodeFor(o);h(Q(d),"Vector set item must be in a VectorSetNode.");let p=a.tree.get(o.id);h(p,"Must have a source node to serialize");let l={assetMap:n,engineChanges:i,modulesStore:s,treeStore:a},{ctx:g,jsx:y,svg:m,type:S}=ns(p,d,l,r,Rl),I=Ve("vectorSet",d.id,"default").localId,T=s.getPersistedModuleByLocalId(I);h(T,"VectorSet must be persisted.");let N=a.tree.getRect(o),{propertyControls:C,variableMap:R,types:x,props:V}=bn(d,l,g,"VectorSet","vector",N),P=xl(g),Z={name:p.name??"Vector",empty:Dl(p)?!0:void 0,color:P,set:{localId:I,id:d.id,moduleId:T.id}},$=g.imports.addImport("react",{exportSpecifier:"*",importBinding:"React"}),xe=g.imports.addImport("framer",{exportSpecifier:"withCSS"}),Te=kl[S],De=M.lines(...g.declarations.file.list(),f`interface ${kr} extends ${$}.HTMLAttributes<${$}.${Te}> { ${x??f``} }`,f`const ${On}: ${$}.ComponentType<${kr}> = ${$}.forwardRef<${$}.${Te}, ${kr}>(function(props, ${sc.ref}) {${f.joinLines(V,...g.declarations.component.list(),f`return (${y})`)}})`,f`const ${_o} = ${g.css.rules}`,dt("This is a generated Framer component.",{framerIntrinsicWidth:N.width,framerIntrinsicHeight:N.height,framerSupportedLayoutWidth:"any-prefer-fixed",framerSupportedLayoutHeight:"any-prefer-fixed",framerVariables:R&&JSON.stringify(R),framerImmutableVariables:!0,framerVector:JSON.stringify(Z),framerDisableUnlink:Ia.has(Z.set.moduleId)?!0:void 0}),f`const ${Dr}: ${$}.ComponentType<${kr}> = ${w.fn(xe,On,_o,r)} as typeof ${On};`,f`${Dr}.displayName = ${p.name??"Vector"};`,f`export default ${Dr}`,C&&w.fn(g.imports.addImport("framer",{exportSpecifier:"addPropertyControls"}),Dr,new w(`${F(C)} as any`)));return c.cache(o.id,{svg:F(m),color:P}),gn([{revision:p.moduleSourceRevision,type:"vector",source:new w(M.sections(M.linesFrom(g.imports.statements),De)),artifacts:{files:[{name:"icon.svg",type:"svgIcon",content:F(m)}]}}])});function xl(o){if(o.colors.uniqueColorCount!==1)return;let t=o.colors.singleColor;if(t)return{type:"static",value:t};let e=o.colors.singleVariableColor;if(e)return{type:"variable",value:ct(e)}}function Dl(o){return!o.children||o.children.length===0?!0:o.children.every(t=>t.visible===!1)}var kl={0:f`HTMLImageElement`,1:f`HTMLDivElement`,3:f`HTMLSVGElement`,2:f`HTMLSVGElement`};var cc=ie(async(o,{modulesStore:t},e)=>{let r=[];for(let s of o.getVectorSetItems()){let a=Ve("vector",s.id,"default").localId,c=t.getPersistedModuleByLocalId(a);c&&r.push({id:s.id,name:s.name??"Vector",moduleId:c.id,saveId:e.includeVectorSetSaveIds?c.saveId:void 0})}let n={framerVectorSet:JSON.stringify({name:o.name??"Set",items:r})},i=new w(M.lines(dt("This is a generated Framer component.",n),f`const VectorSet: React.ComponentType<unknown> = function VectorSet() { return null; };`,f`export default VectorSet;`));return[{revision:o.moduleSourceRevision,type:"vectorSet",source:i}]});function Lt(o,t){if(Se(o,!0))return["canvasComponent"];if(L(o,!0))return["screen","webPageMetadata"];if(oe(o,!0))return["layoutTemplate"];if(H(t.get(o.parentid)))return["screen"];if(Q(o,!0))return["vectorSet"];if(H(o,!0))return["prototype"];if(Pe(o,!0))throw new Error("Unhandled scope node type");if(G(o))return["collection","draftCollection"];if(It(o))return["css"];if(Fe(o))return["componentPresets"];if(fi(o)&&Q(t.getScopeNodeFor(o)))return["vector"];if(Ie(o))return["siteMetadata"];if(ue(o))return["vector"];if(X(t.get(o.parentid)))return["design"];throw new Error(`Unsupported component node: ${o.__class} ${o.id}`)}function uc(o){return Math.ceil(o/Math.ceil(o/100))}var dc=class{constructor(t,e){u(this,"status",null);u(this,"results");u(this,"reportProgress");u(this,"onDone");this.reportProgress=t,this.onDone=e}async import(t,e,r){this.status="importing",this.results={scopeId:e,vectors:[],targetLayout:r};let n=r?{left:r.x+r.width*2,top:r.y}:{left:0,top:0};for(let i=0;i<t.length;i++){let s=t[i];if(!s)continue;let a=await Pl(s,e,n);if(this.status!=="importing")return;a&&this.results.vectors.push(a),this.reportProgress?.({status:this.status,finishedCount:i+1})}await this.done()}cancel(){this.status="canceled"}async done(){this.results&&await this.onDone?.(this.results),this.status="done"}},lc="run-svgo",El=1e6;async function Pl(o,t,e){if(o.size>El){mr({type:"add",variant:"error",key:lc,text:"Your SVG is too large to upload. You may need to convert to a different format, such as PNG.",icon:"error",duration:5e3});return}try{let r=await o.text(),n=da(r),i=Ml(o.name),s=xs(r,an.createEmpty,n);return s?(s.parentid=t,s.set({name:i,isVectorSetItem:!0,...e}),{node:s,size:n}):void 0}catch(r){console.error("Failed to insert SVG:",r),mr({type:"add",variant:"error",key:lc,text:"Failed to insert SVG",icon:"error"});return}}var Ll=/[_-]/gu;function Ml(o){let[t]=ri(o);return oi(t.replace(Ll," "))}var Vl=2;function $o(o){if(L(o))return Vl}function Dv(o,t,e){if(t.type==="siteMetadata"||t.type==="webPageMetadata")return!0;let r=Lt(o,e).includes(t.type);if(h(o.id===t.name&&r,"sourceNode and module must match"),Sn(t))return!1;let n=$o(o);if(n===void 0)return!0;let i=t.metadata.codeGenVersion;return B(i)&&i>=n}var jo=1;function Fl(o){let t=o.metadata.compatibleTextStyleVersion;return B(t)?t:0}function Lv(o){return Fl(o)<jo}var mt=Tt(Hr());function pc(o,t){if(Se(o))return"Smart Component";if(L(o))return"web page";if(H(t.get(o.parentid)))return"prototype screen";if(H(o))return"prototype";if(G(o))return"CMS collection"}function mc(o,t){return L(t)?ha(o,t):t.name??void 0}function hc(o,t="module",e){let r="is too large and will not update";mr({type:"add",variant:"warning",text:e?(0,mt.jsxs)(mt.Fragment,{children:[(0,mt.jsxs)(cn,{children:["The ",t]})," \u201C",e,"\u201D ",(0,mt.jsx)(cn,{children:r})]}):(0,mt.jsxs)(cn,{children:["A ",t," ",r]}),key:`module-too-large-${o}`,duration:1/0,extraAction:{title:"Learn more",onClick(){Xe("ui_interaction",{page:"module-too-large-toast",id:"learn_more"}),Ns("https://www.framer.com/help/articles/how-to-fix-module-too-large-warning/")}}});let i=`module-too-large-toast-${t.split(" ").join("-")}`;Xe("ui_impression",{page:i})}var zn=class{constructor(){u(this,"queue",[]);u(this,"synchronize",async()=>{for(let t of this.snapshot())await t.task()})}snapshot(t){return this.queue=this.queue.filter(t??(e=>!e.promise.isResolved())),Array.from(this.queue)}get size(){return this.snapshot().length}async request(t,e){let r=new Zo;this.queue.push({id:e?.id,promise:r,task:()=>(r.state!=="initial"||(r.pending(),(t()??Promise.resolve()).finally(()=>r.resolve())),r)}),e?.synchronize!==!1&&await this.synchronize()}};function _n(o,t){if(!Si(o)||!t.isGroundNode(o))return!1;let e=t.get(o.parentid);return!!(e&&H(e))}function Ze(o){if(Ie(o))return la.localIdName;switch(o.id){case ps:return"componentPresets";default:return o.id}}function Er(o,t){return Lt(o,t).map(r=>K(r,Ze(o)))}function Pr(o,t,e){return o?Er(o,t).every(r=>!O(e.getModuleEntryByLocalId(r))):!1}function gc(o,t){if(!ht(o,t)||X(o))return!1;if(!Pe(o)){let e=t.getScopeNodeFor(o);if(X(e))return!1}return!0}function ht(o,t){if(Ie(o))return!0;if(!t.has(o.id))return!1;if(Be(o))return!0;if(ci(o))return!1;if(G(o)||It(o)||Fe(o)||Q(o))return!0;if(ue(o)){let e=t.get(o.parentid);return Q(e)}if(X(o))return!1;if(t.isGroundNode(o)&&Bt(o)){let e=t.getScopeNodeFor(o);if(X(e))return!0}return!!(H(o)||_n(o,t))}var Ul=1e4,Al=1e3,Lr=D("CodeGenerationStore");function Bl(o){return!(G(o)||H(o)||Ie(o)||Bt(o)||Fe(o)||Q(o))}function Ol(o,t){if(!ue(t))return;let e=o.getScopeNodeFor(t);return h(Q(e),"Vector set item must be in a VectorSetNode."),e.variables}function zl(o){let t=o.name?.trim();return t||(Ji(o)?"Text":ds(o,o.__class))}function yc(o,t,e,r,n){let i={},s=zl(t);i.metadata||(i.metadata={});let a=[...n?.files??[]];Bl(t)&&a.push({name:"tree.json",type:"nodeTree",content:JSON.stringify(Object.assign(t.toJS(),{__treeSerializationVersion:o.serializationVersion,__vectorSetVariables:Ol(o,t)}))});let c=$o(t);c&&(i.metadata.codeGenVersion=c);let d=n?.packageDependencies;return d&&(i.metadata.packageDependencies=Array.from(d)),Sa(e)&&(i.metadata.compatibleCmsVersion=ya),pi(t)&&(i.metadata.compatibleTextStyleVersion=jo),i.assets=n?.assets?Array.from(n.assets):[],{...i,title:s,files:a,errors:n?.errors??[],type:e,name:r}}async function _l(o,t,e,r){if(o&&t instanceof ei&&t.code===1001){let n=ss(o,s=>e.treeIndex.getScopeIdFor(s))??void 0,i=new as({type:"CodeGeneration",nodeId:Be(o)?o.baseVariantId:o.id,reason:"FileTooLarge",sourceNodeId:o.id,scopeId:n});hc(o.id,pc(o,e.tree),mc(e.tree,o)),await r(s=>{if(s.isViewOnly)return;s.lineage.setEditReason("codegeneration");let a=s.ensureErrorListNode();Lr.debug("Writing ClientFileTooLarge error to tree for",o.id),s.insertNode(i,a.id)})}else Lr.reportError(t)}var Ce,Mr,$n=class{constructor(t,e,r,n){this.treeStore=t;this.modulesStore=e;this.runWhenIdle=r;this.scheduleDocumentUpdateIgnoringUndo=n;ne(this,Ce,new zn);ne(this,Mr,new Wr({delay:Ul,task:()=>this.runWhenIdle(()=>void b(this,Ce).synchronize())}));u(this,"process",b(this,Ce).synchronize);u(this,"changeScope",()=>b(this,Mr).debounce(Al));u(this,"isIdle",()=>b(this,Ce).size===0);u(this,"isBlocking",()=>b(this,Ce).snapshot().some(t=>t.promise.state==="pending"))}enqueue(t,e){b(this,Ce).snapshot(s=>s.promise.isResolved()?!1:s.id===t?s.promise.state!=="initial":!0);let r=this.treeStore.tree.get(t);if(!r||!gc(r,this.treeStore.tree))return;let n=Ze(r),i={};for(let{type:s,artifacts:a}of e){let c=yc(this.treeStore.tree,r,s,n,a);i[K(s,n)]=c}b(this,Ce).request(async()=>{try{Lr.debug("Persisting transient modules for",t),await this.modulesStore.upsertBatch(i)}catch(s){await _l(r,s,this.treeStore,this.scheduleDocumentUpdateIgnoringUndo)}},{id:t,synchronize:!1})}async persist(t,e,r){let n=this.treeStore.tree.get(t);if(n)return this.enqueue(t,e),r?b(this,Mr).debounce():(await b(this,Ce).synchronize(),Er(n,this.treeStore.tree).map(i=>this.modulesStore.getPersistedModuleByLocalId(i)))}async persistBatch(t){let e={},r="batch";for(let n in t){let i=this.treeStore.tree.get(n),s=t[n];if(!i||!s)continue;let a=Ze(i),c=new Set;for(let{type:d,artifacts:p}of s){let l=K(d,a);h(!c.has(l),"Duplicate local module id",l),c.add(l),e[l]=yc(this.treeStore.tree,i,d,a,p),r+=`-${l}`}}b(this,Ce).snapshot(n=>n.promise.isResolved()?!1:n.id===r?n.promise.state!=="initial":!0),await b(this,Ce).request(async()=>{Lr.debug("Persisting transient modules for batch: ",r);try{await this.modulesStore.upsertBatch(e)}catch(n){Lr.reportError(n)}},{id:r,synchronize:!0})}get size(){return b(this,Ce).size}};Ce=new WeakMap,Mr=new WeakMap;var $l=()=>({stylePresets:[],componentPresets:[],collections:[],smartComponents:[],screens:[],prototypes:[],webpages:[],metadata:[],layoutTemplates:[]}),U=D("CodeGenerationStore");var jl=500,vc=1500,ql=6e4;function Wl(o){for(let t in o.to)if(t in gs||t in hs||t in fs)return!0;return!1}function Jl(o){return Q(o)?jl:vc}var gt,W,et,Zt,Vr,er,tr,te,jn,bc,Sc=class extends Xr{constructor(e,r,n,i,s,a,c,d,p,l,g,y=new Map){super();this.scheduler=e;this.treeStore=r;this.modulesStore=n;this.vectorsStore=i;this.aiGenerationStore=s;this.assetMap=a;this.timeline=c;this.engineChanges=d;this.scheduleDocumentUpdateIgnoringUndo=p;this.updateTreeCache=l;this.measureNodes=g;ne(this,jn);ne(this,gt,new Set);ne(this,W);ne(this,et,new Map);ne(this,Zt);ne(this,Vr,new Wr({delay:vc,maxDelay:ql,task:()=>this.scheduler.runWhenIdle(()=>{this.generateAndUpdateQueuedComponents()})}));ne(this,er,new Map);ne(this,tr);u(this,"testing",{setComponentGenerationQueue:e=>{Ge(this,W,e)},flushQueuedCallbacks:()=>{b(this,et).forEach(e=>e.forEach(r=>r()))},generateAndUpdateQueuedComponents:e=>this.generateAndUpdateQueuedComponents(e),setSerializationId:e=>{Ge(this,tr,e)},setModulesStore:e=>{Object.assign(this,{modulesStore:e}),Object.assign(this.persistence,{modulesStore:e})},waitForProcessing:async e=>{await this.serialization.promise(e)}});u(this,"persistence");u(this,"moduleTypeOrder",{localization:0,webPageMetadata:1,siteMetadata:2,collection:3,draftCollection:4,css:5,componentPresets:6,vector:7,vectorSet:8,canvasComponent:9,screen:10,["prototype"]:11,codeFile:12,config:13,layoutTemplate:14,design:15,kit:16});ne(this,te,new Map);u(this,"serialization",{idle:async()=>{let e=[];for(let r of b(this,te).keys())e.push(this.serialization.promise(r)?.then(()=>this.untilCompiled(r)));await Promise.all(e)},isIdle:()=>b(this,te).size===0,prepare:e=>{b(this,W).delete(e);let r=b(this,te).get(e)??jr();b(this,te).set(e,r)},cancel:e=>{b(this,W).delete(e),b(this,te).get(e)?.resolve(),b(this,te).delete(e)},preparing:e=>b(this,te).has(e),promise:e=>b(this,te).get(e),commit:async(e,r,n)=>{let i=()=>{b(this,te).get(e.id)?.reject(),b(this,te).delete(e.id)};try{let s=await Ko(this,jn,bc).call(this,e,r,n);return s||i(),s}catch(s){throw U.reportError(s),i(),s}}});Ge(this,W,y),Ge(this,Zt,this.timeline.openNodeChangesReader()),this.persistence=new $n(this.treeStore,this.modulesStore,m=>this.scheduler.runWhenIdle(m),m=>this.scheduleDocumentUpdateIgnoringUndo(m)),Aa(()=>{if(ot.isTest||this.treeStore.tree.isViewOnly)return!1;if(this.hasBlockingUpdates()){if(U.debug("Showing Unsaved Changes dialog (generation queue #: ",b(this,W).size,", component ids to generate: ",[...b(this,W).keys()],")"),!ot.isTest){let m=this.getMetrics();m.paused>1?U.reportError("Tab closed with paused code generations",m):(m.persisting>5||m.serializing>5||m.queue>5)&&U.reportError("Tab closed with multiple code generations in progress",m)}return b(this,gt).clear(),this.generateAndUpdateQueuedComponents().then(()=>{this.persistence.process()}).catch(m=>U.reportError(m)),!0}return!1}),window.addEventListener("blur",async()=>{try{await this.generateAndPersistAllQueuedComponents()}catch(m){U.reportError(m)}})}isIdle(){return b(this,W).size===0&&this.serialization.isIdle()&&this.persistence.isIdle()}getMetrics(){return{queue:b(this,W).size,paused:b(this,gt).size,serializing:b(this,te).size,persisting:this.persistence.size}}documentDidLoad(){b(this,W).clear(),b(this,et).clear(),b(this,er).clear()}telemetrySession(e){let r=b(this,er).get(e);if(r)return r;let n=this.treeStore.tree.get(e);h(n,"TelemetrySession: source node must exist");let i=new Pn(n);return b(this,er).set(e,i),i}getSerializationId(){return b(this,tr)?`framer-${b(this,tr)}`:`framer-${Us(5)}`}async generateAndPersistAllQueuedComponents(){await this.ensureSiteMetadataModule(),await this.generateAndUpdateQueuedComponents(),await this.serialization.idle(),await this.persistence.process()}debugGetComponentSourceNodes(){let e=$l();h(!1,"This method should only be used in tests.");for(let{node:r,skipChildren:n}of this.treeStore.tree.root.walkWithSkipChildren())L(r)?(e.webpages.push(r),e.metadata.push(r),n()):Se(r)?(e.smartComponents.push(r),n()):G(r)?(e.collections.push(r),n()):It(r)?(e.stylePresets.push(r),n()):Fe(r)?e.componentPresets.push(r):_n(r,this.treeStore.tree)?(e.screens.push(r),n()):H(r)?e.prototypes.push(r):Ie(r)?e.metadata.push(r):oe(r)&&e.layoutTemplates.push(r);return e}postProcess(e,r,n){if(!this.treeStore.tree.isViewOnly){if(n){b(this,Zt).clear();return}this.ingestChanges(e),b(this,Vr).debounce(Jl(r))}}ingestChanges(e){for(let[r,n]of b(this,Zt).read()){if(n.length===0||n.every(s=>s.ignoreInCodeGeneration))continue;let i=e.get(r);if(i){if(ve(i,this.treeStore.tree)){ji(i,n)&&this.addChangeToQueue(i);continue}if(Ie(i)){if(!n.some(Wl))continue;this.addChangeToQueue(i)}else if(H(i))this.addChangeToQueue(i);else{let s=this.treeStore.treeIndex.getGroundNodeIdFor(r),a=e.get(s);if(!a||at(a))continue;let c=e.getScopeNodeFor(a);if(!H(c))continue;this.queueCanvasPageNodesFollowingLinks(e,a)}}}}queueCanvasPageNodesFollowingLinks(e,r){if(this.addChangeToQueue(r),!(!r.cache.links||r.cache.links.size===0))for(let n of r.cache.links){let i=this.treeStore.treeIndex.getGroundNodeIdFor(n),s=e.get(i);!s||at(s)||this.queueCanvasPageNodesFollowingLinks(e,s)}}changeScope(){this.treeStore.tree.isViewOnly||ot.isTest||this.isIdle()||this.serialization.idle().then(()=>this.generateAndUpdateQueuedComponents()).then(()=>{if(!Ke.isOn("prioritizedModuleEvaluation")){this.persistence.process();return}this.persistence.isIdle()||this.persistence.changeScope()}).catch(e=>U.reportError(e))}async createVectorSet(e,r){let n=e[0];if(!n)return;let i=this.treeStore.tree.getScopeNodeFor(n);h(Q(i),"VectorSet: VectorSetNode must exist.");let s=performance.now(),a=await this.batchSerializeVectors(e,r);if(!a)return;let c={},d=0,p=Object.keys(a).length,l=uc(p),g=[];for(let y in a){let m=a[y];m&&(c[y]=m,d++,!(d%l!==0&&d!==p)&&(g.push(c),c={}))}for(let y=0;y<g.length;y++){let m=g[y];m&&(await this.persistence.persistBatch(m),r?.("persisting",y))}await this.forceComponentUpdate(i.id),U.debug("createVectorSet: Spent ",performance.now()-s,"ms creating a new vector set.")}async createModuleFromComponentSource(e,r){if(h(!this.treeStore.tree.isViewOnly,"CodeGenerationStore: viewers cannot create smart components or web pages."),h(ht(e,this.treeStore.tree),"CodeGenerationStore: componentSourceNode must be a valid component source."),Pr(e,this.treeStore.tree,this.modulesStore))return;U.debug("createModuleFromComponentSource",e.id),this.serialization.prepare(e.id);let i=await this.generateComponent(e.id,1,void 0,{intrinsicSize:r});if(!i)throw new Error("Code not generated");return await this.compileOutput(e,i),Er(e,this.treeStore.tree).map(s=>this.modulesStore.getPersistedModuleByLocalId(s))}revisionNodes(){let e=[];for(let r of this.treeStore.tree.root.children)ve(r,this.treeStore.tree)&&e.push(r),(Fe(r)||ui(r))&&r.children.forEach(n=>{ve(n,this.treeStore.tree)&&e.push(n),G(n)&&n.getUnsortedChildren().forEach(i=>{ve(i,this.treeStore.tree)&&e.push(i)})});return e}nodesWithStaleModules(e,r){let n=[],i=r?.ignoreHint??!1;for(let s of this.revisionNodes())ro(s)||e&&!e(s)||(!i&&s.moduleSourceRevisionHint!==s.moduleSourceRevisionCommittedHint||!this.allModulesAreAtRevision(s.id))&&n.push(s);return n}async updateComponent(e,r=0){h(!this.treeStore.tree.isViewOnly,"CodeGenerationStore: viewers cannot generate smart component or web page updates.");let n=this.treeStore.tree.get(e);if(!n||!ht(n,this.treeStore.tree))return!1;if(this.serialization.preparing(e))return await this.serialization.promise(e),await this.untilCompiled(e),!0;U.debug("Update component: ",e,", Condition: ",r);let i=b(this,W).get(e);this.serialization.prepare(e);let s=await this.generateComponent(e,r,i);return s?this.compileOutput(n,s):!1}async forceComponentUpdate(e){return h(!this.treeStore.tree.isViewOnly,"CodeGenerationStore: viewers cannot generate smart component or web page updates."),await this.updateComponent(e,2)?(await this.persistence.process(),!0):!1}queueCallbackAfterComponentCompilation(e,r){let n=b(this,et).get(e);n?n.push(r):b(this,et).set(e,[r])}untilCompiled(e){return new Promise(r=>{this.queueCallbackAfterComponentCompilation(e,r)})}calculateNewModuleRevision(e){let r=this.treeStore.tree.get(e);if(!r||!ve(r,this.treeStore.tree))return 1;if(!(!ko(this.treeStore.tree,e)||!this.treeStore.tree.has(e)))return Fa(e,this.scheduleDocumentUpdateIgnoringUndo)}allModulesAreAtRevision(e,r){let n=this.treeStore.tree.get(e);if(!n||!ve(n,this.treeStore.tree))return!1;let i=r??n.moduleSourceRevision;return Lt(n,this.treeStore.tree).every(s=>this.modulesStore.forType(s).getByStableName(Ze(n)).sourceRevision()===i)}async ensureDependencyModulesExist(){for(let e of this.revisionNodes()){if(!ht(e,this.treeStore.tree))return;if(!Pr(e,this.treeStore.tree,this.modulesStore))try{await this.updateComponent(e.id)}catch(r){U.error("Error updating dependency module",e.id,r)}}}async ensureSourceNode(e){let r=this.treeStore.tree.get(e),n=Pe(r)&&!r.isLoaded()?await r.load():r;if(n){if(L(n)&&await this.ensureSiteMetadataModule(),G(n)&&await this.ensureDependentModulesAreCompatibleWithCollection(n),ue(n)){let i=this.treeStore.tree.getScopeNodeFor(n);if(!Q(i))return;let s=K("vectorSet",i.id);if(this.modulesStore.getModuleEntryByLocalId(s))return;await this.createModuleFromComponentSource(i)}await this.ensureAllNodesWithLinksHaveLinkedScopesLoaded(n)}}async ensureSiteMetadataModule(){if(this.treeStore.tree.isViewOnly)return;let e=this.treeStore.tree.root;if(!Pr(e,this.treeStore.tree,this.modulesStore))return this.updateComponent(e.id)}hasBlockingUpdates(){if(b(this,W).size>0){for(let[e,r]of b(this,W))if(this.treeStore.tree.has(e)&&r)return!0}return!this.persistence.isIdle()||!this.serialization.isIdle()}async updateModules(e,r){let n=this.treeStore.tree.get(e),i=this.timeline.remoteTreeVersion;if(!n||!ht(n,this.treeStore.tree))return!1;let s=[];for(let{revision:c,source:d,type:p,artifacts:l}of r){let g={assets:l?.assets,submodules:l?.submodules,binaryAssets:l?.binaryAssets,preventCircularImports:p==="canvasComponent",telemetrySession:this.telemetrySession(e),treeVersion:i,sourceRevision:c,kitSectionsStructure:l?.kitSectionsStructure,svgIcon:l?.files?.find(S=>S.type==="svgIcon")?.content,stableName:!0},y=this.modulesStore.forType(p).getByStableName(Ze(n)),m=M.sections(ic(),d);y.currentSourceEquals(m,g)||s.push({localId:y.localId,source:m,options:g})}if(s.length===0)return!1;let a=await this.modulesStore.updateSources(s);return ue(n)&&this.vectorsStore.delete(e),L(n)&&this.aiGenerationStore.deleteKitSectionsStructure(e),a}allModulesExistForSources(e,r){let n=Ze(e);for(let i of r)if(!this.modulesStore.getPersistedModuleByLocalId(K(i.type,n)))return!1;return!0}async compileOutput(e,r){if(this.treeStore.tree.isViewOnly)return!1;let n=r.slice().sort((s,a)=>this.moduleTypeOrder[s.type]-this.moduleTypeOrder[a.type]);if(this.allModulesExistForSources(e,n))await this.updateModules(e.id,n);else for(let s of n){let a=await this.updateModules(e.id,[s]),c=Ze(e);!this.modulesStore.getPersistedModuleByLocalId(K(s.type,c))&&a&&await this.persistence.persist(e.id,[s])}return G(e)&&await this.ensureDependentModulesCanRenderCollectionColors(e),b(this,et).get(e.id)?.forEach(s=>s()),b(this,et).delete(e.id),this.persistence.persist(e.id,r,!0),!0}pauseCodeGeneration(e){return U.debug("Pausing code generation for",e),b(this,gt).add(e),()=>{U.debug("Resuming code generation for",e),b(this,gt).delete(e),b(this,Vr).debounce()}}async generateAndUpdateQueuedComponents(e){if(this.treeStore.tree.isViewOnly)return[];await this.ensureDependencyModulesExist();let r=[],n=new Map;for(let[s]of b(this,W)){if(b(this,gt).has(s)||this.serialization.preparing(s))continue;let a=this.treeStore.tree.get(s);if(!a||!ht(a,this.treeStore.tree)||e&&!Lt(a,this.treeStore.tree).includes(e)){b(this,W).delete(s);continue}if(this.serialization.prepare(s),ue(a)){let c=this.treeStore.tree.getScopeNodeFor(a);if(!c)continue;let d=n.get(c.id)??[];d.push(a),n.set(c.id,d)}else r.push(a)}let i=new Set;U.debug("Batch generating queued vector nodes");for(let s of n.values())try{let a=await this.batchSerializeVectors(s,void 0,i);for(let c in a)this.persistence.persist(c,a[c],!0)}catch{}U.debug("Generating queued components",{ids:r.map(vn)});for(let s of r)try{U.debug("Flushing queue of ",s.id);let a=await this.generateComponent(s.id,1);a&&(await this.compileOutput(s,a),i.add(s.id))}catch{}return Array.from(i)}async batchSerializeVectors(e,r,n){let i=e[0];if(!i)return;await this.ensureSourceNode(i.id),await this.ensureSourceCache(i.id),e.forEach(l=>this.serialization.prepare(l.id));let s=await Ua(e,this.scheduleDocumentUpdateIgnoringUndo);h(s,"VectorSet: newModuleRevisions must exist");let a={assetMap:this.assetMap,modulesStore:this.modulesStore,treeStore:this.treeStore,vectorsStore:this.vectorsStore,aiGenerationStore:this.aiGenerationStore,engineChanges:this.engineChanges,measureNodes:this.measureNodes},c=await Promise.all(e.map(async l=>{if(!s[l.id])return;let S=(await this.serializerForSourceNode(l)(l,a,{serializationId:this.getSerializationId()}))?.[0];return h(S,"VectorSet: source must exist.",l.id),this.serialization.promise(l.id)?.resolve(),b(this,te).delete(l.id),[l.id,S]})),d=0,p={};for(let l of c){if(!l)continue;let[g,y]=l;await this.updateModules(g,[y])&&(p[g]=[y],r?.("serializing",d),d++,n?.add(g))}return p}async createVersionedVectorSet(e){await this.generateAndPersistAllQueuedComponents();let r=await this.generateComponent(e.id,2,void 0,{includeVectorSetSaveIds:!0});return!r||!await this.compileOutput(e,r)?!1:(await this.persistence.process(),!0)}async generateComponent(e,r,n,i){U.debug("Ensure source node",e),await this.ensureSourceNode(e),U.debug("Ensure source cache",e),await this.ensureSourceCache(e);let s=await this.calculateNewModuleRevision(e),a=this.treeStore.tree.get(e);if(!a||!ht(a,this.treeStore.tree)||!this.shouldGenerateUnderCondition(r,a,s,n)){U.debug("Cancel serialization",e),this.serialization.cancel(e);return}let c=Be(a)?a.getPrimaryVariant():a;return U.debug("Serialize",e),this.serialization.commit(a,c,i)}shouldGenerateUnderCondition(e,r,n,i){let s=i??b(this,W).get(r.id);if(b(this,W).delete(r.id),!Pr(r,this.treeStore.tree,this.modulesStore))return!0;switch(e){case 2:return!0;case 1:return!O(n)||!this.allModulesAreAtRevision(r.id,n);case 0:return!O(n)&&!!s&&!this.allModulesAreAtRevision(r.id,n);default:ye(e)}}addChangeToQueue(e){if(!this.shouldSkipChange(e)){if(ue(e)&&this.vectorsStore.queue(e.id),ro(e)){let r=e.parentid;h(r,"Collection node has no parent"),b(this,W).set(r,!0);return}b(this,W).set(e.id,!0)}}serializerForSourceNode(e){return G(e)?Ja:Be(e)?zo:It(e)?ec:H(e)?Qa:Ie(e)?fa:Fe(e)?Ga:Q(e)?cc:ue(e)?ac:X(this.treeStore.tree.get(e.parentid))?zo:Xa}shouldSkipChange(e){if(at(e)){let r=nt(e.codeComponentIdentifier);if($r(r)&&r.type==="screen")return!0}return!1}async ensureSourceCache(e){let r=this.treeStore.tree.get(e);!r||r.update===r.cache.lastUpdate||await new Promise(n=>{this.scheduler.runBeforeNextFrame(()=>{Pe(r)&&r.update!==r.cache.lastUpdate&&this.updateTreeCache(r.id),n()})})}async ensureDependentModulesAreCompatibleWithCollection(e){let r=K("collection",e.id),n=this.modulesStore.getDependentsOfModule(r);!n||n.size===0||await Promise.all(Array.from(n).map(async i=>{let s=i,a=this.modulesStore.getPersistedModuleByLocalId(s);if(!(!a||!Sn(a)))return this.forceComponentUpdate(a.name)}))}async ensureDependentModulesCanRenderCollectionColors(e){let r=K("collection",e.id),n=this.modulesStore.getDependentsOfModule(r);if(!n||n.size===0)return;let i=this.modulesStore.forType("collection").getByStableName(e.id);i&&i.annotations(null,"default")?.framerColorSyntax&&await Promise.all(Array.from(n).map(async s=>{let[a,c]=Ki(s);a==="draftCollection"||this.modulesStore.forType(a).getByStableName(c)?.annotations(null,"default")?.framerColorSyntax||await this.forceComponentUpdate(c)}))}async ensureAllNodesWithLinksHaveLinkedScopesLoaded(e){let r=new Set;this.treeStore.tree.beginAllowPartialScopeAccess();for(let n of e.walkWithSkipChildren()){if(!cs(n.node))continue;let i=n.node.getLink();if(!ai(i))continue;let s=this.treeStore.tree.get(i.webPageId);!s||s.loaded||this.modulesStore.forType("screen").getByStableName(i.webPageId)?.annotations(null,"default")?.framerScrollSections||(r.add(s),n.skipChildren())}this.treeStore.tree.endAllowPartialScopeAccess(),await this.treeStore.tree.loadScopes(Array.from(r))}};gt=new WeakMap,W=new WeakMap,et=new WeakMap,Zt=new WeakMap,Vr=new WeakMap,er=new WeakMap,tr=new WeakMap,te=new WeakMap,jn=new WeakSet,bc=async function(e,r,n){if(!Ie(e)&&!this.treeStore.tree.has(r.id))return;let i=this.telemetrySession(e.id),s=i.start("synchronize"),a=performance.now();U.debug("Waiting for ModulesStore to be idle",{id:e.id}),await this.modulesStore.whenIdle();let c=performance.now()-a;U.debug("Waited",Math.round(c/1e3*100)/100,"seconds for ModulesStore to be idle",{id:e.id}),s.end();let d=e.draftOrCurrent();if(Pe(d)&&(!d.isLoaded()||d.loaded.children?.length===0))return;let p=i.start("serialize");G(e)&&Hl(e,this.treeStore,this);let l=this.serializerForSourceNode(e);b(this,te).get(e.id)?.resolve(),b(this,te).delete(e.id);let g=await l(e,{assetMap:this.assetMap,modulesStore:this.modulesStore,treeStore:this.treeStore,vectorsStore:this.vectorsStore,aiGenerationStore:this.aiGenerationStore,engineChanges:this.engineChanges,measureNodes:this.measureNodes},{serializationId:this.getSerializationId(),initialIntrinsicSize:n?.intrinsicSize,includeVectorSetSaveIds:n?.includeVectorSetSaveIds});return g.forEach(({source:y,artifacts:m})=>{if(U.trace("serializeComponent",`
>>>> >>>>
`,F(y),`
<<<< <<<<`),m?.submodules)for(let[S,I]of m.submodules)U.trace("serializeComponent",`
>>>>`,S,`>>>>
`,I,`
<<<<`,S,"<<<<")}),p.end(g),g};function Hl(o,t,e){let r=o.instanceIdentifier,n=de.dataForIdentifier(r);if(!n||!Object.values(n.properties).some(a=>a?.type==="image"))return;let s=new Set;for(let a of t.tree.root.children){if(!Pe(a))continue;if(L(a)&&a.dataIdentifier===r){s.add(a);continue}a.loaded?.some(d=>li(d)&&d.dataIdentifier===r)&&s.add(a)}s.forEach(a=>{e.forceComponentUpdate(a.id).catch(Xo)})}var yt=Tt(Zn());var Cc=Symbol("uninitialized");function Gl(o){return o+1}function NC(o,t,e,r){let n=Fi(),[,i]=(0,yt.useReducer)(Gl,0),s=(0,yt.useRef)(Cc);s.current===Cc&&(s.current=t());let a=(0,yt.useRef)(t);a.current=t;let c=(0,yt.useRef)(e);if(!Gr(e,c.current)){c.current=e;let p=s.current,l=a.current();(r?!it(p,l):!Gr(p,l))&&(s.current=l)}let d=Array.isArray(o)?o:[o];return(0,yt.useEffect)(()=>{let p=()=>{let y=s.current,m=a.current();(r?it(y,m):Gr(y,m))||(s.current=m,i())},l=[...d,p],g=n.scheduler.changes.observe(...l);return()=>n.scheduler.changes.removeObserver(g)},d),s.current}var Tc=class{constructor(){u(this,"undoBuffer",[]);u(this,"redoBuffer",[]);u(this,"undoGroup",[]);u(this,"scheduledEndUndoGroup")}canUndo(){return this.undoBuffer.length>0}peekUndo(){return this.undoBuffer.at(-1)}undo(t,e){let r=this.undoBuffer.pop();if(O(r))return;mo(t,r.changes),this.redoBuffer.push({...r,...e});let n=this.undoBuffer.length;return this.undoGroup.forEach((i,s)=>{this.undoGroup[s]=Math.min(i,n)}),r}canRedo(){return this.redoBuffer.length>0}peekRedo(){return this.redoBuffer.at(-1)}redo(t,e){let r=this.redoBuffer.pop();if(!O(r))return Ne(t,r.changes),this.undoBuffer.push({...r,...e}),r}beginUndoGroup(){this.undoGroup.push(this.undoBuffer.length)}discardUndoGroup(t){let e=this.undoGroup.pop();if(O(e)||e>=this.undoBuffer.length)return;let r=this.undoBuffer.splice(e),n=fo(r);return mo(t,n),r[0]}scheduleEndUndoGroup(){let t=this.undoGroup.pop();O(t)||t>=this.undoBuffer.length||(this.scheduledEndUndoGroup=t)}processScheduledEndUndoGroup(t){let e=this.scheduledEndUndoGroup;if(this.scheduledEndUndoGroup=void 0,O(e)||e>=this.undoBuffer.length)return;let r=this.undoBuffer.splice(e),n=fo(r);this.undoBuffer.push({changes:n,...t})}clearUndoStack(){this.undoBuffer.length=0,this.redoBuffer.length=0,this.undoGroup.length=0,this.scheduledEndUndoGroup=void 0}addUndoEntry(t){this.undoBuffer.push(t),this.redoBuffer.length=0}getUndoBufferSize(){return this.undoBuffer.length}};var se=Tt(Zn());var Kl=0,qn=class{constructor(){u(this,"id",++Kl);u(this,"currentRtt",NaN);u(this,"rtts",[]);u(this,"rttIndex",0);u(this,"pending",Array.from(Array(128),()=>({type:"",time:0})));u(this,"start",0);u(this,"end",0);u(this,"overflow",0);u(this,"lastSendTime",0);u(this,"bytesSent",0);u(this,"bytesReceived",0)}read(){let{bytesSent:t,bytesReceived:e,id:r}=this;return this.bytesSent=0,this.bytesReceived=0,[t,e,this.rtt(),r]}computeRtt(){let t=this.rtts.length;if(t===0){this.currentRtt=NaN;return}let e=0;for(let r of this.rtts)e+=r;this.currentRtt=e/t}lastSend(){return this.lastSendTime}rtt(){return Number.isNaN(this.currentRtt)&&this.computeRtt(),Math.max(this.currentRtt||0,this.pendingRtt())}pendingRtt(){if(this.start===this.end)return 0;let t=this.pending[this.start];return performance.now()-t.time}pendingCount(t){if(!t)return this.start>this.end?128-this.start+this.end:this.end-this.start;let e=0;for(let r=this.start;r!==this.end;r=r+1&127)this.pending[r].type===t&&e++;return e}sent(t,e){this.bytesSent+=e.length,this.end===(this.start===0?127:this.start-1)&&(this.start=this.start+1&127,this.overflow++);let r=this.pending[this.end];r.type=t,r.time=performance.now(),this.end=this.end+1&127,this.lastSendTime=r.time}received(t){this.bytesReceived+=t.length}acked(){if(this.start===this.end){console.warn("Called SocketStats.acked() with empty buffer");return}if(this.overflow>0){this.overflow--;return}let t=this.pending[this.start],e=performance.now()-t.time;this.rtts.length<32?this.rtts.push(e):(this.rtts[this.rttIndex]=e,this.rttIndex=this.rttIndex+1&31),this.start=this.start+1&127,this.currentRtt=NaN}};var tt=D("remote:socket"),Ql=28;function Xl(o){switch(o){case"AccessDenied":case"ClientNeedsUpdate":case"ClientTooNew":case"DocumentNotFound":case"UnsupportedSchema":case"Maintenance":case"UnknownPermanentError":case"ClientSidePermanentError":return!1;case"ReconnectToNewServer":case"UnknownRecoverableError":case"ClientSideRecoverableError":return!0;default:return ye(o)}}function BC({url:o,documentConnection:t,tunnel:e=null}){let r=(0,se.useRef)(null),n=(0,se.useRef)(!0),i=(0,se.useRef)({onConnect:new Set,onDisconnect:new Set,onMessage:new Set}),s=(0,se.useRef)(o),a=(0,se.useRef)(!0),c=(0,se.useRef)(void 0);function d(){c.current!==void 0&&(window.clearTimeout(c.current),c.current=void 0)}let p=(0,se.useCallback)(()=>{a.current=!1;let m=r.current;m&&m.ws.readyState<WebSocket.CLOSING&&(m.clientClosed=!0,m.ws.close())},[]),l=(0,se.useCallback)(()=>{if(d(),!a.current||r.current)return;function m(x){c.current===void 0&&(c.current=window.setTimeout(()=>{c.current=void 0,navigator.onLine&&!document.hidden&&l()},x))}let S=new URL(s.current);if(S.searchParams.set("v",Ql.toString()),S.searchParams.set("tunnel",e||""),hr()&&S.searchParams.set("mode","crdt"),t.treeSchema<=0)return;S.searchParams.set("treeSchema",t.treeSchema.toString()),S.searchParams.set("treeVersion",t.treeVersion.toString()),tt.debug("connecting to",S.href);let I=performance.now(),T=new WebSocket(S.href),N=new qn,C={ws:T,stats:N,clientClosed:!1};t.setSocketStats(N);let R=0;T.addEventListener("open",()=>{tt.debug("open"),R=window.setInterval(()=>{if(performance.now()-N.lastSend()<1e3||N.pendingCount("ping")>1||T.readyState!==WebSocket.OPEN)return;let x="ping {}";T.send(x),N.sent("ping",x)},1e3);for(let x of i.current.onConnect)try{x(n.current)}catch(V){tt.warn("Error in onConnect handler:",V)}n.current=!1}),T.addEventListener("close",x=>{let V=Zl(x);if(tt.debug("close:",V,"clientClosed:",C.clientClosed,x),R!==0&&(clearInterval(R),R=0),r.current===C){Xl(V)||(a.current=!1);for(let P of i.current.onDisconnect)try{P(V)}catch(Z){tt.warn("Error in onDisconnect handler:",Z)}if(r.current=null,a.current){let P=1e3;V==="ReconnectToNewServer"?P=50:performance.now()-I<5e3&&(P=5e3),m(P)}}}),T.addEventListener("message",x=>{try{let V=x.data;N.received(V);let P=eu(V);if(P.type==="ack"){N.acked();return}else P.type==="redirect"&&(s.current=P.value.url);for(let Z of i.current.onMessage)try{Z(P)}catch($){tt.warn("Error in onMessage handler:",$)}}catch(V){tt.warn("Error receiving:",V)}}),r.current=C},[t]);(0,se.useEffect)(()=>{l()},[l]);let g=(0,se.useCallback)(({online:m,visible:S})=>{m&&S?l():d()},[l]);return Yl(g),(0,se.useMemo)(()=>({getSocketStats(){return r.current?.stats},connect(){a.current=!0,l()},disconnect(){p()},onConnect(m){return i.current.onConnect.add(m),()=>{i.current.onConnect.delete(m)}},onDisconnect(m){return i.current.onDisconnect.add(m),()=>{i.current.onDisconnect.delete(m)}},onMessage(m){return i.current.onMessage.add(m),()=>{i.current.onMessage.delete(m)}},send(m){if(!r.current||r.current.ws.readyState!==1){m.type!=="state"&&tt.warn("Dropping",m.type,"message.");return}try{let S=`${m.type} ${JSON.stringify(m.value)}`;r.current.ws.send(S),r.current.stats.sent(m.type,S)}catch(S){tt.warn("Error sending",m.type,"message:",S)}}}),[l,p])}function Yl(o){(0,se.useEffect)(()=>{document.addEventListener("visibilitychange",t),window.addEventListener("online",t),window.addEventListener("offline",t);function t(){o({online:navigator.onLine,visible:!document.hidden})}return()=>{document.removeEventListener("visibilitychange",t),window.removeEventListener("online",t),window.removeEventListener("offline",t)}},[o])}function Zl(o){switch(o.reason){case"ERR_RECONNECT_TO_NEW_SERVER":return"ReconnectToNewServer";case"ERR_ACCESS_DENIED":return"AccessDenied";case"ERR_CLIENT_NEEDS_UPDATE":return"ClientNeedsUpdate";case"ERR_DOCUMENT_NOT_FOUND":return"DocumentNotFound";case"ERR_UNSUPPORTED_SCHEMA_VERSION":return"UnsupportedSchema";case"ERR_MAINTENANCE":return"Maintenance";case"ERR_INVALID_OPERATION":return"ClientSidePermanentError";case"ERR_UNKNOWN":return"UnknownPermanentError"}return o.code===1011?"ClientNeedsUpdate":"UnknownRecoverableError"}function eu(o){let t=o.indexOf(" "),e=o.indexOf(" ",t+1);h(t>=0&&e>=0,"Invalid data");let r=o.substring(0,t),n=o.substring(t+1,e),i=o.substring(e+1),s=JSON.parse(i);return{id:r,type:n,value:s}}function Wn(o){return typeof o=="object"&&!Array.isArray(o)&&o!==null}function wc(o,t){if(!Wn(o)&&Wn(t))return Object.assign({},t);if(!Wn(o)||!Wn(t))return t;for(let e of Object.keys(t))o[e]=wc(o[e],t[e]);return o}function qo(o,...t){let e=o;for(let r of t)e=wc(e,r);return e}function Ic(o){return o===void 0}function tu(o,t,e){let r=e.replicaInfo;if(r?.master){let s=o.get(r.master);if(!s||!At(s))return!0}if(r?.inheritsFrom){let s=o.get(r.inheritsFrom);if(!s||!(st(s)||At(s)))return!0}let n=e.parentid;if(!n)return!1;let i=o.get(n);return i?o.isAncestorOfNode(i,t):!0}function ru(o,t,{children:e,...r}){if(h(!o.has(t),"Tree must not have node",t),!r.parentid)return null;let n=o.get(r.parentid);if(!n||Pe(n)&&!n.isLoaded())return null;let i=r.__class;if(!i)throw new Error("Unknown node class for: "+t);let s=pr(i);if(!s)throw new Error("Unknown node class for: "+t);let a=r.replicaInfo;if(a){let d=o.get(a.master);if(!d||!At(d))throw Error("broken diff, replica without master: "+t+" "+a.master);let p=Ss(a),l=Qr.create(o,d,{overrides:p?.overrides,owner:t,inheritsFrom:p?.inheritsFrom,duplicatedFrom:r.duplicatedFrom,fromDiff:!0});return l.parentid=r.parentid,o.insertNode(l,l.parentid),l}if(ys(s)){h(Hi(t),"Invalid EntityReferenceNode ID: "+t);let d=new s({...lo(r),id:t});return o.insertNode(d,d.parentid),d}let c=new s({...lo(r),id:t});return o.insertNode(c,c.parentid),c}function nu(o,t){o.has(t)&&o.remove(t)}function ou(o,t,{children:e,...r}){let n=o.get(t);if(!n)return null;if(r.parentid&&n.parentid!==r.parentid){if(!o.has(r.parentid))return o.remove(t),null;o.move(t,r.parentid)}let i=n.asDraft(o);for(let s in r){let a=i[s];s==="replicaInfo"||typeof a!="object"||Array.isArray(a)||a===null||(r[s]=qo({},a,r[s]))}if(r.replicaInfo&&st(n)){let{overrides:s,_deleted:a,...c}=r.replicaInfo;for(let p in s){let l=s[p],g=i.replicaInfo?.overrides[p];g!==null&&typeof g=="object"&&!Array.isArray(g)&&(l=qo({},g,l)),l&&Cs(o,i,p,l)}let d=Object.assign(i.replicaInfo,c);return Ot.updateNode(o,i,r),i.replicaInfo=d,i.cache.rebuildReplica=!0,i}else return Ot.updateNode(o,n,r),i}function iu(o,t){if(o.length!==t.length)return!1;for(let e=0;e<o.length;e++)if(o[e].id!==t[e])return!1;return!0}function su(o,t,e){if(iu(t.children,e))return;let r=[];for(let s=0,a=e.length;s<a;s++){let c=o.get(e[s]);c&&c.parentid===t.id&&r.push(c)}let n=new Set(e),i=t.children;for(let s=0,a=i.length;s<a;s++){let c=i[s];n.has(c.id)||r.push(c)}gi(i,r)||(t.asDraft(o).children=r)}function Nc(o,t){o.applyingDiffs=!0;let e=Array.from(t.keys()),r=[...e];for(;r.length>0;){let n=[];for(let i of r){let s=t.get(i);Ic(s)||(tu(o,i,s)?n.push(i):o.has(i)?ou(o,i,s):s.__class&&ru(o,i,s))}if(n.length===0||n.length===r.length)break;r=n}for(let n of e){let s=t.get(n)?.children;if(!s||s.length===0)continue;let a=o.get(n);if(a){if(!a.children)throw Error("assertion failure: node has no children");su(o,a,s)}}for(let n of e){let i=t.get(n);Ic(i)&&nu(o,n)}return o.applyingDiffs=!1,o.commitDiffs()}function Wo(o,t){let e=o.getParentId(t);for(;e&&e!==Y;)e=o.getParentId(e);return e===Y}function au(o,t,e){let r=new Map;for(let[n,i]of t){if(Wo(o,n)){r.set(n,void 0);continue}let s=o.getObject(n);if(!s.__class||!pr(s.__class))continue;let a={id:n,parentid:o.getParentId(n),children:o.getChildrenIds(n)??[]},c=e.has(n)?Object.keys(s).map(d=>[d]):i;for(let d of c){let p=a,l=s;for(let[g,y]of d.entries()){if(y==="parentid"||y==="children"||y===ft)break;if(Array.isArray(p)){!p.length&&Array.isArray(l)&&p.push(...l);break}if(!(y in p))if(l?.[y]===void 0){p?._deleted||(p._deleted=[]),p._deleted.push(y);break}else if(g===d.length-1)p[y]=l[y];else{let S=Array.isArray(l[y]);p[y]=S?[]:{}}p=p[y],l=l[y]}}r.set(n,a),a.parentid&&(r.has(a.parentid)||r.set(a.parentid,{children:o.getChildrenIds(a.parentid)}))}return r}function Rc(o,t=0){let e=new Map,r=o.table.columns,n=o.getFirstRowForSeq(t);for(let i=n;i<r.client.length;++i){if(r.seq.get(i)<t)continue;let a=r.id.get(i),c=r.key.get(i),d=a.split("."),[p,...l]=d,g=e.get(p);g||(g=[],e.set(p,g)),l.push(c),g.push(l)}return e}function cu(o,t){let e=Rc(t),r=new Set;for(let[n,i]of e){let s=t.getCurrentSeq(n,"parentid");if(s===void 0||t.getParentId(n)===Y)continue;let c=o.getCurrentSeq(n,"parentid");c!==void 0&&(c>s||Wo(o,n)&&r.add(n))}return r}function du(o,t){let e=[...t];for(let r of e)for(let n of o.getChildrenIds(r)??[])e.push(n);return new Set(e)}function xc(o,t){let e=t.getRows();if(!e.length)return new Map;let r=cu(o,t),n=o.addRows(e);for(let s of Array.from(r))Wo(o,s)&&r.delete(s);r=du(o,r);let i=Rc(o,n);for(let s of r)i.has(s)||i.set(s,[]);return au(o,i,r)}var Jo=class{constructor(t,e){this.id=t;this.store=e;u(this,"loadedScope")}loadScopeDataFromStore(){let t=this.store.getObject(this.id);if(!t){Re.debug("No object with id "+this.id+" in the store");return}return t}createNodeFromData(t){let e=this.buildPage(t);if(e)return e.cache.isShallowLoad=!1,e}async run(t){if(this.loadedScope)return this.loadedScope;let e=performance.now(),r=this.loadScopeDataFromStore(),n=performance.now()-e;if(await t.yield(),this.loadedScope)return this.loadedScope;let i=performance.now(),s=this.createNodeFromData(r),a=performance.now()-i;return this.loadedScope=new Dt(s,n+a),this.loadedScope}force(){if(this.loadedScope)return this.loadedScope;let t=performance.now(),e=this.loadScopeDataFromStore(),r=this.createNodeFromData(e),n=performance.now()-t;return this.loadedScope=new Dt(r,n),this.loadedScope}buildPage(t){if(!t)return;let e=[],r=Re.isLoggingTraceMessages()?[]:void 0,n=lt(t,void 0,{extraChecksAndFixes:!0,errors:e,warnings:r});if(n&&hn(n,e),e.length>0&&Re.warn("errors loading server tree: "+e.join(`
`)),r&&r.length>0&&Re.trace("warnings loading server tree: "+r.join(`
`)),!!n)return n}},Re=D("CrdtDocumentLoader"),Fr=class extends xt{constructor(e,...r){super(...r);this.store=e;u(this,"parsedIds",new Set)}async loadFirstCrdtTree(e){let r=[],i=this.store.getObjectWithShallowChildren(e.rootId,2),s=i?.homePageNodeId,a=this.settings.activeNodeId,c=a?this.store.getObjectWithShallowChildren(a,2):void 0;if(c){for(;c.parentid!==e.rootId;){if(!c.parentid)throw Error("active node has no parent");c=this.store.getObjectWithShallowChildren(c.parentid,2)}s=c.id}let d=lt(i,null,{extraChecksAndFixes:!0,errors:r,warnings:r});if(!d)throw Error("Unable to create load document");let p=[...ia,s];for(let y of p){if(!y)continue;let m=this.store.getObject(y);if(!m){Re.debug("No value for "+y);continue}let S=lt(m);S.cache.isShallowLoad=!1;let I=d.children.findIndex(T=>T.id===y);d.children[I]=S,this.parsedIds.add(y)}for(let y of d.children)this.parsedIds.has(y.id)||this.scopesToLoad.add(y.id);ra(d,r),d.children.forEach(y=>{if(!this.parsedIds.has(y.id)&&Array.isArray(y.children)&&L(y)){y.cache.isShallowLoad=!0;return}});let l=an.createByAdoptingRoot(d);l.verify(),l=Qr.treeDidLoad(l,[]).didNonLinearMove(de);let g=[];return ta(l,g)&&(g.forEach(y=>{r.push(`${y.id}: code component links itself via ${y.stack}`),na(l,y.id,y.stack)}),l=l.commit()),await this.emitWrapped(()=>{if(this.scheduler.isDone())return;let y=performance.now();l.setService("loader",this),this.emit("loadedFirstData",l),fe("parsingFirstPage"),this.parsingDuration+=performance.now()-y}),l}async createTreeFromBuffer(e){this.documentSize=e.byteLength,this.store.fromBuffer(e);let r=this.store.getObject("meta");if(!r)throw new Error("Meta field not found");if(!ti(r.version))throw Error("cannot read document version");for(this.canvasTreeVersion=r.version,Re.debug("createTree",this.canvasTreeVersion,Rt(this.documentSize),pe(this.loadingDuration)),this.emit("loadedDocumentVersion",r.version),this.tree=await this.loadFirstCrdtTree(r),this.loadedFirstScope=!0,this.updatePauseResumeState(),await this.scheduler.yield(),fe("parsingResume");this.hasNextScopeToLoad();)await this.loadNextScopeAsync(),await this.scheduler.yield();await this.emitWrapped(()=>{h(this.tree,"tree must have been set"),this.tree.setService("loader",void 0),this.emit("loadedAllData")}),Re.debug("done",Rt(this.documentSize),"loading:",pe(this.loadingDuration),"parsing:",pe(this.parsingDuration))}async start(){await this.scheduler.run(async()=>{Re.debug("start"),fe("parsingInit"),this.updatePauseResumeState();let e=performance.now(),r=await this.loadCrdtData();this.loadingDuration=performance.now()-e,await this.scheduler.yield(),await this.createTreeFromBuffer(r)})}async loadCrdtData(){let e=this.settings.initData,r=e?.version===this.treeVersion,n=e?.prefetchPromise;if(Re.debug("loadData: prefetch"),r&&n){e&&delete e.prefetchPromise;let s=await n;if(n.then(a=>a.duration).then(a=>{fe("dataLoad",a)}),await this.scheduler.yield(),s.status<200||s.status>=300)throw new Error(`Failed to fetch project data. Status code: ${s.status}`);if(s.buffer){Re.debug("loadData: prefetch bytes parser");let a=await s.buffer;return await this.scheduler.yield(),new Uint8Array(a)}}Re.debug("loadData: fetch");let i;this.settings.refreshAccessToken&&(i=await this.settings.refreshAccessToken({}),await this.scheduler.yield());for(let s=0;s<wn;++s){let a=await fetch(this.documentURL,i);if(a.ok){await this.scheduler.yield();let c=await a.arrayBuffer();return await this.scheduler.yield(),new Uint8Array(c)}(a.status<200||a.status>=300)&&(Re.debug("onErrorStatusLoaded, retry:",s),await this.scheduler.sleep(s*yr+Math.random()*yr))}throw Error(`Failed to fetch project data after attempting ${wn} times`)}createLoadingScope(e){return new Jo(e,this.store)}};function Dc(o){if(!o.children)return;let t=new Map;for(let e of o.children)At(e)&&t.set(e.id,{master:e,replicas:new Map});for(let e of o.children){if(!st(e))continue;let r=t.get(e.replicaInfo.master);r&&r.replicas.set(e.id,e)}for(let{master:e,replicas:r}of t.values())lu(e,r)}function lu(o,t){for(let e of t.values()){let r=e.replicaInfo;h(r.master===o.id,"Replica must match master");let n=r.overrides;if(r.inheritsFrom){let l=t.get(r.inheritsFrom);l&&(n=Oi(n,l.replicaInfo.overrides))}let i=n[o.id],s=e.duplicatedFrom;Ot.copyToNode(e,o,i),e.duplicatedFrom=s;let a=!1;ki(e)&&(a=!0,zi(e,n,o),io(o,e));let c=e.id,d=o.children;if(!d)return;let p=new Array(d.length);for(let l=0,g=d.length;l<g;l++)p[l]=kc(c,n,d[l],c,a);e.children=p}}function kc(o,t,e,r,n){let i=lt({__class:e.__class,id:o+e.id,parentid:r});h(i,"Failed to create replica node");let s=t[e.id];if(Ot.copyToNode(i,e,s),i.duplicatedFrom=null,n&&io(e,i),e.children){let a=e.children,c=new Array(a.length);for(let d=0,p=a.length;d<p;d++)c[d]=kc(o,t,a[d],i.id,n);i.children=c}return i}var qe=D("remote:sync"),Ec=2**52,rr=class{constructor(t,e=0,r){this.timeline=t;u(this,"rollingDiff",null);u(this,"session",Math.floor(Math.random()*Ec));u(this,"seq",0);u(this,"treeVersion",0);u(this,"updatesSeen",0);u(this,"init",0);u(this,"expectingInitialUpdates",0);u(this,"localUpdatesInFlight",[]);u(this,"localUpdatesAtInit",[]);u(this,"hasError",!1);u(this,"waitingForTree",!1);this.setTree(t.tree,e,r)}get waitingForInitialUpdates(){return this.expectingInitialUpdates>this.updatesSeen}get isLoading(){return this.waitingForTree||this.waitingForInitialUpdates}get isReady(){return!(this.hasError||this.waitingForTree||this.waitingForInitialUpdates)}get tree(){return this.timeline.tree}error(t){return this.hasError=!0,Error(t)}verify(t,e){let r=this.timeline.getTreeForVersion(t);if(!r)return qe.info("verify: unable to find tree with version",t),!0;let n=r.computeTreeHash();if(n!==e){if(qe.warn("verify: failed",n,"!==",e),e===0)return!0;qe.reportError("Tree verification failed",{localHash:n,serverHash:e,treeVersion:t,treeSize:r.size()})}else qe.debug("verify: passed; hash:",e);return n===e}setTree(t,e,r){qe.info("setTree",e),this.timeline.reset(t,r),this.setRemoteTreeVersion(e),!!r?.isLoading&&Ke.isOn("rollingDiff")&&(this.rollingDiff=new kn,this.rollingDiff.addChanges(r?.initialChanges)),this.treeVersion=e,this.waitingForTree=!1,this.hasError=!1,this.localUpdatesInFlight=[]}resetSession(){this.treeVersion=0,this.session=Math.floor(Math.random()*Ec),this.localUpdatesInFlight=[],this.localUpdatesAtInit=[]}debugResetSessionAndTree(t){this.resetSession(),this.setTree(t,0)}handleInit(t,e){return this.init+=1,this.init===1&&fe("wsTreeInitMessages"),qe.info("init",this.init,{treeVersion:t,initialUpdates:e,localTreeVersion:this.treeVersion}),qe.debug("init updates:",{seen:this.updatesSeen,inFlight:this.localUpdatesInFlight.length,previous:this.localUpdatesAtInit.length}),this.hasError=!1,this.expectingInitialUpdates=e,this.updatesSeen=0,this.localUpdatesAtInit=this.localUpdatesInFlight.slice(),this.treeVersion!==t||this.waitingForTree?(this.waitingForTree=!0,!0):!1}trimForShallowLoading(){let t=this.timeline,e=this.getRemoteIndex()-3;e<=0||(t.trimmed+=e,qe.debug("trim",e,"new offset:",t.trimmed,"entries.length:",t.entries.length,"after load"),t.entries.splice(0,e),h(this.timeline.remoteTreeIndex===0||this.getRemoteIndex()>=0,"must have some buffer before remoteTreeIndex"))}loadedAllScopes(){let t=this.timeline;qe.info("done loading, took:",Math.round((performance.now()-t.resetTime)/100)/10,"seconds"),h(t.isPartialLoading,"Must be in loading mode"),t.isPartialLoading=!1,this.rollingDiff=null;let e=this.getRemoteEntry();e&&(e.version=t.remoteTreeVersion,this.trimForShallowLoading())}loadOneScope(t,e){let r=this.timeline;qe.debug("loadOneScope:",t.id),h(r.isPartialLoading,"Must be loading"),h(!t.cache.isShallowLoad,"Scope must not be shallow");let n=this.getRemoteEntry();h(n,"remote tree is missing");let i=r.tree.isViewOnly;n.tree.editClosed=!1,n.tree.isViewOnly=!1,n.tree.inEditor=!1,n.tree.makeLatest();let s=new Set,a=n.tree.root.children.findIndex(d=>d.id===t.id);if(t.__class==="WebPageNode"||t.__class==="SmartComponentNode"){Dc(t),n.tree=n.tree.commitWithLoadedScope(t);for(let d of t.walk())r.trackChange(d.id),s.add(d.id)}else n.tree.remove(t.id),n.tree.insertNode(t,n.tree.root.id,a);if(this.rollingDiff){let d=this.rollingDiff.getChanges();s.size>0?po(d,s)&&Ne(n.tree,d):Ne(n.tree,d)}else{let d=0,p=s.size>0,l=this.getRemoteIndex();for(let g of r.entries){if(d>l)break;d++,!g.wasScopeInsert&&(p&&!po(g.changes,s)||(p=!1,Ne(n.tree,g.changes)))}}a===-1?h(!n.tree.get(t.id),"Scope must have been deleted by remote diffs"):n.tree.loadReplicasAndCodeComponents(t);let c=n.tree.commit((d,p)=>{let l=d?.id??p?.id;l&&r.trackChange(l)});return n.tree.inEditor=!0,c.inEditor=!0,this.incrementRemoteTreeIndex(),e||(r.latestReversibleNodeChanges=null),this.addTreeToTimeline(c),r.legacyMode&&r.invalidateAllCursors(),c.isViewOnly=i,this.rollingDiff&&this.trimForShallowLoading(),r.tree}getRemoteEntry(){return this.timeline.getEntry(this.getRemoteIndex())}setRemoteTreeVersion(t){if(this.timeline.remoteTreeVersion=t,this.timeline.isPartialLoading)return;let e=this.getRemoteEntry();h(e,"remote tree is missing"),e.version=t}};var Pc=D("remote:sync"),Jn=class extends rr{constructor(e,r=0,n){super(e,r,n);u(this,"lastValidLocalIndex",0);u(this,"lastRemoteIndex",0);this.timeline.enableAddRemoveOptimizations=!1}setTree(e,r,n){super.setTree(e,r,n),this.lastValidLocalIndex=0,this.lastRemoteIndex=0}handleRemoteUpdate(e){if(this.hasError||this.waitingForTree)return;Pc.trace("this:",this.session,this.seq,"at:",this.treeVersion,"update:",e),this.updatesSeen+=1;let r=this.timeline,n=this.timeline.getLastEntry();h(n,"remote tree is missing");let i=r.tree.isViewOnly;n.tree.editClosed=!1,n.tree.isViewOnly=!1,n.tree.makeLatest(),n.tree.beginAllowPartialScopeAccess();let s=Nc(n.tree,e),{changes:a}=ws(n.tree,s);for(let c of a)r.trackChange(c.id,c);for(let c of n.tree.getNodesChangedByCommit())r.trackChange(c.id);return r.latestReversibleNodeChanges=null,this.timeline.addEntry(s,a,[],!1),this.lastRemoteIndex=this.timeline.length-1,this.trim(),this.setRemoteTreeVersion(this.treeVersion),n.tree.endAllowPartialScopeAccess(),s.isViewOnly=i,a}addTreeToTimeline(e){let r=this.timeline.addEntry(e,[]);r.wasScopeInsert=!0}getRemoteIndex(){return this.timeline.entries.length-1}incrementRemoteTreeIndex(){}hasOnlyEmptyChangesForRemote(){let e=this.lastValidLocalIndex,r=this.timeline.length-1;return e>=r?!0:this.timeline.computeForwardChanges(e,r).length===0}resetTreesForRecovery(){return this.timeline.resetTreesForRecovery(this.lastRemoteIndex-this.timeline.trimmed,this.lastValidLocalIndex-this.lastRemoteIndex)}trimForShallowLoading(){}trim(){if(this.timeline.isPartialLoading)return;let e=this.lastValidLocalIndex-this.timeline.trimmed-100;e<=75||(this.timeline.trimmed+=e,Pc.debug("trim",e,"new offset:",this.timeline.trimmed,"entries.length:",this.timeline.entries.length),this.timeline.entries.splice(0,e))}};var uu={cache:!0,update:!0,mutable:!0,children:!0};function fu(o,t){if(o!=="cached")return t}function Lc(o){return JSON.parse(JSON.stringify(o,fu))}function Hn(o,t,e){let r=new Set,n=!1;function i(a,c){r.add(a.id),c+="."+a.id;let d=t.get(a.id);if(!d)n=!0,e.push("-node: "+c+(Kr(a)?" (replica child)":""));else{let p=[],l=a.children?.map(y=>y.id).join(","),g=d.children?.map(y=>y.id).join(",");l!==g&&p.push(" .children: ["+l+"] != ["+g+"]");for(let[y,m]of a.entries()){if(y in uu)continue;let S=d[y];it(m,S)?m&&typeof m=="object"&&m.__proto__!==(typeof S=="object"&&S&&"__proto__"in S?S.__proto__:void 0)&&p.push(" ."+y+": different prototypes"):(m===void 0||S===void 0||!it(Lc(m),Lc(S)))&&y!=="contentHash"&&p.push(" ."+y+": "+JSON.stringify(m)+" != "+JSON.stringify(S))}p.length>0&&(n=!0,e.push("!node: "+c+(Kr(a)?" (replica child)":"")),e.push(...p))}for(let p of a.children??[])i(p,c)}function s(a,c){c+="."+a.id,r.has(a.id)||(n=!0,e.push("+node: "+c+(Kr(a)?" (replica child)":"")));for(let d of a.children??[])s(d,c)}return i(o.root,""),s(t.root,""),n}var ce=D("remote:connection"),Mt=D("remote:verify"),pu=5,Mc=class{constructor(t,e,r,n){this.userId=e;this.projectId=r;this.callbacks=n;u(this,"treeSync");u(this,"remoteUpdates",[]);u(this,"ignoreTreeVerifies",!1);u(this,"ignoreTreeVerifyVersion",0);u(this,"shouldCrashFromDebug",!1);u(this,"loader");u(this,"documentSize",0);u(this,"loaderPromise");u(this,"lastSyncSeq",0);u(this,"messageSeq",0);u(this,"unconfirmedCrdtRows",new Map);this.treeSync=new Jn(t),this.treeSync.waitingForTree=!0,window.store=this.store,t.validationEnabled=!1}get treeVersion(){return this.treeSync.treeVersion}get isReady(){return this.treeSync.isReady}get waitingForTree(){return this.treeSync.waitingForTree}get timeline(){return this.treeSync.timeline}get store(){return this.timeline.store}get isLoading(){return this.treeSync.isLoading}get localUpdatesInFlight(){return this.treeSync.localUpdatesInFlight}get localUpdatesAtInit(){return this.treeSync.localUpdatesAtInit}get hasError(){return this.treeSync.hasError}get init(){return this.treeSync.init}get session(){return this.treeSync.session}setTree(t,e,r){this.treeSync.setTree(t,e,r)}get hasUpdatesToProcess(){return!this.waitingForTree&&this.remoteUpdates.length>0}resetSession(){this.treeSync.resetSession(),this.unconfirmedCrdtRows.clear(),this.messageSeq=0}debugResetSessionAndTree(t){this.treeSync.debugResetSessionAndTree(t)}debugCrash(){this.shouldCrashFromDebug=!0}canProcessChanges(){if(this.treeSync.trim(),!this.treeSync.isReady||this.shouldCrashFromDebug){if(this.treeSync.hasOnlyEmptyChangesForRemote())return!1;let t="is not ready";throw this.treeSync.hasError?t="had an error":this.treeSync.waitingForTree?t="is waiting for tree data":this.treeSync.waitingForInitialUpdates?t="is waiting for initial updates":this.shouldCrashFromDebug&&(this.shouldCrashFromDebug=!1,t="is doing a deliberate crash test"),this.treeSync.error("cannot create local updates when the document "+t)}return!0}processViewOnly(){this.store.seq<this.lastSyncSeq||(this.lastSyncSeq=this.store.seq-1,ce.warn("cannot create local updates when the user is a viewer"))}resumeLoadingScopes(){this.loader?.resumeLoadingScopes()}handleRows(t,e){this.remoteUpdates.push(e)}handleConfirmRows(t){let e=this.unconfirmedCrdtRows.get(t);this.unconfirmedCrdtRows.delete(t),h(e,"rows not found for seq",t),this.treeSync.treeVersion+=1}handleInit(t,e){return this.remoteUpdates.length=0,{needsDownload:this.treeSync.handleInit(t,e)}}handleMigration(t){this.treeSync.treeVersion=t}handleReload(t){this.remoteUpdates.length=0,this.treeSync.hasError=!0;let e=new Error(t||"Server reloaded document.");this.callbacks.error(e)}handleTreeUpdate(){throw new Error("Json tree updates cannot be handled by Crdt data handler")}handleTreeVerify(t,e,r){if(!this.treeSync.isReady||this.ignoreTreeVerifies||this.ignoreTreeVerifyVersion===e)return;if(!this.treeSync.verify(e,r)){let s=this.treeSync.timeline.getTreeForVersion(e);if(s){let c=this.treeSync.timeline.entries.slice();this.verifyLocalTreeWithServer(t,s,e,c)}this.remoteUpdates.length=0,this.treeSync.hasError=!0;let a=new Error("Local document out of sync with document on server.");this.callbacks.error(a);return}let n=dn(),i=!!window.location.hostname.match(/development/u);if(n||i){let s=this.treeSync.timeline.getTreeForVersion(e);if(s){let a=this.treeSync.timeline.entries.slice();this.verifyLocalTreeWithServer(t,s,e,a)}}}processRemoteUpdates(){if(ce.debug("processRemoteUpdates: starting - waitingForTree:",this.treeSync.waitingForTree,"waitingForInitialUpdates:",this.treeSync.waitingForInitialUpdates,"hasError:",this.treeSync.hasError,"isReady:",this.isReady,"remoteUpdates.length:",this.remoteUpdates.length),this.treeSync.waitingForTree){ce.debug("processRemoteUpdates: exiting early - waitingForTree=true");return}let t;try{if(h(!this.timeline.tree.hasUncommittedChanges(),"tree must not have uncommitted changes"),this.shouldCrashFromDebug)throw this.shouldCrashFromDebug=!1,Error("RemoteDocument CrashTest");for(;this.remoteUpdates.length>0;){let e=this.remoteUpdates.shift();if(!e)break;this.treeSync.treeVersion+=1,t=e;let r=this.writeServerUpdateToTheStore(e);if(this.ensureAllScopesAreLoaded(r),r){let n=this.treeSync.handleRemoteUpdate(r);n&&this.loader?.addNodeChanges(n)}e.rows.length>0&&this.treeSync.expectingInitialUpdates>0&&(ce.debug("handleRows: counting",e.rows.length,"rows as updates toward initial updates"),this.treeSync.updatesSeen+=e.rows.length,ce.debug("handleRows: updatesSeen now:",this.treeSync.updatesSeen,"still expecting:",this.treeSync.expectingInitialUpdates-this.treeSync.updatesSeen))}if(this.loader){let e=this.timeline.tree.root.children;if(!e.some(n=>ut(n)&&n.isValid())){ce.info("cannot show any page, forcing load of next page");let n=e.find(s=>ut(s));if(!n)throw Error("No scope to load");let i=this.loader.loadScope(n.id);if(!i)throw Error("Unable to load scope");this.treeSync.loadOneScope(i,!1)}}this.callbacks.updateProcessed(this.timeline.tree)}catch(e){let r=_r(e);throw this.remoteUpdates.length=0,ce.error("Error processing remote updates:",r),ce.debug("Last update:",t),this.callbacks.errorRecoverable(),this.treeSync.error(r.message),r}}async verifyTreeWithServer(){let t=new URL(`/projects/${this.projectId}/tree/latest?forceSnapshot=true`,window.location.href),e;try{this.ignoreTreeVerifies=!0,e=await fetch(t,await jt.withAuthorizationHeader({}))}finally{this.ignoreTreeVerifies=!1}if(!e.ok)throw Error(`unable to fetch document json: ${e.status} ${e.statusText}`);let r=e.headers.get("etag")||"",n=Number.parseInt(r.match(/Version-(\d+)/u)?.[1]??"0",10);if(!Number.isFinite(n)||n<=0)throw Error(`unable to parse document tree version from: ${r}`);let i=this.treeSync.treeVersion-n,s=this.treeSync.timeline.getTreeForVersion(n);if(!s)throw Error(`unable to get the local tree for version ${n}`);this.ignoreTreeVerifyVersion=n;let a=await e.text(),c=await this.loadServerTree(a,t.toString(),n),d=this.compareTreeWithServerJson(s,c,n);if(d)throw d;return i}async loadServerTree(t,e,r){let n,i=new Fr(this.store,r,e,{partialParsing:!0,loadInBackground:!0,loadedData:t,requestIdleCallback:this.callbacks.requestIdleCallback});return i.on("loadedFirstData",s=>{i.on("loadedScope",a=>{let c=s.root.children.findIndex(d=>d.id===a.id);s.remove(a.id),s.insertNode(a,s.root.id,c),s=s.commit()}),i.on("loadedAllData",()=>{n=s})}),await i.start(),h(n,"loadedAllData not called"),n}clearRemoteUpdates(){this.remoteUpdates.length=0}flushUpdates(t){let e=this.getRowsToSend();return e.length<=0?!1:(this.send(t,e),!0)}resendUnconfirmedUpdates(t){h(this.isReady);let e=Array.from(this.unconfirmedCrdtRows.values());this.unconfirmedCrdtRows.clear();for(let n of e)this.send(t,n);let r=this.getRowsToSend();r.length<=0||this.send(t,r)}cancelAndClearLoader(){this.loader?.scheduler.cancel(),this.loader=void 0}maybeSend(t){if(!this.treeSync.isReady||this.store.seq<this.lastSyncSeq)return"nothingToSend";if(this.unconfirmedCrdtRows.size>=pu)return"postpone";let r=this.getRowsToSend();return r.length<=0?"nothingToSend":(this.send(t,r),"didSend")}send(t,e){let r=this.unconfirmedCrdtRows.size,n=++this.messageSeq;ce.debug("sending CRDT rows:",e.length,"inflight:",r,n),t.sendMessage({type:"rows",value:{seq:n,rows:e}}),this.unconfirmedCrdtRows.set(n,e)}writeServerUpdateToTheStore(t){let e=new kt({client:0,user:"temp-user"});return e.addRows(t.rows),xc(this.store,e)}ensureAllScopesAreLoaded(t){if(!this.loader)return;let e=new Set,r=this.timeline.tree;for(let[n,i]of t){let s=i?.parentid;if(!s)continue;let a=r.get(s);if(a){let d=r.getScopeNodeFor(a);d&&e.add(d.id)}let c=r.get(n)?.parentid;if(c){let d=r.get(c);if(d){let p=r.getScopeNodeFor(d);p&&e.add(p.id)}}}for(let n of e){if(this.loader.hasLoadedScope(n))continue;let i=this.loader.loadScope(n);i&&this.treeSync.loadOneScope(i,!1)}}createLoader(t,e,r){this.loader?.scheduler.cancel();let n=new Fr(this.store,e,t,r);return this.loader=n,n.on("loadedFirstData",()=>{this.lastSyncSeq=this.store.seq-1,ce.debug("Reset last sent seq to current store length:",this.lastSyncSeq)}),this.loader}finishLoading(){this.loader=void 0}async verifyLocalTreeWithServer(t,e,r,n){try{let i=t.replace(/\d+\.json/u,r+".json"),s=await fetch(i,await jt.withAuthorizationHeader({}));if(!s.ok)throw Error(`unable to fetch document json: ${s.status} ${s.statusText}`);let a=await s.text(),c=await this.loadServerTree(a,i,r);this.compareTreeWithServerJson(e,c,r,n)}catch(i){Mt.error("Error:",i)}}compareTreeWithServerJson(t,e,r,n){Mt.debug("local:",t.computeTreeHash(),t.size(),"remote:",e.computeTreeHash(),e.size(),"version:",r);let i,s=[];return Hn(t,e,s)?(Mt.warn(`trees are different
`+s.join(`
`)),n&&Mt.debug("timeline.entries",n),i=Error("Local document different from server document."),Mt.reportError(i,{differences:s,changes:n?.slice(-25).map(c=>c.changes)})):s.length>0?Mt.debug(`trees have warnings:
`+s.join(`
`)):Mt.debug("trees are same"),i}getRowsToSend(){let t=this.store.getFirstRowForSeq(this.lastSyncSeq),e=this.store.getRows(t);ce.debug("getRowsToSend: allRows from store:",e.length,"store total length:",this.store.length),ce.debug("store.client:",this.store.client),ce.debug("store.client (hashed):",this.store.client);let r=this.lastSyncSeq,n=[];for(let i=0;i<e.length;i++){let s=e[i];s.client===this.store.client&&(s.seq<=this.lastSyncSeq||(r<s.seq&&(r=s.seq),n.push({...s,user:this.userId})))}return ce.debug("getRowsToSend: returning",n.length,"rows"),ce.debug("Setting minSeqToSend from",this.lastSyncSeq,"to",r),this.lastSyncSeq=r,n}loadedAllScopes(){this.treeSync.loadedAllScopes()}loadOneScope(t,e){return this.treeSync.loadOneScope(t,e)}hasUnconfirmedChanges(){return this.unconfirmedCrdtRows.size>0}resetTreesForRecovery(){return this.treeSync.resetTreesForRecovery()}error(t){return this.treeSync.error(t)}};function Vc(o){return typeof o=="object"&&o!==null&&"next"in o}function Gn(o){return Vc(o)&&"session"in o}function Kn(o){return Vc(o)&&"changes"in o&&Array.isArray(o.changes)}function Qn(o){let{appEnvironment:t,session:e,seq:r,count:n,reasons:i,changes:s}=o;return{appEnvironment:t,session:e,seq:r,changes:s,count:n,reasons:i}}function Fc(o,t){return{...o,next:t}}var Le=D("remote:sync"),Xn=class extends rr{constructor(){super(...arguments);u(this,"localChangesSentToRemote",0)}setTree(e,r,n){super.setTree(e,r,n),this.localChangesSentToRemote=0}handleRemoteUpdate(e){if(this.hasError||this.waitingForTree)return;h(typeof e.next=="number","must be a valid tree update");let r=e.next;if(Le.trace("this:",this.session,this.seq,"at:",this.treeVersion,"update:",e),r!==this.treeVersion+1){if(r<=this.treeVersion){Le.debug("ignoring old update:",r," <= ",this.treeVersion);return}throw this.error("missing update: "+this.treeVersion+" + 1 != "+r)}if(this.updatesSeen+=1,this.treeVersion=r,Gn(e)&&e.session===this.session){let n=this.localUpdatesInFlight[0];if(n?.seq===e.seq)this.localUpdatesInFlight.shift(),this.confirmLocalChangesByRemote(n.count,r),n.confirmed=!0;else{let i=this.localUpdatesAtInit.find(s=>s.seq===e.seq);if(i)this.insertRemoteChanges(i.changes,r),i.confirmed=!0;else{let s=this.localUpdatesInFlight.findIndex(c=>c.seq===e.seq),a=s===-1?"unknown local update: "+e.seq+" != "+n?.seq:"missing local update: "+e.seq+" != "+n?.seq+", is index: "+s;throw this.error(a)}}}else Kn(e)?e.changes.length>0&&this.insertRemoteChanges(e.changes,r):Le.reportErrorOncePerMinute(new Error("Unknown remote update"),{update:e})}confirmLocalChangesByRemote(e,r=0){let n=this.timeline;if(h(e>=1,"cannot confirm less than one change"),h(this.localChangesSentToRemote>=e,"cannot confirm local changes that have not been sent"),h(n.remoteTreeIndex<n.localTreeIndex,"must have unconfirmed local changes"),this.rollingDiff)for(let i=1;i<=e;i++)this.rollingDiff.addChanges(n.getEntry(n.remoteTreeIndex+i)?.changes);return this.localChangesSentToRemote-=e,n.incrementRemoteTreeIndex(e),this.setRemoteTreeVersion(r),n.tree}insertRemoteChanges(e,r=0){let n=this.timeline;Le.debug("insertRemoteChanges:",e.length),h(n.tree===n.getLastEntry().tree,"tree out of sync"),h(n.remoteTreeIndex<=n.localTreeIndex,"remote tree too far ahead"),this.rollingDiff&&this.rollingDiff.addChanges(e);let i=this.getRemoteEntry();h(i,"remote tree is missing");let s=n.tree.isViewOnly;i.tree.editClosed=!1,i.tree.isViewOnly=!1,i.tree.makeLatest(),i.tree.beginAllowPartialScopeAccess(),Ne(i.tree,e);let a=i.tree.commitDiffs();for(let d of e)n.trackChange(d.id,d);for(let d of i.tree.getNodesChangedByCommit())n.trackChange(d.id);n.incrementRemoteTreeIndex(1),n.latestReversibleNodeChanges=null;let c=n.entries.length-this.getRemoteIndex();return h(c>=0,"computed rebase is off"),c===0?this.addRemoteTreeWithChanges(a,e):this.rebaseRemoteTreeWithChanges(a,e,c),this.trim(),this.setRemoteTreeVersion(r),i.tree.endAllowPartialScopeAccess(),a.isViewOnly=s,n.tree}addRemoteTreeWithChanges(e,r){Le.trace("addRemoteTreeWithChanges:",r.length);let n=this.timeline.getLastEntry();return h(e.lineage===n.tree.lineage,"Trees must belong to the same line."),h(!e.hasUncommittedChanges(),"Tree cannot have uncommitted changes."),n.tree!==e&&n.tree.releaseMemory(),this.timeline.addEntry(e,r)}rebaseRemoteTreeWithChanges(e,r,n){let i=this.timeline;Le.debug("rebaseRemoteTreeWithChanges:",n,"changes:",r.length),h(e.lineage===i.getLastEntry().tree.lineage,"Trees must belong to the same line."),h(!e.hasUncommittedChanges(),"Tree cannot have uncommitted changes."),h(i.entries.length>=n,"rebase",n,"> commits",i.entries.length);let s=i.entries.splice(i.entries.length-n,n);h(s.length===n,"must have",n,"entries to process");let a=i.addEntry(e,r,[],!0),c=e;for(let d=0;d<n;d++){let p=s[d];Ne(e,p.changes),e=e.commitDiffs();for(let l of p.changes)i.trackChange(l.id,l);for(let l of c.getNodesChangedByCommit())i.trackChange(l.id);i.addEntry(e,p.changes,p.editReasons,p.wasRebase),e!==c&&(c.releaseMemory(),c=e)}return i.tree=e,a}addTreeToTimeline(e){let n=this.timeline.entries.length-this.getRemoteIndex();h(n>=0,"computed rebase is off");let i;n===0?i=this.addRemoteTreeWithChanges(e,[]):i=this.rebaseRemoteTreeWithChanges(e,[],n),i.wasScopeInsert=!0}loadCompleteTree(e,r=0){let n=this.timeline;Le.debug("load complete tree:",n.tree.sizeAtStart(),"->",e.size(),"entries:",n.entries.length),h(n.trimmed===0,"cannot load complete tree while having local changes"),h(!e.hasUncommittedChanges(),"tree should be clean"),n.entries.forEach((c,d)=>{d>n.remoteTreeIndex||Ne(e,c.changes)}),e.hasUncommittedChanges()&&(e=e.commitDiffs());let i=[],s=n.tree;if(s.sizeAtStart()*2>e.size()){let c={};for(let d of e.root.walk()){let p=s.getNodeAtStart(d.id)||void 0,l=on(p,d);l&&(c[l.id]=l),n.trackChange(d.id,l)}i=Object.values(c),Le.debug("load complete tree, diff:",i.length)}else n.invalidateAllCursors(),Le.debug("load complete tree, resending:",n.tree.size());n.incrementRemoteTreeIndex(1),n.latestReversibleNodeChanges=null;let a=n.entries.length-n.remoteTreeIndex;return h(a>=0,"computed rebase is off"),e.lineage!==n.tree.lineage?(n.reset(e),this.setRemoteTreeVersion(r),n.tree):(a===0?this.addRemoteTreeWithChanges(e,i):this.rebaseRemoteTreeWithChanges(e,i,a),this.setRemoteTreeVersion(r),this.trim(),n.tree.forEachNode(c=>n.trackChange(c.id)),n.tree)}incrementRemoteTreeIndex(){this.timeline.incrementRemoteTreeIndex(1)}getRemoteIndex(){return this.timeline.remoteTreeIndex-this.timeline.trimmed}getUnconfirmedChangeCount(){return this.timeline.localTreeIndex-this.timeline.remoteTreeIndex}hasChangesForRemote(){let e=this.timeline.remoteTreeIndex+this.localChangesSentToRemote,r=this.timeline.localTreeIndex;return h(e<=r,"inconsistency in getting local changes to send"),e<r}hasOnlyEmptyChangesForRemote(){let e=this.timeline.remoteTreeIndex+this.localChangesSentToRemote,r=this.timeline.localTreeIndex;return e>=r?!0:this.timeline.computeForwardChanges(e,r).length===0}createUpdateToSend(){if(!this.isReady)throw Error("cannot create updates while not ready");if(!this.hasChangesForRemote())return null;let{changes:e,count:r,reasons:n}=this.getForwardChangesForRemote(),i=++this.seq,s={session:this.session,seq:i,changes:e,count:r,reasons:n,confirmed:!1};return this.localUpdatesInFlight.push(s),s}getForwardChangesForRemote(){let e=this.timeline.remoteTreeIndex+this.localChangesSentToRemote,r=this.timeline.localTreeIndex,n=this.timeline.getChangesBetweenEntries(e,r);return this.localChangesSentToRemote+=n.count,n}commitAndCreateUpdate(e=0){h(ot.isTest),this.timeline.commitLocalTree();let r=this.createUpdateToSend();return r?Fc(r,e):null}resetTreesForRecovery(){return Le.info("reset trees for recovery, remote:",this.getRemoteIndex(),"last index:",this.timeline.localTreeIndex,"number of entries to reapply to remote tree",this.localChangesSentToRemote),this.timeline.resetTreesForRecovery(this.getRemoteIndex(),this.localChangesSentToRemote)}trim(){if(this.timeline.isPartialLoading)return;let e=0;this.timeline.remoteTreeIndex>0?e=this.getRemoteIndex()-100:e=this.timeline.localTreeIndex-this.timeline.trimmed-100,!(e<=75)&&(this.timeline.trimmed+=e,Le.debug("trim",e,"new offset:",this.timeline.trimmed,"entries.length:",this.timeline.entries.length),this.timeline.entries.splice(0,e),h(this.timeline.remoteTreeIndex===0||this.getRemoteIndex()>=0,"must have some buffer before remoteTreeIndex"))}};var nr=D("remote:connection"),Vt=D("remote:verify"),mu=5,Uc=class{constructor(t,e,r){this.projectId=e;this.callbacks=r;u(this,"treeSync");u(this,"remoteUpdates",[]);u(this,"ignoreTreeVerifies",!1);u(this,"ignoreTreeVerifyVersion",0);u(this,"shouldCrashFromDebug",!1);u(this,"loader");this.treeSync=new Xn(t),this.treeSync.waitingForTree=!0}get init(){return this.treeSync.init}setTree(t,e,r){this.treeSync.setTree(t,e,r)}get timeline(){return this.treeSync.timeline}get treeVersion(){return this.treeSync.treeVersion}get isReady(){return this.treeSync.isReady}get waitingForTree(){return this.treeSync.waitingForTree}get isLoading(){return this.treeSync.isLoading}get session(){return this.treeSync.session}resetSession(){this.treeSync.resetSession()}debugResetSessionAndTree(t){this.treeSync.debugResetSessionAndTree(t)}debugCrash(){this.shouldCrashFromDebug=!0}canProcessChanges(){if(this.treeSync.trim(),!this.treeSync.isReady||this.shouldCrashFromDebug){if(this.treeSync.hasOnlyEmptyChangesForRemote())return!1;let t="is not ready";throw this.treeSync.hasError?t="had an error":this.treeSync.waitingForTree?t="is waiting for tree data":this.treeSync.waitingForInitialUpdates?t="is waiting for initial updates":this.shouldCrashFromDebug&&(this.shouldCrashFromDebug=!1,t="is doing a deliberate crash test"),this.treeSync.error("cannot create local updates when the document "+t)}return!0}processViewOnly(){if(!this.treeSync.hasChangesForRemote())return;let{changes:t,count:e}=this.treeSync.getForwardChangesForRemote();nr.warn("cannot create local updates when the user is a viewer, ignoring:",t),this.treeSync.confirmLocalChangesByRemote(e)}maybeSend(t){if(!this.treeSync.isReady||!this.treeSync.hasChangesForRemote())return"nothingToSend";let e=this.treeSync.localUpdatesInFlight.length;if(e>=mu)return"postpone";let r=this.treeSync.createUpdateToSend();return r?(nr.debug("sending update:",e,r.changes.length,r.reasons),t.sendMessage({type:"treeUpdate",value:Qn(r)}),"didSend"):"nothingToSend"}resumeLoadingScopes(){this.loader?.resumeLoadingScopes()}handleRows(){throw Error("Crdt tree updates cannot be handled by Json data handler")}handleConfirmRows(){throw Error("Crdt tree updates cannot be handled by Json data handler")}get hasUpdatesToProcess(){return!this.waitingForTree&&this.remoteUpdates.length>0}handleInit(t,e){return this.remoteUpdates.length=0,{needsDownload:this.treeSync.handleInit(t,e)}}handleMigration(t){this.treeSync.treeVersion=t}handleReload(t){this.remoteUpdates.length=0,this.treeSync.hasError=!0;let e=new Error(t||"Server reloaded document.");this.callbacks.error(e)}handleTreeVerify(t,e,r){if(!this.treeSync.isReady||this.ignoreTreeVerifies||this.ignoreTreeVerifyVersion===e)return;if(!this.treeSync.verify(e,r)){let s=this.treeSync.timeline.getTreeForVersion(e);if(s){let c=this.treeSync.timeline.entries.slice();this.verifyLocalTreeWithServer(t,s,e,c)}this.remoteUpdates.length=0,this.treeSync.hasError=!0;let a=new Error("Local document out of sync with document on server.");this.callbacks.error(a);return}let n=dn(),i=!!window.location.hostname.match(/development/u);if(n||i){let s=this.treeSync.timeline.getTreeForVersion(e);if(s){let a=this.treeSync.timeline.entries.slice();this.verifyLocalTreeWithServer(t,s,e,a)}}}async verifyLocalTreeWithServer(t,e,r,n){try{let i=t.replace(/\d+\.json/u,r+".json"),s=await fetch(i,await jt.withAuthorizationHeader({}));if(!s.ok)throw Error(`unable to fetch document json: ${s.status} ${s.statusText}`);let a=await s.text(),c=await this.loadServerTree(a,i,r);this.compareTreeWithServerJson(e,c,r,n)}catch(i){Vt.error("Error:",i)}}compareTreeWithServerJson(t,e,r,n){Vt.debug("local:",t.computeTreeHash(),t.size(),"remote:",e.computeTreeHash(),e.size(),"version:",r);let i,s=[];return Hn(t,e,s)?(Vt.warn(`trees are different
`+s.join(`
`)),n&&Vt.debug("timeline.entries",n),i=Error("Local document different from server document."),Vt.reportError(i,{differences:s,changes:n?.slice(-25).map(c=>c.changes)})):s.length>0?Vt.debug(`trees have warnings:
`+s.join(`
`)):Vt.debug("trees are same"),i}handleTreeUpdate(t){this.remoteUpdates.push(t)}processRemoteUpdates(){if(this.treeSync.waitingForTree)return;let t;try{if(h(!this.timeline.tree.hasUncommittedChanges(),"tree must not have uncommitted changes"),this.shouldCrashFromDebug)throw this.shouldCrashFromDebug=!1,Error("RemoteDocument CrashTest");for(;this.remoteUpdates.length>0;){let e=this.remoteUpdates.shift();if(!e)break;t=e,this.ensureAllScopesAreLoaded(e),this.treeSync.handleRemoteUpdate(e),this.loader&&!Gn(e)&&this.loader.addNodeChanges(e.changes)}if(this.loader){let e=this.timeline.tree.root.children;if(!e.some(n=>ut(n)&&n.isValid())){nr.info("cannot show any page, forcing load of next page");let n=e.find(s=>ut(s));if(!n)throw Error("No scope to load");let i=this.loader.loadScope(n.id);if(!i)throw Error("Unable to load scope");this.treeSync.loadOneScope(i,!1)}}this.callbacks.updateProcessed(this.timeline.tree)}catch(e){let r=_r(e);throw this.remoteUpdates.length=0,nr.error("Error processing remote updates:",r),nr.debug("Last update:",t),this.treeSync.error(r.message),this.callbacks.errorRecoverable(),r}}ensureAllScopesAreLoaded(t){if(!this.loader||!Kn(t))return;let e=new Set;for(let r of t.changes)r.previousScope&&(e.add(r.previousScope),e.add(r.to.parentid));for(let r of e){if(this.loader.hasLoadedScope(r))continue;let n=this.loader.loadScope(r);n&&this.treeSync.loadOneScope(n,!1)}}createLoader(t,e,r){this.loader?.scheduler.cancel();let n=new xt(e,t,r);return this.loader=n,this.loader}async verifyTreeWithServer(){let t=new URL(`/projects/${this.projectId}/tree/latest?forceSnapshot=true`,window.location.href),e;try{this.ignoreTreeVerifies=!0,e=await fetch(t,await jt.withAuthorizationHeader({}))}finally{this.ignoreTreeVerifies=!1}if(!e.ok)throw Error(`unable to fetch document json: ${e.status} ${e.statusText}`);let r=e.headers.get("etag")||"",n=Number.parseInt(r.match(/Version-(\d+)/u)?.[1]??"0",10);if(!Number.isFinite(n)||n<=0)throw Error(`unable to parse document tree version from: ${r}`);let i=this.treeSync.treeVersion-n,s=this.treeSync.timeline.getTreeForVersion(n);if(!s)throw Error(`unable to get the local tree for version ${n}`);this.ignoreTreeVerifyVersion=n;let a=await e.text(),c=await this.loadServerTree(a,t.toString(),n),d=this.compareTreeWithServerJson(s,c,n);if(d)throw d;return i}async loadServerTree(t,e,r){let n,i=new xt(r,e,{partialParsing:!0,loadInBackground:!0,loadedData:t,requestIdleCallback:this.callbacks.requestIdleCallback});return i.on("loadedFirstData",s=>{i.on("loadedScope",a=>{let c=s.root.children.findIndex(d=>d.id===a.id);s.remove(a.id),s.insertNode(a,s.root.id,c),s=s.commit()}),i.on("loadedAllData",()=>{n=s})}),await i.start(),h(n,"loadedAllData not called"),n}clearRemoteUpdates(){this.remoteUpdates.length=0}get localUpdatesInFlight(){return this.treeSync.localUpdatesInFlight}get localUpdatesAtInit(){return this.treeSync.localUpdatesAtInit}get hasError(){return this.treeSync.hasError}flushUpdates(t){if(this.localUpdatesInFlight.length===0)return!1;let e=this.treeSync.createUpdateToSend();return e&&t.sendMessage({type:"treeUpdate",value:Qn(e)}),!0}resendUnconfirmedUpdates(t){h(this.isReady);let e=this.localUpdatesAtInit.filter(r=>!r.confirmed);if(e.length!==0){nr.debug("resending local updates:",e.length);for(let r of e)t.sendMessage({type:"treeUpdate",value:Qn(r)})}}cancelAndClearLoader(){this.loader?.scheduler.cancel(),this.loader=void 0}finishLoading(){this.loader=void 0}loadOneScope(t,e){return this.treeSync.loadOneScope(t,e)}loadedAllScopes(){this.treeSync.loadedAllScopes()}hasUnconfirmedChanges(){return this.treeSync.getUnconfirmedChangeCount()>0}resetTreesForRecovery(){return this.treeSync.resetTreesForRecovery()}error(t){return this.treeSync.error(t)}};var hu=D("exportToHTML");function Ac(o,t,e,r=new Set([t]),n=new Set){for(let{node:i,skipChildren:s}of t.walkWithSkipChildren()){if(n.has(i)){s();continue}n.add(i);for(let a of es(i,e)){let c=Zi(a);if(!c)continue;let d=o.getNode(c);if(d){if(!o.isGroundNode(d)){hu.reportError("Navigation target node must be ground node",{sourceId:i.id,targetId:d.id});continue}r.add(d),Ac(o,d,e,r,n)}}at(i)&&Object.values(Is(o,i,e)).flat().forEach(a=>Ac(o,a.node,e,r,n))}return r}function Iw(o,t){let e=t.getPrimaryVariant();ao(e)&&(o.routes[t.id]=e.pageEffects)}function Nw(o,t,e){let r=t.getPrimaryVariant();if(ao(r)){let n={};for(let i in r.pageEffects)n[i]=e.dedupe("effect",r.pageEffects[i]);o.routes[t.id]=n}}var Bc="utils";function kw(o,t){if(!L(t)||!t.dataIdentifier)return;let e=nt(t.dataIdentifier);if(!Yo(e)||e.kind!=="localModuleExport")return;let r=o.getPersistedModuleByLocalId(e.localId);if(r&&r.exports.includes(Bc))return{exportIdentifier:Bc,moduleURL:r.moduleURL,collectionId:e.localIdName}}function Mw(o,t,e,r=void 0){if(!e&&!r)return;let n=r??Rs(e??[]);n.length&&Zs.resetPropertiesToMasterValues(o,t,n)}export{Hc as a,Ma as b,Va as c,Lt as d,uc as e,dc as f,td as g,qp as h,Wp as i,nd as j,Dv as k,Lv as l,Er as m,ht as n,Aa as o,Sc as p,Ac as q,Iw as r,Nw as s,kw as t,Mw as u,ku as v,Eu as w,Pu as x,vo as y,xt as z,Fr as A,Qu as B,xa as C,NC as D,Tc as E,qn as F,Ql as G,Xl as H,BC as I,Zl as J,eu as K,Mc as L,Uc as M};
//# sourceMappingURL=https://app.framerstatic.com/chunk-6RQGRTAF.mjs.map
